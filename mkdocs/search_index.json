{
    "docs": [
        {
            "location": "/install-docker-quickstart/", 
            "text": "Docker quickstart\n\n\nTo start developing with Nakama, you\nll first need to install it on your development machine. It\ns straightforward and takes just a few minutes. In this guide we\nre going to focus on installing your Nakama development instance using Docker.\n\n\n\n\nRecommended Approach\n\n\nDocker is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a \nbinary\n to ensure all system resources are available to Nakama.\n\n\n\n\nThere is a single, minimal Nakama image that contains the Nakama binary. The basic format is:\n\n\ndocker run heroiclabs/nakama \ncommand\n \n[\noptions\n]\n\n\n\n\n\n\nInstalling Nakama using Docker is ideal for a few reasons, including:\n\n\n\n\n\n\nyou install to a pristine environment\n\n\n\n\n\n\nyou get everything you need in one go, including CockroachDB\n\n\n\n\n\n\nyou can take snapshots, re-install and remove Nakama without affecting your primary operating system.\n\n\n\n\n\n\nIt also means that the installation instructions are the same whether your development machine runs Windows, MacOS and Linux.\n\n\n\n\n\n\nWhat is Docker?\n\n\nIf you\nre new to Docker, then here\ns what you need to know: Docker is an open soure containerization tool that lets you create multiple distinct Linux environments, each separate from the other.\n\n\nIn a Docker container you run a suite of tools to do a particular job; in this case we\nll have one container running Nakama and another running CockroachDB. You can think of Docker containers as lightweight virtual machines.\n\n\n\n\n\n\nFollow this \nguide\n, if you are trying to install Docker on Mac, Linux and Windows 10 Pro edition.\n\n\n\n\n\n\nDocker Toolbox\n is needed, if you are installing Docker on Windows 7, 8 or 10 Home (non-Pro) editions.\n\n\n\n\n\n\nUse the \nDocker Store\n to find the right version of Docker Community Edition for your environment.\n\n\n\n\n\n\nConnecting the Nakama client\n\n\nOnce Nakama is running via Docker, use the following connection detail to configure your client to connect to the server:\n\n\nHost\n: \n127.0.0.1\n (or \nlocalhost\n)  \n\n\nPort\n : \n7350\n   \n\n\nSSL\n: \nFalse\n  \n\n\nServer Key\n: \ndefaultkey\n     \n\n\nIn the Unity client, you can create an \nNClient\n like this:\n\n\nINClient\n \nclient\n \n=\n \nnew\n \nNClient\n.\nBuilder\n(\ndefaultkey\n)\n\n    \n.\nHost\n(\n127.0.0.1\n)\n\n    \n.\nPort\n(\n7350\n)\n\n    \n.\nSSL\n(\nfalse\n)\n\n    \n.\nBuild\n();\n\n\n\n\n\n\nRunning Nakama\n\n\nYou can run Nakama and Cockroach without using Docker-Compose. This will mean you have greater control over how they are started, and various data volumes options but in return, you'll have to configure the two containers:\n\n\n# Let\ns pull and start CockroachDB\n\ndocker run --name\n=\ndb cockroachdb/cockroach start --insecure\n\n# Let\ns pull and migrate the database\n\ndocker run --link\n=\ndb heroiclabs/nakama migrate up --db root@db:26257\n\n# start Nakama server\n\ndocker run --link\n=\ndb -p \n7350\n:7350 heroiclabs/nakama --db root@db:26257\n\n\n\n\n\nUsing Docker-Compose\n\n\nDocker Compose simplifies running more than one Docker container in conjunction. For Nakama, we\nll need two containers: one for Nakama itself and one for the database it relies on, CockroachDB.\n\n\nYou can choose to configure the Nakama and CockroachDB containers without Docker Compose but we do not recommend it when you\nre starting out.\n\n\nDocker Compose uses YAML configuration files to declare which containers to use and how they should work together.\n\n\n\n\nLet\ns start by downloading the \nNakama Docker Compose file\n:\n\n\n\n\nwget https://raw.githubusercontent.com/heroiclabs/nakama/master/install/docker/docker-compose.yml\n\n\n\n\n\n\n\nWindows users\n\n\nIf you are trying to run Nakama via Docker-Compose on Windows, you'll need to make a small change to the downloaded \ndocker-compose.yml\n file. Follow this \ninstruction\n to bind the correct path.\n\n\n\n\nThis will download \ndocker-compose.yml\n to your current working directory.\n\n\n\n\nNext, we\nll ask Docker Compose to follow the instructions in the file we just downloaded:\n\n\n\n\ndocker-compose -f docker-compose.yml up\n\n\n\n\n\nDocker Compose will download the latest CockroachDB and Nakama images published on Docker Hub.\n\n\n\n\nYou now have both CockroachDB and Nakama running on your machine, available at \n127.0.0.1:26257\n and \n127.0.0.1:7350\n respectively.\n\n\n\n\nDocker-Compose Data\n\n\nDocker containers are ephemeral by design: when you remove the container, you lose the data stored inside them.\n\n\nFor development purposes, we suggest that you bind a folder in the local machine's filesystem to the Docker file system. The easiest way to achieve this is by editing the \ndocker-compose.yml\n file:\n\n\n...\nnakama:\n  image: heroiclabs/nakama:latest\n  entrypoint:\n    - /bin/bash\n    - -ecx\n    - /nakama/nakama migrate up --db \nroot@cockroachdb:26257\n \n /nakama/nakama --db \nroot@cockroachdb:26257\n\n  volumes:\n\n    - ./nakama/data:/nakama/data # Edit this line\n\n  expose:\n    - \n7350\n\n...\n\n\n\n\n\n\n\nOn Mac and Linux systems, the path highlighted above will create a folder called \nnakama\n in the same directory as where you are running \ndocker-compose\n from.\n\n\nOn Windows, you'll need to update the path above so that Docker can bind the folder properly. A valid value can look like this: \nC:/users/\nusername\n/projects/docker\n.\n\n\n\n\n\n\nDrive Binding on Windows\n\n\nDocker will complain about an unshared Drive if you the path above is not changed or is not available. The error looks like this:\n\n\nERROR: for bin_nakama_1 Cannot create container for service nakama: Drive has not been shared\n\n\nMake sure to change the line highlighted above to the correct path and restart Nakama.\n\n\n\n\nYou can put your Lua scripts in the \ndata/modules\n directory and restart Nakama using \ndocker-compose --restart\n.\n\n\nLogs\n\n\nLogs generated within the containers are printed to the console as part of the docker-compose output, and you can access them with \ndocker-compose logs\n from within the same the directory as the \ndocker-compose.yml\n file.\n\n\nStopping containers\n\n\nIf you need to temporarily pause the Docker containers, without losing the state of those containers, you have two options:\n\n\n\n\nIn the terminal where docker-compose is currently running, hit CTRL-C.\n\n\nOr run \ndocker-compose stop\n in the same directory as docker-compose.yml and all containers will be shut down gracefully.\n\n\n\n\nYou can re-activate them by running \ndocker-compose up\n.\n\n\nTo stop the containers and purge all stored data, run \ndocker-compose down\n.\n\n\nUpgrade\n\n\nAs new versions of Nakama, or CockroachDB, become available you might want to upgrade. Docker makes upgrading easy, as all you need to do is pull down a new version of the container image.\n\n\n\n\nSchema migration\n\n\nWhen upgrading to a new version of Nakama, the process in the \ndocker-compose.yml\n performs a migration of your data to the new database schema.\n\n\n\n\nyou can pull down the most recent Nakama image and allow Docker Compose to perform the data migration.\n\n\ndocker-compose down \n# top and remove both the Nakama and CockroachDB containers\n\ndocker pull heroiclabs/nakama \n# download the latest Nakama image\n\ndocker-compose up \n# start the containers (both Nakama and CockroachDB) as fresh installss\n\n\n\n\n\n\nAnd, similarly, here\ns how to update the CockroachDB container:\n\n\ndocker pull cockroachdb/cockroach \n# download the latest CockroachDB image\n\n\n\n\n\n\nIf you'd like to explicity run a database schema migration, issue the following command:\n\n\ndocker run heroiclabs/nakama migrate up", 
            "title": "Docker quickstart"
        }, 
        {
            "location": "/install-docker-quickstart/#docker-quickstart", 
            "text": "To start developing with Nakama, you ll first need to install it on your development machine. It s straightforward and takes just a few minutes. In this guide we re going to focus on installing your Nakama development instance using Docker.   Recommended Approach  Docker is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a  binary  to ensure all system resources are available to Nakama.   There is a single, minimal Nakama image that contains the Nakama binary. The basic format is:  docker run heroiclabs/nakama  command   [ options ]   Installing Nakama using Docker is ideal for a few reasons, including:    you install to a pristine environment    you get everything you need in one go, including CockroachDB    you can take snapshots, re-install and remove Nakama without affecting your primary operating system.    It also means that the installation instructions are the same whether your development machine runs Windows, MacOS and Linux.", 
            "title": "Docker quickstart"
        }, 
        {
            "location": "/install-docker-quickstart/#what-is-docker", 
            "text": "If you re new to Docker, then here s what you need to know: Docker is an open soure containerization tool that lets you create multiple distinct Linux environments, each separate from the other.  In a Docker container you run a suite of tools to do a particular job; in this case we ll have one container running Nakama and another running CockroachDB. You can think of Docker containers as lightweight virtual machines.    Follow this  guide , if you are trying to install Docker on Mac, Linux and Windows 10 Pro edition.    Docker Toolbox  is needed, if you are installing Docker on Windows 7, 8 or 10 Home (non-Pro) editions.    Use the  Docker Store  to find the right version of Docker Community Edition for your environment.", 
            "title": "What is Docker?"
        }, 
        {
            "location": "/install-docker-quickstart/#connecting-the-nakama-client", 
            "text": "Once Nakama is running via Docker, use the following connection detail to configure your client to connect to the server:  Host :  127.0.0.1  (or  localhost )    Port  :  7350      SSL :  False     Server Key :  defaultkey        In the Unity client, you can create an  NClient  like this:  INClient   client   =   new   NClient . Builder ( defaultkey ) \n     . Host ( 127.0.0.1 ) \n     . Port ( 7350 ) \n     . SSL ( false ) \n     . Build ();", 
            "title": "Connecting the Nakama client"
        }, 
        {
            "location": "/install-docker-quickstart/#running-nakama", 
            "text": "You can run Nakama and Cockroach without using Docker-Compose. This will mean you have greater control over how they are started, and various data volumes options but in return, you'll have to configure the two containers:  # Let s pull and start CockroachDB \ndocker run --name = db cockroachdb/cockroach start --insecure # Let s pull and migrate the database \ndocker run --link = db heroiclabs/nakama migrate up --db root@db:26257 # start Nakama server \ndocker run --link = db -p  7350 :7350 heroiclabs/nakama --db root@db:26257", 
            "title": "Running Nakama"
        }, 
        {
            "location": "/install-docker-quickstart/#using-docker-compose", 
            "text": "Docker Compose simplifies running more than one Docker container in conjunction. For Nakama, we ll need two containers: one for Nakama itself and one for the database it relies on, CockroachDB.  You can choose to configure the Nakama and CockroachDB containers without Docker Compose but we do not recommend it when you re starting out.  Docker Compose uses YAML configuration files to declare which containers to use and how they should work together.   Let s start by downloading the  Nakama Docker Compose file :   wget https://raw.githubusercontent.com/heroiclabs/nakama/master/install/docker/docker-compose.yml   Windows users  If you are trying to run Nakama via Docker-Compose on Windows, you'll need to make a small change to the downloaded  docker-compose.yml  file. Follow this  instruction  to bind the correct path.   This will download  docker-compose.yml  to your current working directory.   Next, we ll ask Docker Compose to follow the instructions in the file we just downloaded:   docker-compose -f docker-compose.yml up  Docker Compose will download the latest CockroachDB and Nakama images published on Docker Hub.   You now have both CockroachDB and Nakama running on your machine, available at  127.0.0.1:26257  and  127.0.0.1:7350  respectively.", 
            "title": "Using Docker-Compose"
        }, 
        {
            "location": "/install-docker-quickstart/#docker-compose-data", 
            "text": "Docker containers are ephemeral by design: when you remove the container, you lose the data stored inside them.  For development purposes, we suggest that you bind a folder in the local machine's filesystem to the Docker file system. The easiest way to achieve this is by editing the  docker-compose.yml  file:  ...\nnakama:\n  image: heroiclabs/nakama:latest\n  entrypoint:\n    - /bin/bash\n    - -ecx\n    - /nakama/nakama migrate up --db  root@cockroachdb:26257    /nakama/nakama --db  root@cockroachdb:26257 \n  volumes:     - ./nakama/data:/nakama/data # Edit this line   expose:\n    -  7350 \n...   On Mac and Linux systems, the path highlighted above will create a folder called  nakama  in the same directory as where you are running  docker-compose  from.  On Windows, you'll need to update the path above so that Docker can bind the folder properly. A valid value can look like this:  C:/users/ username /projects/docker .    Drive Binding on Windows  Docker will complain about an unshared Drive if you the path above is not changed or is not available. The error looks like this:  ERROR: for bin_nakama_1 Cannot create container for service nakama: Drive has not been shared  Make sure to change the line highlighted above to the correct path and restart Nakama.   You can put your Lua scripts in the  data/modules  directory and restart Nakama using  docker-compose --restart .", 
            "title": "Docker-Compose Data"
        }, 
        {
            "location": "/install-docker-quickstart/#logs", 
            "text": "Logs generated within the containers are printed to the console as part of the docker-compose output, and you can access them with  docker-compose logs  from within the same the directory as the  docker-compose.yml  file.", 
            "title": "Logs"
        }, 
        {
            "location": "/install-docker-quickstart/#stopping-containers", 
            "text": "If you need to temporarily pause the Docker containers, without losing the state of those containers, you have two options:   In the terminal where docker-compose is currently running, hit CTRL-C.  Or run  docker-compose stop  in the same directory as docker-compose.yml and all containers will be shut down gracefully.   You can re-activate them by running  docker-compose up .  To stop the containers and purge all stored data, run  docker-compose down .", 
            "title": "Stopping containers"
        }, 
        {
            "location": "/install-docker-quickstart/#upgrade", 
            "text": "As new versions of Nakama, or CockroachDB, become available you might want to upgrade. Docker makes upgrading easy, as all you need to do is pull down a new version of the container image.   Schema migration  When upgrading to a new version of Nakama, the process in the  docker-compose.yml  performs a migration of your data to the new database schema.   you can pull down the most recent Nakama image and allow Docker Compose to perform the data migration.  docker-compose down  # top and remove both the Nakama and CockroachDB containers \ndocker pull heroiclabs/nakama  # download the latest Nakama image \ndocker-compose up  # start the containers (both Nakama and CockroachDB) as fresh installss   And, similarly, here s how to update the CockroachDB container:  docker pull cockroachdb/cockroach  # download the latest CockroachDB image   If you'd like to explicity run a database schema migration, issue the following command:  docker run heroiclabs/nakama migrate up", 
            "title": "Upgrade"
        }, 
        {
            "location": "/install-binary/", 
            "text": "Binary install\n\n\nTo start developing with Nakama, you\nll first need to install it on your development machine. It\ns straightforward and takes just a few minutes. In this guide we\nre going to focus on installing your Nakama development instance using the binary executable.\n\n\n\n\nRecommended Approach\n\n\nDocker\n is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a binary to ensure all system resources are available to Nakama.\n\n\n\n\nRequirement\n\n\nThere are a few things you\nll need to know or have to hand before you install Nakama:\n\n\n\n\nOperating system: Windows 10 64-bit or above, MacOS 10.9 or above, or a modern Linux.\n\n\nArchitecture: X86_64 (64bit) processor architecture\n\n\nDependent software: Nakama relies on \nCockroachDB\n.\n\n\n\n\nInstall CockroachDB\n\n\nNakama relies on CockroachDB as the main and only database. Nakama uses CockroachDB to store server configuration, user data, chat messages and more persistent data.\n\n\nYou'll first need to install CockroachDB. Follow \nthis guide\n to install CockroachDB on your machine before installing Nakama.\n\n\n\n\nCockroachDB Alternative\n\n\nNakama unofficially supports \nPostgreSQL\n for environments where CockroachDB is not available.\n\n\nFor production settings, Nakama should be used with CockroachDB as queries are optimised for the way data is stored on the disk.\n\n\n\n\nInstall Nakama on MacOS\n\n\nYou\nll need to be running MacOS 10.9 (Mavericks) to run Nakama.\n\n\nHomebrew\n\n\nHomebrew is a community-developed package manager for MacOS. If you\nve used \napt\n or \nyum\n on Linux systems then you\nll find Homebrew to be familiar.\n\n\nIf this is your first time using Homebrew, take a look at \ntheir website\n for installation instructions. Once you\nve installed Homebrew, follow the instructions below.\n\n\n# run our brew recipe to download the Nakama code and build the binary\n\nbrew install https://raw.githubusercontent.com/heroiclabs/nakama/master/install/local/nakama.rb\n\n\n\n\n\nNow you have Nakama running and you\nre ready to start developing.\n\n\nWithout Homebrew\n\n\nInstalling the binaries directly rather than via Homebrew allows you the flexibility of placing the server in your prefered workspace. However, installing through \nHomebrew\n is the simplest and easiest \n including for updates \n as everything is handled using the Homebrew workflow.\n\n\n\n\nDownload the latest \nNakama tarball for Mac OSX\n.\n\n\nThen extract the binary:\n\n\n\n\n# replace the X.X.X with the version number you have downloaded\n\ntar xfz nakama-X.X.X-darwin-amd64.tar.gz\n\n\n\n\n\n\n\nAdd the directory containing the binary to your \nPATH\n. This makes it easy to execute Nakama commands from your terminal.\n\n\n\n\ncp -i nakama /usr/local/bin\n\n\n\n\n\n\n\nMigrate the database schema and then start Nakama\n\n\n\n\n# migrate schema\n\nnakama migration up\n\n# start the server and output logs to the terminal\n\nnakama --log.stdout\n\n\n\n\n\nYou may come across a permissions error. If you\nre happy to perform the action with root permissions then prefix the command with \nsudo\n.\n\n\nInstall Nakama on Windows\n\n\nNakama is also available as a \nWindows binary\n. However, \nDocker\n is the recommended way to install CockroachDB and Nakama on Windows.\n\n\n\n\nDownload the binary\n and decompress the downloaded file.\n\n\nOpen a Powershell terminal and navigate to the folder you downloaded Nakama into.\n\n\nMigrate the database schema and then start Nakama\n\n\n\n\n# migrate schema\n\nnakama.exe migration up\n\n# start the server and output logs to the terminal\n\nnakama.exe --log.stdout\n\n\n\n\n\nInstall Nakama on Linux\n\n\nUsing \nDocker\n - This is the recommended approach. We will soon provide packages for various Linux package managers to ease the installation procedure. \nLet us know\n if you have requests for specific package managers.\n\n\nFirst you\nll need to create a suitable directory to install Nakama. To some extent its location will depend on your particular flavor of Linux and your own preferences.\n\n\n\n\n\n\nDownload the binary\n and decompress the downloaded file.\n\n\n\n\n\n\nThen extract the binary:\n\n\n\n\n\n\n# replace the X.X.X with the version number you have downloaded\n\ntar xfz nakama-X.X.X-linux-amd64.tar.gz\n\n\n\n\n\n\n\nAdd the directory containing the binary to your \nPATH\n. This makes it easy to execute Nakama commands from your terminal.\n\n\n\n\ncp -i nakama /usr/local/bin\n\n\n\n\n\n\n\nMigrate the database schema and then start Nakama\n\n\n\n\n# migrate schema\n\nnakama migration up\n\n# start the server and output logs to the terminal\n\nnakama --log.stdout\n\n\n\n\n\nYou may come across a permissions error. If you\nre happy to perform the action with root permissions then prefix the command with \nsudo\n.\n\n\nsystemd\n\n\nIf you prefer to run Nakama as a service, and you\nre running a distro that uses systemd, you can optionally use the following script.\n\n\n\n\nNote\n\n\nYou\nll need to update the paths within the systemd configuration.\n\n\n\n\n\n\nCreate the service file: \n/usr/lib/systemd/system/nakama.service\n\n\n\n\n[Unit]\n\n\nDescription\n=\nNakama server\n\n\n\n[Service]\n\n\nExecStart\n=\n/path/to/nakama --config /path/to/nakama/config.yml\n\n\nKillMode\n=\nprocess\n\n\n\n[Install]\n\n\nWantedBy\n=\nmulti-user.target\n\n\n\n\n\n\n\n\nUpdate file permission so it's readable by the \nsystemd\n daemon process\n\n\n\n\nsudo chmod \n644\n /usr/lib/systemd/system/nakama.service\n\n\n\n\n\n\n\nEnable and run the service\n\n\n\n\nsudo systemctl \nenable\n nakama\nsudo systemctl start nakama", 
            "title": "Binary install"
        }, 
        {
            "location": "/install-binary/#binary-install", 
            "text": "To start developing with Nakama, you ll first need to install it on your development machine. It s straightforward and takes just a few minutes. In this guide we re going to focus on installing your Nakama development instance using the binary executable.   Recommended Approach  Docker  is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a binary to ensure all system resources are available to Nakama.", 
            "title": "Binary install"
        }, 
        {
            "location": "/install-binary/#requirement", 
            "text": "There are a few things you ll need to know or have to hand before you install Nakama:   Operating system: Windows 10 64-bit or above, MacOS 10.9 or above, or a modern Linux.  Architecture: X86_64 (64bit) processor architecture  Dependent software: Nakama relies on  CockroachDB .", 
            "title": "Requirement"
        }, 
        {
            "location": "/install-binary/#install-cockroachdb", 
            "text": "Nakama relies on CockroachDB as the main and only database. Nakama uses CockroachDB to store server configuration, user data, chat messages and more persistent data.  You'll first need to install CockroachDB. Follow  this guide  to install CockroachDB on your machine before installing Nakama.   CockroachDB Alternative  Nakama unofficially supports  PostgreSQL  for environments where CockroachDB is not available.  For production settings, Nakama should be used with CockroachDB as queries are optimised for the way data is stored on the disk.", 
            "title": "Install CockroachDB"
        }, 
        {
            "location": "/install-binary/#install-nakama-on-macos", 
            "text": "You ll need to be running MacOS 10.9 (Mavericks) to run Nakama.", 
            "title": "Install Nakama on MacOS"
        }, 
        {
            "location": "/install-binary/#homebrew", 
            "text": "Homebrew is a community-developed package manager for MacOS. If you ve used  apt  or  yum  on Linux systems then you ll find Homebrew to be familiar.  If this is your first time using Homebrew, take a look at  their website  for installation instructions. Once you ve installed Homebrew, follow the instructions below.  # run our brew recipe to download the Nakama code and build the binary \nbrew install https://raw.githubusercontent.com/heroiclabs/nakama/master/install/local/nakama.rb  Now you have Nakama running and you re ready to start developing.", 
            "title": "Homebrew"
        }, 
        {
            "location": "/install-binary/#without-homebrew", 
            "text": "Installing the binaries directly rather than via Homebrew allows you the flexibility of placing the server in your prefered workspace. However, installing through  Homebrew  is the simplest and easiest   including for updates   as everything is handled using the Homebrew workflow.   Download the latest  Nakama tarball for Mac OSX .  Then extract the binary:   # replace the X.X.X with the version number you have downloaded \ntar xfz nakama-X.X.X-darwin-amd64.tar.gz   Add the directory containing the binary to your  PATH . This makes it easy to execute Nakama commands from your terminal.   cp -i nakama /usr/local/bin   Migrate the database schema and then start Nakama   # migrate schema \nnakama migration up # start the server and output logs to the terminal \nnakama --log.stdout  You may come across a permissions error. If you re happy to perform the action with root permissions then prefix the command with  sudo .", 
            "title": "Without Homebrew"
        }, 
        {
            "location": "/install-binary/#install-nakama-on-windows", 
            "text": "Nakama is also available as a  Windows binary . However,  Docker  is the recommended way to install CockroachDB and Nakama on Windows.   Download the binary  and decompress the downloaded file.  Open a Powershell terminal and navigate to the folder you downloaded Nakama into.  Migrate the database schema and then start Nakama   # migrate schema \nnakama.exe migration up # start the server and output logs to the terminal \nnakama.exe --log.stdout", 
            "title": "Install Nakama on Windows"
        }, 
        {
            "location": "/install-binary/#install-nakama-on-linux", 
            "text": "Using  Docker  - This is the recommended approach. We will soon provide packages for various Linux package managers to ease the installation procedure.  Let us know  if you have requests for specific package managers.  First you ll need to create a suitable directory to install Nakama. To some extent its location will depend on your particular flavor of Linux and your own preferences.    Download the binary  and decompress the downloaded file.    Then extract the binary:    # replace the X.X.X with the version number you have downloaded \ntar xfz nakama-X.X.X-linux-amd64.tar.gz   Add the directory containing the binary to your  PATH . This makes it easy to execute Nakama commands from your terminal.   cp -i nakama /usr/local/bin   Migrate the database schema and then start Nakama   # migrate schema \nnakama migration up # start the server and output logs to the terminal \nnakama --log.stdout  You may come across a permissions error. If you re happy to perform the action with root permissions then prefix the command with  sudo .", 
            "title": "Install Nakama on Linux"
        }, 
        {
            "location": "/install-binary/#systemd", 
            "text": "If you prefer to run Nakama as a service, and you re running a distro that uses systemd, you can optionally use the following script.   Note  You ll need to update the paths within the systemd configuration.    Create the service file:  /usr/lib/systemd/system/nakama.service   [Unit]  Description = Nakama server  [Service]  ExecStart = /path/to/nakama --config /path/to/nakama/config.yml  KillMode = process  [Install]  WantedBy = multi-user.target    Update file permission so it's readable by the  systemd  daemon process   sudo chmod  644  /usr/lib/systemd/system/nakama.service   Enable and run the service   sudo systemctl  enable  nakama\nsudo systemctl start nakama", 
            "title": "systemd"
        }, 
        {
            "location": "/storage-collections/", 
            "text": "Collections", 
            "title": "Collections"
        }, 
        {
            "location": "/storage-collections/#collections", 
            "text": "", 
            "title": "Collections"
        }, 
        {
            "location": "/friends/", 
            "text": "Friends\n\n\nFriends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.\n\n\n\n\nFun fact\n\n\nNakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!\n\n\n\n\nEach user builds up a list of friends by who they know already from their social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.\n\n\nAny social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.\n\n\nAdd friends\n\n\nA user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.\n\n\n\n\nHint\n\n\nA user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.\n\n\n\n\nWhen a friend request is sent or the user is added an in-app notification will be sent. See the \nin-app notification\n section for more info.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendAddMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nFriend added or request sent.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nWhen both users have added eachother as friends it's easy to initiate realtime chat in a 1-on-1 channel. See the \nrealtime chat\n section for more info.\n\n\nList friends\n\n\nYou can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.\n\n\nvar\n \nmessage\n \n=\n \nNFriendsListMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINFriend\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nf\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nf\n.\nId\n);\n \n// convert byte[].\n\n    \n// f.State is one of: Friend, Invite, Invited, Blocked.\n\n    \nDebug\n.\nLogFormat\n(\nUser {0} has state {1}.\n,\n \nid\n,\n \nf\n.\nState\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nRemove friends\n\n\nA user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.\n\n\n\n\nNote\n\n\nIf a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.\n\n\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendRemoveMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nuserId\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been removed.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBlock a friend\n\n\nYou can stop a user from using 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a \nFriend Remove\n message.\n\n\nA user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendBlockMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nid\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been blocked.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBan a user\n\n\nA user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.\n\n\nThis is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team.\n\n\nSee the \nruntime code basics\n on how to write server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n-- you can use both IDs and handles to ban.\n\n\nlocal\n \nbad_users\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n,\n \nuserhandle\n}\n\n\nlocal\n \nsuccess\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nbad_users\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nBan failed: %q\n):\nformat\n(\nerr\n))\n\n\nend", 
            "title": "Friends"
        }, 
        {
            "location": "/friends/#friends", 
            "text": "Friends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.   Fun fact  Nakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!   Each user builds up a list of friends by who they know already from their social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.  Any social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.", 
            "title": "Friends"
        }, 
        {
            "location": "/friends/#add-friends", 
            "text": "A user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.   Hint  A user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.   When a friend request is sent or the user is added an in-app notification will be sent. See the  in-app notification  section for more info.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendAddMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Friend added or request sent. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   When both users have added eachother as friends it's easy to initiate realtime chat in a 1-on-1 channel. See the  realtime chat  section for more info.", 
            "title": "Add friends"
        }, 
        {
            "location": "/friends/#list-friends", 
            "text": "You can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.  var   message   =   NFriendsListMessage . Default ();  client . Send ( message ,   ( INResultSet INFriend   list )   =   { \n   foreach   ( var   f   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( f . Id );   // convert byte[]. \n     // f.State is one of: Friend, Invite, Invited, Blocked. \n     Debug . LogFormat ( User {0} has state {1}. ,   id ,   f . State ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List friends"
        }, 
        {
            "location": "/friends/#remove-friends", 
            "text": "A user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.   Note  If a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.   byte []   userId   =   ...;   // some user ID  var   message   =   NFriendRemoveMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( userId );   // convert byte[]. \n   Debug . Log ( User {0} has been removed. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Remove friends"
        }, 
        {
            "location": "/friends/#block-a-friend", 
            "text": "You can stop a user from using 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a  Friend Remove  message.  A user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendBlockMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( id );   // convert byte[]. \n   Debug . Log ( User {0} has been blocked. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Block a friend"
        }, 
        {
            "location": "/friends/#ban-a-user", 
            "text": "A user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.  This is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team.  See the  runtime code basics  on how to write server-side code.  local   nk   =   require ( nakama )  -- you can use both IDs and handles to ban.  local   bad_users   =   { someuserid ,   anotheruserid ,   userhandle }  local   success ,   err   =   pcall ( nk . users_ban ,   bad_users )  if   ( not   success )   then \n   nk . logger_error (( Ban failed: %q ): format ( err ))  end", 
            "title": "Ban a user"
        }, 
        {
            "location": "/groups-clans/", 
            "text": "Groups and Clans\n\n\nA group brings together a bunch of users into a small community or team.\n\n\nA group is made up of an owner, admins, and members. It can be public or private which determines whether it appears in results when a user searches. Private groups are similar to how Whatsapp groups work. A user can only be added when they're invited to join by one of the group's admins.\n\n\nSearch for groups\n\n\nA user can find public groups to join by a filter on language, recently created, how many members in a group, and more. These filters make it easy to assemble new users into smaller groups for team-based play or collaboration.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNGroupsListMessage\n.\nBuilder\n()\n\n    \n.\nOrderByAsc\n(\ntrue\n)\n\n    \n.\nFilterByLang\n(\nen\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroup\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \ngroup\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nGroup: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe message response for a list of groups contains a cursor. The cursor can be used to quickly retrieve the next set of results.\n\n\n\n\nTip\n\n\nCursors are used across different server features to page through batches of results quickly and efficiently. It's used with storage, friends, chat history, etc.\n\n\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nvar\n \nmessageBuilder\n \n=\n \nnew\n \nNGroupsListMessage\n.\nBuilder\n()\n\n    \n.\nOrderByAsc\n(\ntrue\n)\n\n    \n.\nFilterByLang\n(\nen\n);\n\n    \n.\nPageLimit\n(\n100\n);\n\n\n\nclient\n.\nSend\n(\nmessageBuilder\n.\nBuild\n(),\n \n(\nINResultSet\nINGroup\n \nlist\n)\n \n=\n \n{\n\n  \n// Lets get the next page of results.\n\n  \nINCursor\n \ncursor\n \n=\n \nlist\n.\nCursor\n;\n\n  \nif\n \n(\ncursor\n \n!=\n \nnull\n \n \nlist\n.\nResults\n.\nCount\n \n \n0\n)\n \n{\n\n    \nvar\n \nmessage\n \n=\n \nmessageBuilder\n.\nCursor\n(\ncursor\n).\nBuild\n();\n\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroup\n \nnextList\n)\n \n=\n \n{\n\n      \nforeach\n \n(\nvar\n \ngroup\n \nin\n \nnextList\n.\nResults\n)\n \n{\n\n        \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n        \nDebug\n.\nLogFormat\n(\nGroup: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n      \n}\n\n    \n},\n \nerrorHandler\n);\n\n  \n}\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nJoin groups\n\n\nWhen a user has found a group to join they can request to become a member. A public group can be joined without any need for permission while a private group requires an \nadmin to accept\n the user.\n\n\nA user who's part of a group can join \ngroup chat\n and access it's \nmessage history\n.\n\n\n\n\nTip\n\n\nWhen a user joins or leaves a group event messages are added to chat history. This makes it easy for members to see what's changed in the group.\n\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupJoinMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nRequested to join group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe user will receive an \nin-app notification\n when they've been added to the group. In a private group an admin will receive a notification when a user has requested to join.\n\n\nList a user's groups\n\n\nEach user can list groups they've joined as a member or an admin. The list also contains groups which they've requested to join but not been accepted into yet.\n\n\nvar\n \nmessage\n \n=\n \nNGroupsSelfListMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroup\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \ngroup\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nGroup: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nList group members\n\n\nA user can list all members who're part of their group. These include other users who've requested to join the private group but not been accepted into yet.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupUsersListMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroupUser\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nmember\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmember\n.\nId\n);\n  \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nMember id \n{0}\n with name \n{1}\n.\n,\n \nid\n,\n \nmember\n.\nFullname\n);\n\n    \n// member.Type is one of: Admin, Member, Join.\n\n    \nUserType\n \nstatus\n \n=\n \nmember\n.\nType\n;\n\n    \nDebug\n.\nLogFormat\n(\nHas handle \n{0}\n with status \n{1}\n.\n,\n \nmember\n.\nHandle\n,\n \nstatus\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nCreate a group\n\n\nA group can be created with a name and other optional fields. These optional fields are used when a user \nsearches for groups\n. The user who creates the group becomes the owner and an admin for it.\n\n\nvar\n \nmetadata\n \n=\n \n{\nmy_custom_field\n: \nsome value\n}\n;\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNGroupCreateMessage\n.\nBuilder\n(\nSome unique group name\n)\n\n    \n.\nDescription\n(\nMy awesome group.\n)\n\n    \n.\nLang\n(\nen\n)\n\n    \n.\nPrivate\n(\ntrue\n)\n\n    \n.\nAvatarUrl\n(\nurl://somelink\n)\n\n    \n.\nMetadata\n(\nmetadata\n)\n\n    \n.\nBuild\n();\n\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINGroup\n \ngroup\n)\n \n=\n \n{\n\n  \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nNew group: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n  \nDebug\n.\nLog\n \n(\nSuccessfully created a private group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can also create a group with server-side code. This can be useful when the group must be created together with some other record or feature.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nmetadata\n \n=\n \n{\n \n-- Add whatever custom fields you want.\n\n  \nmy_custom_field\n \n=\n \nsome value\n\n\n}\n\n\nlocal\n \ngroup\n \n=\n \n{\n\n  \nName\n \n=\n \nSome unique group name\n,\n\n  \nDescription\n \n=\n \nMy awesome group.\n,\n\n  \nLang\n \n=\n \nen\n,\n\n  \nPrivate\n \n=\n \ntrue\n,\n\n  \nCreatorId\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n,\n\n  \nAvatarUrl\n \n=\n \nurl://somelink\n,\n\n  \nMetadata\n \n=\n \nmetadata\n\n\n}\n\n\nlocal\n \nnew_groups\n \n=\n \n{\n \ngroup\n \n}\n\n\n\nlocal\n \nsuccess\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\ngroups_create\n,\n \nnew_groups\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nError with groups create: %q\n):\nformat\n(\nerr\n))\n\n\nend\n\n\n\n\n\n\nUpdate a group\n\n\nWhen a group has been created it's admins can update optional fields.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNGroupUpdateMessage\n.\nBuilder\n(\ngroupId\n)\n\n    \n.\nDescription\n(\nA new group description.\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully updated group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nLeave a group\n\n\nA user can leave a group and will no longer be able to join \ngroup chat\n or read \nmessage history\n. If the user is an admin they will only be able to leave when at least one other admin exists in the group.\n\n\n\n\nNote\n\n\nAny user who leaves the group will generate an event message in group chat which other members can read.\n\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupLeaveMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nSuccessfully left the group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nGroupLastAdmin\n)\n \n{\n\n    \n// Must promote another admin before user can leave group.\n\n    \nDebug\n.\nLog\n(\nUnable to leave as last admin.\n);\n\n  \n}\n \nelse\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\nManage groups\n\n\nEach group is managed by one or more admins. These users are members with permission to make changes to optional fields, accept or reject new members, remove members or other admins, and promote other members as admins.\n\n\n\n\nWarning\n\n\nA group must have at least one admin so the last admin will have to promote another member before they can \nleave\n.\n\n\n\n\nAccept new members\n\n\nWhen a user joins a private group it will create a join request until an admin accepts or rejects the user. The admin can accept the user into the group.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupAddUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully added user to group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe user will receive an \nin-app notification\n when they've been added to the group. In a private group an admin will receive a notification about the join request.\n\n\nTo reject the user from joining the group you should \nkick them\n.\n\n\nPromote a member\n\n\nAn admin can promote another member of the group as an admin. This grants the member the same privileges to \nmanage the group\n. A group can have one or more admins.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupPromoteUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully promoted user as an admin.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nTo demote an admin as a member you can kick and re-add them.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nkickMessage\n \n=\n \nNGroupKickUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nkickMessage\n,\n \n(\nbool\n \ncompleted\n)\n \n=\n \n{\n\n  \nvar\n \naddMessage\n \n=\n \nNGroupAddUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n  \nclient\n.\nSend\n(\naddMessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n    \nDebug\n.\nLog\n(\nAdmin user demoted to member in group.\n);\n\n  \n},\n \nerrorHandler\n);\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nKick a member\n\n\nAn admin can kick a member from the group. The user is removed but can rejoin again later unless the group is private in which case an admin must accept the join request.\n\n\nIf a user is removed from a group it does not prevent them from joining other groups.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupKickUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nSuccessfully kicked user from group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\nHint\n\n\nSometimes a bad user needs to be kicked from the group and \npermanently banned\n. This will prevent the user from being able to connect to the server and interact at all.\n\n\n\n\nRemove a group\n\n\nA group can only be removed by one of the admins which will disband all members. When a group is removed it's name can be re-used to \ncreate a new group\n.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupRemoveMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nThe group has been removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});", 
            "title": "Groups and Clans"
        }, 
        {
            "location": "/groups-clans/#groups-and-clans", 
            "text": "A group brings together a bunch of users into a small community or team.  A group is made up of an owner, admins, and members. It can be public or private which determines whether it appears in results when a user searches. Private groups are similar to how Whatsapp groups work. A user can only be added when they're invited to join by one of the group's admins.", 
            "title": "Groups and Clans"
        }, 
        {
            "location": "/groups-clans/#search-for-groups", 
            "text": "A user can find public groups to join by a filter on language, recently created, how many members in a group, and more. These filters make it easy to assemble new users into smaller groups for team-based play or collaboration.  var   message   =   new   NGroupsListMessage . Builder () \n     . OrderByAsc ( true ) \n     . FilterByLang ( en ) \n     . Build ();  client . Send ( message ,   ( INResultSet INGroup   list )   =   { \n   foreach   ( var   group   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n     Debug . LogFormat ( Group: name  {0}  id  {1} . ,   group . Name ,   id ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The message response for a list of groups contains a cursor. The cursor can be used to quickly retrieve the next set of results.   Tip  Cursors are used across different server features to page through batches of results quickly and efficiently. It's used with storage, friends, chat history, etc.   var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  var   messageBuilder   =   new   NGroupsListMessage . Builder () \n     . OrderByAsc ( true ) \n     . FilterByLang ( en ); \n     . PageLimit ( 100 );  client . Send ( messageBuilder . Build (),   ( INResultSet INGroup   list )   =   { \n   // Lets get the next page of results. \n   INCursor   cursor   =   list . Cursor ; \n   if   ( cursor   !=   null     list . Results . Count     0 )   { \n     var   message   =   messageBuilder . Cursor ( cursor ). Build (); \n\n     client . Send ( message ,   ( INResultSet INGroup   nextList )   =   { \n       foreach   ( var   group   in   nextList . Results )   { \n         var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n         Debug . LogFormat ( Group: name  {0}  id  {1} . ,   group . Name ,   id ); \n       } \n     },   errorHandler ); \n   }  },   errorHandler );", 
            "title": "Search for groups"
        }, 
        {
            "location": "/groups-clans/#join-groups", 
            "text": "When a user has found a group to join they can request to become a member. A public group can be joined without any need for permission while a private group requires an  admin to accept  the user.  A user who's part of a group can join  group chat  and access it's  message history .   Tip  When a user joins or leaves a group event messages are added to chat history. This makes it easy for members to see what's changed in the group.   byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupJoinMessage . Default ( groupId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Requested to join group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The user will receive an  in-app notification  when they've been added to the group. In a private group an admin will receive a notification when a user has requested to join.", 
            "title": "Join groups"
        }, 
        {
            "location": "/groups-clans/#list-a-users-groups", 
            "text": "Each user can list groups they've joined as a member or an admin. The list also contains groups which they've requested to join but not been accepted into yet.  var   message   =   NGroupsSelfListMessage . Default ();  client . Send ( message ,   ( INResultSet INGroup   list )   =   { \n   foreach   ( var   group   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n     Debug . LogFormat ( Group: name  {0}  id  {1} . ,   group . Name ,   id ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List a user's groups"
        }, 
        {
            "location": "/groups-clans/#list-group-members", 
            "text": "A user can list all members who're part of their group. These include other users who've requested to join the private group but not been accepted into yet.  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupUsersListMessage . Default ( groupId );  client . Send ( message ,   ( INResultSet INGroupUser   list )   =   { \n   foreach   ( var   member   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( member . Id );    // convert byte[]. \n     Debug . LogFormat ( Member id  {0}  with name  {1} . ,   id ,   member . Fullname ); \n     // member.Type is one of: Admin, Member, Join. \n     UserType   status   =   member . Type ; \n     Debug . LogFormat ( Has handle  {0}  with status  {1} . ,   member . Handle ,   status ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List group members"
        }, 
        {
            "location": "/groups-clans/#create-a-group", 
            "text": "A group can be created with a name and other optional fields. These optional fields are used when a user  searches for groups . The user who creates the group becomes the owner and an admin for it.  var   metadata   =   { my_custom_field :  some value } ;  var   message   =   new   NGroupCreateMessage . Builder ( Some unique group name ) \n     . Description ( My awesome group. ) \n     . Lang ( en ) \n     . Private ( true ) \n     . AvatarUrl ( url://somelink ) \n     . Metadata ( metadata ) \n     . Build ();  client . Send ( message ,   ( INGroup   group )   =   { \n   var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n   Debug . LogFormat ( New group: name  {0}  id  {1} . ,   group . Name ,   id ); \n   Debug . Log   ( Successfully created a private group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can also create a group with server-side code. This can be useful when the group must be created together with some other record or feature.  local   nk   =   require ( nakama )  local   metadata   =   {   -- Add whatever custom fields you want. \n   my_custom_field   =   some value  }  local   group   =   { \n   Name   =   Some unique group name , \n   Description   =   My awesome group. , \n   Lang   =   en , \n   Private   =   true , \n   CreatorId   =   4c2ae592-b2a7-445e-98ec-697694478b1c , \n   AvatarUrl   =   url://somelink , \n   Metadata   =   metadata  }  local   new_groups   =   {   group   }  local   success ,   err   =   pcall ( nk . groups_create ,   new_groups )  if   ( not   success )   then \n   nk . logger_error (( Error with groups create: %q ): format ( err ))  end", 
            "title": "Create a group"
        }, 
        {
            "location": "/groups-clans/#update-a-group", 
            "text": "When a group has been created it's admins can update optional fields.  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   new   NGroupUpdateMessage . Builder ( groupId ) \n     . Description ( A new group description. ) \n     . Build ();  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully updated group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Update a group"
        }, 
        {
            "location": "/groups-clans/#leave-a-group", 
            "text": "A user can leave a group and will no longer be able to join  group chat  or read  message history . If the user is an admin they will only be able to leave when at least one other admin exists in the group.   Note  Any user who leaves the group will generate an event message in group chat which other members can read.   byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupLeaveMessage . Default ( groupId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log   ( Successfully left the group. );  },   ( INError   err )   =   { \n   if   ( err . Code   ==   ErrorCode . GroupLastAdmin )   { \n     // Must promote another admin before user can leave group. \n     Debug . Log ( Unable to leave as last admin. ); \n   }   else   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   }  });", 
            "title": "Leave a group"
        }, 
        {
            "location": "/groups-clans/#manage-groups", 
            "text": "Each group is managed by one or more admins. These users are members with permission to make changes to optional fields, accept or reject new members, remove members or other admins, and promote other members as admins.   Warning  A group must have at least one admin so the last admin will have to promote another member before they can  leave .", 
            "title": "Manage groups"
        }, 
        {
            "location": "/groups-clans/#accept-new-members", 
            "text": "When a user joins a private group it will create a join request until an admin accepts or rejects the user. The admin can accept the user into the group.  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   message   =   NGroupAddUserMessage . Default ( groupId ,   userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully added user to group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The user will receive an  in-app notification  when they've been added to the group. In a private group an admin will receive a notification about the join request.  To reject the user from joining the group you should  kick them .", 
            "title": "Accept new members"
        }, 
        {
            "location": "/groups-clans/#promote-a-member", 
            "text": "An admin can promote another member of the group as an admin. This grants the member the same privileges to  manage the group . A group can have one or more admins.  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   message   =   NGroupPromoteUserMessage . Default ( groupId ,   userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully promoted user as an admin. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   To demote an admin as a member you can kick and re-add them.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   kickMessage   =   NGroupKickUserMessage . Default ( groupId ,   userId );  client . Send ( kickMessage ,   ( bool   completed )   =   { \n   var   addMessage   =   NGroupAddUserMessage . Default ( groupId ,   userId ); \n   client . Send ( addMessage ,   ( bool   done )   =   { \n     Debug . Log ( Admin user demoted to member in group. ); \n   },   errorHandler );  },   errorHandler );", 
            "title": "Promote a member"
        }, 
        {
            "location": "/groups-clans/#kick-a-member", 
            "text": "An admin can kick a member from the group. The user is removed but can rejoin again later unless the group is private in which case an admin must accept the join request.  If a user is removed from a group it does not prevent them from joining other groups.  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   message   =   NGroupKickUserMessage . Default ( groupId ,   userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log   ( Successfully kicked user from group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });    Hint  Sometimes a bad user needs to be kicked from the group and  permanently banned . This will prevent the user from being able to connect to the server and interact at all.", 
            "title": "Kick a member"
        }, 
        {
            "location": "/groups-clans/#remove-a-group", 
            "text": "A group can only be removed by one of the admins which will disband all members. When a group is removed it's name can be re-used to  create a new group .  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupRemoveMessage . Default ( groupId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( The group has been removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Remove a group"
        }, 
        {
            "location": "/in-app-notifications/", 
            "text": "In-app Notifications\n\n\nIn-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.\n\n\nA notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.\n\n\nThese notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.\n\n\nSend notifications\n\n\nYou can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.\n\n\n\n\nNote\n\n\nThe code you choose for your notifications must start at \"101\" and upwards. See \nbelow\n for reserved message codes.\n\n\n\n\nA notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.\n\n\nNotifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_ids\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n}\n\n\nlocal\n \nsender_id\n \n=\n \nnil\n   \n-- \nnil\n for server sent.\n\n\nlocal\n \ncontent\n \n=\n \n{\n\n  \nitem_id\n \n=\n \n192308394345345\n,\n\n  \nitem_icon\n \n=\n \nstorm_bringer_sword.png\n\n\n}\n\n\n\nlocal\n \nnotifications\n \n=\n \n{}\n\n\nfor\n \n_\n,\n \nuser_id\n \nin\n \nipairs\n(\nuser_ids\n)\n\n\ndo\n\n  \nlocal\n \nnotification\n \n=\n \n{\n\n    \nUserId\n \n=\n \nuser_id\n,\n\n    \nSenderId\n \n=\n \nsender_id\n,\n\n    \nSubject\n \n=\n \nYou earned a secret item!\n,\n\n    \nContent\n \n=\n \ncontent\n,\n\n    \nCode\n \n=\n \n101\n,\n\n    \nExpiresAt\n \n=\n \n1000\n \n*\n \n60\n \n*\n \n60\n \n*\n \n24\n \n*\n \n7\n,\n  \n-- expires in 7 days.\n\n    \nPersistent\n \n=\n \ntrue\n\n  \n}\n\n  \ntable.insert\n(\nnotifications\n,\n \nnotification\n)\n\n\nend\n\n\n\nnk\n.\nnotification_send_id\n(\nnotifications\n)\n\n\n\n\n\n\nReceive notifications\n\n\nAn event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.\n\n\nclient\n.\nOnNotification\n \n+=\n \n(\nobject\n \nsender\n,\n \nNNotificationEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINNotification\n \nn\n \n=\n \nargs\n.\nNotification\n;\n\n  \nDebug\n.\nLogFormat\n(\nReceived code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nn\n.\nContent\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nReceived id \n{0}\n and content \n{1}\n.\n,\n \nn\n.\nId\n,\n \ncontent\n);\n\n\n};\n\n\n\n\n\n\nList notifications\n\n\nYou can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nn\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nNotice code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.\n\n\n\n\nHint\n\n\nYou usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.\n\n\n\n\nIList\nINNotification\n \nallNotifications\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\n\nAction\n \naccumulateNotifications\n \n=\n \ndelegate\n(\nINCursor\n \nresumeCursor\n)\n \n{\n\n  \nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n      \n.\nCursor\n(\nresumeCursor\n)\n\n      \n.\nBuild\n();\n\n  \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n    \nif\n \n(\nlist\n.\nResults\n.\nLength\n \n \n1\n)\n \n{\n\n      \nreturn\n;\n\n    \n}\n \nelse\n \n{\n\n      \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n      \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n \n// recursive async call.\n\n    \n}\n\n  \n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n});\n\n\n};\n\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n  \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nIt can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.\n\n\nThe resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.\n\n\nINCursor\n \nresumeCursor\n \n=\n \n...;\n \n// stored from last list retrieval.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n    \n.\nCursor\n(\nresumeCursor\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \n// use notification list.\n\n  \nresumeCursor\n \n=\n \nlist\n.\nCursor\n;\n \n// cache resume cursor.\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nDelete notifications\n\n\nYou can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.\n\n\nIList\nINNotification\n \nlist\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\nlist\n.\nAdd\n(...);\n \n// Add notification from your internal list\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsRemoveMessage\n.\nDefault\n(\nlist\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nNotifications were removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nNotification codes\n\n\nThe server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.\n\n\n\n\n\n\n\n\nCode\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n001\n\n\nUser X wants to chat.\n\n\n\n\n\n\n002\n\n\nUser X wants to add you as a friend.\n\n\n\n\n\n\n003\n\n\nUser X accepted your friend invite.\n\n\n\n\n\n\n004\n\n\nYou've been accepted to X group.\n\n\n\n\n\n\n005\n\n\nUser X wants to join your group.\n\n\n\n\n\n\n006\n\n\nYour friend X has just joined the game.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/in-app-notifications/#in-app-notifications", 
            "text": "In-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.  A notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.  These notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/in-app-notifications/#send-notifications", 
            "text": "You can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.   Note  The code you choose for your notifications must start at \"101\" and upwards. See  below  for reserved message codes.   A notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.  Notifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.  local   nk   =   require ( nakama )  local   user_ids   =   { someuserid ,   anotheruserid }  local   sender_id   =   nil     --  nil  for server sent.  local   content   =   { \n   item_id   =   192308394345345 , \n   item_icon   =   storm_bringer_sword.png  }  local   notifications   =   {}  for   _ ,   user_id   in   ipairs ( user_ids )  do \n   local   notification   =   { \n     UserId   =   user_id , \n     SenderId   =   sender_id , \n     Subject   =   You earned a secret item! , \n     Content   =   content , \n     Code   =   101 , \n     ExpiresAt   =   1000   *   60   *   60   *   24   *   7 ,    -- expires in 7 days. \n     Persistent   =   true \n   } \n   table.insert ( notifications ,   notification )  end  nk . notification_send_id ( notifications )", 
            "title": "Send notifications"
        }, 
        {
            "location": "/in-app-notifications/#receive-notifications", 
            "text": "An event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.  client . OnNotification   +=   ( object   sender ,   NNotificationEventArgs   args )   =   { \n   INNotification   n   =   args . Notification ; \n   Debug . LogFormat ( Received code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   var   content   =   Encoding . UTF8 . GetString ( n . Content );   // convert byte[]. \n   Debug . LogFormat ( Received id  {0}  and content  {1} . ,   n . Id ,   content );  };", 
            "title": "Receive notifications"
        }, 
        {
            "location": "/in-app-notifications/#list-notifications", 
            "text": "You can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   foreach   ( var   n   in   list . Results )   { \n     Debug . LogFormat ( Notice code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.   Hint  You usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.   IList INNotification   allNotifications   =   new   List INNotification ();  Action   accumulateNotifications   =   delegate ( INCursor   resumeCursor )   { \n   var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n       . Cursor ( resumeCursor ) \n       . Build (); \n   client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n     if   ( list . Results . Length     1 )   { \n       return ; \n     }   else   { \n       allNotifications . AddRange ( list . Results ); \n       accumulateNotifications ( list . Cursor );   // recursive async call. \n     } \n   },   ( INError   err )   =   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   });  };  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   allNotifications . AddRange ( list . Results ); \n   accumulateNotifications ( list . Cursor );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   It can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.  The resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.  INCursor   resumeCursor   =   ...;   // stored from last list retrieval.  var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n     . Cursor ( resumeCursor ) \n     . Build ();  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   // use notification list. \n   resumeCursor   =   list . Cursor ;   // cache resume cursor.  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List notifications"
        }, 
        {
            "location": "/in-app-notifications/#delete-notifications", 
            "text": "You can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.  IList INNotification   list   =   new   List INNotification ();  list . Add (...);   // Add notification from your internal list  var   message   =   NNotificationsRemoveMessage . Default ( list );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Notifications were removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Delete notifications"
        }, 
        {
            "location": "/in-app-notifications/#notification-codes", 
            "text": "The server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.     Code  Purpose      001  User X wants to chat.    002  User X wants to add you as a friend.    003  User X accepted your friend invite.    004  You've been accepted to X group.    005  User X wants to join your group.    006  Your friend X has just joined the game.", 
            "title": "Notification codes"
        }, 
        {
            "location": "/realtime-chat/", 
            "text": "Realtime Chat\n\n\nRealtime chat makes it easy to power a live community.\n\n\nUsers can chat with each other 1-on-1, as part of a group, and in chat rooms. Messages can contain images, links, and other content. These messages are delivered immediately to clients if the recipients are online and stored in message history so offline users can catch up when they connect.\n\n\nEvery message which flows through the realtime chat engine belongs to a topic which is used internally to identify which users should receive the messages. Users explicitly join and leave topics when they connect. This makes it easy to selectively listen for messages which they care about or decide to \"mute\" certain topics when they're busy. Users can also join multiple topics at once to chat simultaneously in multiple groups or chat rooms.\n\n\nThere are 3 types of topic:\n\n\n\n\n\n\nA chat room is great for public chat. Any user can join and participate without need for permission. These rooms can scale to millions of users all in simultaneous communication. This is perfect for live participation apps or games with live events or tournaments.\n\n\n\n\n\n\nA group chat is private to only users part of a \ngroup\n. Each user must be a member of the group and no other users can participate. You can use group chat with team-based gameplay or collaboration.\n\n\n\n\n\n\nDirect chat is private between two users. Each user will receive a \nnotification\n when they've been invited to chat. Both users must join for messages to be exchanged which prevents spam from bad users.\n\n\n\n\n\n\nReceive messages\n\n\nA user joins a chat topic to start receiving messages in realtime. Each new message is received by an event handler and can be added to your UI. Messages are delivered in the order they are handled by the server.\n\n\nclient\n.\nOnTopicMessage\n \n+=\n \n(\nobject\n \nsource\n,\n \nNTopicMessageEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINTopicMessage\n \nmessage\n \n=\n \nargs\n.\nTopicMessage\n;\n\n  \n// TopicType will be one of DirectMessage, Room, or Group.\n\n  \nDebug\n.\nLogFormat\n(\nReceived a \n{0}\n message.\n,\n \nmessage\n.\nTopic\n.\nTopicType\n);\n\n  \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmessage\n.\nTopic\n.\nId\n);\n     \n// convert byte[].\n\n  \nvar\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmessage\n.\nTopic\n.\nData\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nMessage has id \n{0}\n and content \n{1}\n.\n,\n \nid\n,\n \ndata\n);\n\n\n};\n\n\n\n\n\n\nIn group chat a user will receive other messages from the server. These messages contain events on users who join or leave the group, when someone is promoted as an admin, etc. You may want users to see these messages in the chat stream or ignore them in the UI.\n\n\nYou can identify event messages from chat messages by the message \"Type\".\n\n\nTopicMessageType\n \nmessageType\n \n=\n \nmessage\n.\nType\n;\n \n// enum\n\n\nif\n \n(\nmessageType\n \n!=\n \nTopicMessageType\n.\nChat\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nReceived message with event type \n{0}\n.\n,\n \nmessageType\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nPurpose\n\n\nSource\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\nchat message\n\n\nuser\n\n\nAll messages sent by users.\n\n\n\n\n\n\n1\n\n\njoined group\n\n\nserver\n\n\nAn event message for when a user joined the group.\n\n\n\n\n\n\n2\n\n\nadded to group\n\n\nserver\n\n\nAn event message for when a user was added to the group.\n\n\n\n\n\n\n3\n\n\nleft group\n\n\nserver\n\n\nAn event message for when a user left a group.\n\n\n\n\n\n\n4\n\n\nkicked from group\n\n\nserver\n\n\nAn event message for when an admin kicked a user from the group.\n\n\n\n\n\n\n5\n\n\npromoted in group\n\n\nserver\n\n\nAn event message for when a user is promoted as a group admin.\n\n\n\n\n\n\n\n\nJoin chat\n\n\nTo send messages to other users a user must join the chat topic they want to communicate on. This will also enable messages to be \nreceived in realtime\n.\n\n\n\n\nTip\n\n\nEach user can join many rooms, groups, and direct chat with their session. The same user can also be connected to the same chats from other devices because each device is identified as a separate session.\n\n\n\n\nrooms\n\n\nA room is created dynamically for users to chat. A room has a name and will be setup on the server when any user joins. The list of room names available to join can be stored within client code or via remote configuration with a \nstorage record\n.\n\n\nINTopicId\n \nroomId\n \n=\n \nnull\n;\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \nroomId\n \n=\n \ntopic\n.\nTopic\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined the room.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe \nroomId\n variable contains an ID used to \nsend messages\n.\n\n\ngroups\n\n\nA group chat can only be joined by a user who is a member of the \ngroup\n. Messages are pushed in realtime to group members and they can read \nhistoric messages\n.\n\n\n\n\nNote\n\n\nIf a user is kicked or leaves a group they can no longer receive messages or read history.\n\n\n\n\nA group ID is needed when a user joins group chat and can be \nlisted by the user\n.\n\n\nINTopicId\n \ngroupTopicId\n \n=\n \nnull\n;\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicGroup\n(\ngroupId\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \ngroupTopicId\n \n=\n \ntopic\n.\nTopic\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined the group chat.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe \ngroupTopicId\n variable contains an ID used to \nsend messages\n.\n\n\ndirect\n\n\nA user can direct message another user by ID. Each user will not receive messages in realtime until both users have joined the chat. This is important because it prevents spam messages from bad users.\n\n\n\n\nTip\n\n\nFriends, groups, leaderboards, matchmaker, room chat, and searches in storage are all ways to find users for chat.\n\n\n\n\nA user will receive an \nin-app notification\n when a request to chat has been received.\n\n\nINTopicId\n \ndirectTopicId\n \n=\n \nnull\n;\n\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n \n// an INUser ID.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicDirectMessage\n(\nuserId\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \ndirectTopicId\n \n=\n \ntopic\n.\nTopic\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined the direct chat.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe \ndirectTopicId\n variable contains an ID used to \nsend messages\n.\n\n\n\n\nNote\n\n\nA user can \nblock other users\n to stop unwanted direct messages.\n\n\n\n\nList online users\n\n\nEach user who joins a chat becomes a \"presence\" in the chat topic. These presences keep information about which users are connected.\n\n\nA presence is made up of a unique session combined with a user ID. This makes it easy to distinguish between the same user connected from multiple devices in the chat topic.\n\n\nThe user who \njoins a chat topic\n receives an initial presence list of all other connected users in the chat topic. An event handler can be used to receive \"presence\" changes from the server about users who joined and left. This makes it easy to maintain a list of online users and update it when changes occur.\n\n\n\n\nSummary\n\n\nA list of all online users is received when a user joins a chat topic you can combine it with an event handler which notifies when users join or leave. Together it becomes easy to maintain a list of online users.\n\n\n\n\nIList\nINUserPresence\n \nonlineUsers\n \n=\n \nnew\n \nList\nINUserPresence\n();\n\n\n\nclient\n.\nOnTopicPresence\n \n+=\n \n(\nobject\n \nsource\n,\n \nNTopicPresenceEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINTopicPresence\n \npresenceUpdate\n \n=\n \nargs\n.\nTopicPresence\n;\n\n  \n// Remove all users who left.\n\n  \nforeach\n \n(\nvar\n \nuser\n \nin\n \npresenceUpdate\n.\nLeave\n)\n \n{\n\n    \nonlineUsers\n.\nRemove\n(\nuser\n);\n\n  \n}\n\n  \n// Add all users who joined.\n\n  \nonlineUsers\n.\nAddRange\n(\npresenceUpdate\n.\nJoin\n);\n\n\n};\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \n// Setup initial online user list.\n\n  \nonlineUsers\n.\nAddRange\n(\ntopic\n.\nPresences\n);\n\n  \n// Remove your own user from list.\n\n  \nonlineUsers\n.\nRemove\n(\ntopic\n.\nSelf\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\nTip\n\n\nThe server is optimized to only push presence updates when other users join or leave the chat.\n\n\n\n\nSend messages\n\n\nWhen a user has \njoined a chat topic\n it's ID can be used to send messages with JSON encoded strings.\n\n\nEvery message sent returns an acknowledgement when it's received by the server. The acknowledgement returned contains a message ID, timestamp, and details back about the user who sent it.\n\n\nINTopicId\n \nchatTopicId\n \n=\n \ntopic\n.\nTopic\n;\n \n// A chat topic ID.\n\n\n\nvar\n \njson\n \n=\n \n{\nsome\n:\ndata\n}\n;\n\n\nbyte\n[]\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njson\n);\n\n\nvar\n \nmessage\n \n=\n \nNTopicMessageSendMessage\n.\nDefault\n(\nchatTopicId\n,\n \ndata\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopicMessageAck\n \nack\n)\n \n=\n \n{\n\n  \nvar\n \nmessageId\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nack\n.\nMessageId\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nNew message sent has id \n{0}\n.\n,\n \nmessageId\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nLeave chat\n\n\nA user can leave a chat topic to no longer be sent messages in realtime. This can be useful to \"mute\" a chat while in some other part of the UI.\n\n\nINTopicId\n \nchatTopicId\n \n=\n \ntopic\n.\nTopic\n;\n \n// A chat topic ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNTopicLeaveMessage\n.\nDefault\n(\nchatTopicId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully left chat.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nMessage history\n\n\nEvery chat conversation stores a history of messages. The history also contains \nevent messages\n sent by the server with group chat. Each user can retrieve old messages for chat when they next connect online.\n\n\nMessages can be listed in order of most recent to oldest and also in reverse (oldest to newest). Messages are returned in batches of up to 100 each with a cursor for when there are more messages.\n\n\n\n\nTip\n\n\nA user does not have to join a chat topic to see chat history. This is useful to \"peek\" at old messages without the user appearing online in the chat.\n\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\n// Fetch 10 messages on the chat room with oldest first.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicMessagesListMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nForward\n(\nfalse\n)\n\n    \n.\nLimit\n(\n10\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINTopicMessage\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nmsg\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nId\n);\n     \n// convert byte[].\n\n    \nvar\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nData\n);\n \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nMessage has id \n{0}\n and content \n{1}\n.\n,\n \nid\n,\n \ndata\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA cursor can be used to page after a batch of messages for the next set of results.\n\n\nWe recommend you only list the most recent 100 messages in your UI. A good user experience could be to fetch the next 100 older messages when the user scrolls to the bottom of your UI panel.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\nvar\n \nmessageBuilder\n \n=\n \nnew\n \nNTopicMessagesListMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nLimit\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessageBuilder\n.\nBuild\n(),\n \n(\nINResultSet\nINTopicMessage\n \nlist\n)\n \n=\n \n{\n\n  \n// Lets get the next page of results.\n\n  \nINCursor\n \ncursor\n \n=\n \nlist\n.\nCursor\n;\n\n  \nif\n \n(\ncursor\n \n!=\n \nnull\n \n \nlist\n.\nResults\n.\nCount\n \n \n0\n)\n \n{\n\n    \nvar\n \nmessage\n \n=\n \nmessageBuilder\n.\nCursor\n(\ncursor\n).\nBuild\n();\n\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINTopicMessage\n \nnextList\n)\n \n=\n \n{\n\n      \nforeach\n \n(\nvar\n \nmsg\n \nin\n \nnextList\n.\nResults\n)\n \n{\n\n        \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nId\n);\n     \n// convert byte[].\n\n        \nvar\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nData\n);\n \n// convert byte[].\n\n        \nDebug\n.\nLogFormat\n(\nMessage has id \n{0}\n and content \n{1}\n.\n,\n \nid\n,\n \ndata\n);\n\n      \n}\n\n    \n},\n \nerrorHandler\n);\n\n  \n}\n\n\n},\n \nerrorHandler\n);", 
            "title": "Realtime Chat"
        }, 
        {
            "location": "/realtime-chat/#realtime-chat", 
            "text": "Realtime chat makes it easy to power a live community.  Users can chat with each other 1-on-1, as part of a group, and in chat rooms. Messages can contain images, links, and other content. These messages are delivered immediately to clients if the recipients are online and stored in message history so offline users can catch up when they connect.  Every message which flows through the realtime chat engine belongs to a topic which is used internally to identify which users should receive the messages. Users explicitly join and leave topics when they connect. This makes it easy to selectively listen for messages which they care about or decide to \"mute\" certain topics when they're busy. Users can also join multiple topics at once to chat simultaneously in multiple groups or chat rooms.  There are 3 types of topic:    A chat room is great for public chat. Any user can join and participate without need for permission. These rooms can scale to millions of users all in simultaneous communication. This is perfect for live participation apps or games with live events or tournaments.    A group chat is private to only users part of a  group . Each user must be a member of the group and no other users can participate. You can use group chat with team-based gameplay or collaboration.    Direct chat is private between two users. Each user will receive a  notification  when they've been invited to chat. Both users must join for messages to be exchanged which prevents spam from bad users.", 
            "title": "Realtime Chat"
        }, 
        {
            "location": "/realtime-chat/#receive-messages", 
            "text": "A user joins a chat topic to start receiving messages in realtime. Each new message is received by an event handler and can be added to your UI. Messages are delivered in the order they are handled by the server.  client . OnTopicMessage   +=   ( object   source ,   NTopicMessageEventArgs   args )   =   { \n   INTopicMessage   message   =   args . TopicMessage ; \n   // TopicType will be one of DirectMessage, Room, or Group. \n   Debug . LogFormat ( Received a  {0}  message. ,   message . Topic . TopicType ); \n   var   id   =   Encoding . UTF8 . GetString ( message . Topic . Id );       // convert byte[]. \n   var   data   =   Encoding . UTF8 . GetString ( message . Topic . Data );   // convert byte[]. \n   Debug . LogFormat ( Message has id  {0}  and content  {1} . ,   id ,   data );  };   In group chat a user will receive other messages from the server. These messages contain events on users who join or leave the group, when someone is promoted as an admin, etc. You may want users to see these messages in the chat stream or ignore them in the UI.  You can identify event messages from chat messages by the message \"Type\".  TopicMessageType   messageType   =   message . Type ;   // enum  if   ( messageType   !=   TopicMessageType . Chat )   { \n   Debug . LogFormat ( Received message with event type  {0} . ,   messageType );  }      Type  Purpose  Source  Description      0  chat message  user  All messages sent by users.    1  joined group  server  An event message for when a user joined the group.    2  added to group  server  An event message for when a user was added to the group.    3  left group  server  An event message for when a user left a group.    4  kicked from group  server  An event message for when an admin kicked a user from the group.    5  promoted in group  server  An event message for when a user is promoted as a group admin.", 
            "title": "Receive messages"
        }, 
        {
            "location": "/realtime-chat/#join-chat", 
            "text": "To send messages to other users a user must join the chat topic they want to communicate on. This will also enable messages to be  received in realtime .   Tip  Each user can join many rooms, groups, and direct chat with their session. The same user can also be connected to the same chats from other devices because each device is identified as a separate session.", 
            "title": "Join chat"
        }, 
        {
            "location": "/realtime-chat/#rooms", 
            "text": "A room is created dynamically for users to chat. A room has a name and will be setup on the server when any user joins. The list of room names available to join can be stored within client code or via remote configuration with a  storage record .  INTopicId   roomId   =   null ;  byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   roomId   =   topic . Topic ; \n   Debug . Log ( Successfully joined the room. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The  roomId  variable contains an ID used to  send messages .", 
            "title": "rooms"
        }, 
        {
            "location": "/realtime-chat/#groups", 
            "text": "A group chat can only be joined by a user who is a member of the  group . Messages are pushed in realtime to group members and they can read  historic messages .   Note  If a user is kicked or leaves a group they can no longer receive messages or read history.   A group ID is needed when a user joins group chat and can be  listed by the user .  INTopicId   groupTopicId   =   null ;  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicGroup ( groupId ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   groupTopicId   =   topic . Topic ; \n   Debug . Log ( Successfully joined the group chat. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The  groupTopicId  variable contains an ID used to  send messages .", 
            "title": "groups"
        }, 
        {
            "location": "/realtime-chat/#direct", 
            "text": "A user can direct message another user by ID. Each user will not receive messages in realtime until both users have joined the chat. This is important because it prevents spam messages from bad users.   Tip  Friends, groups, leaderboards, matchmaker, room chat, and searches in storage are all ways to find users for chat.   A user will receive an  in-app notification  when a request to chat has been received.  INTopicId   directTopicId   =   null ;  byte []   userId   =   user . Id ;   // an INUser ID.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicDirectMessage ( userId ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   directTopicId   =   topic . Topic ; \n   Debug . Log ( Successfully joined the direct chat. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The  directTopicId  variable contains an ID used to  send messages .   Note  A user can  block other users  to stop unwanted direct messages.", 
            "title": "direct"
        }, 
        {
            "location": "/realtime-chat/#list-online-users", 
            "text": "Each user who joins a chat becomes a \"presence\" in the chat topic. These presences keep information about which users are connected.  A presence is made up of a unique session combined with a user ID. This makes it easy to distinguish between the same user connected from multiple devices in the chat topic.  The user who  joins a chat topic  receives an initial presence list of all other connected users in the chat topic. An event handler can be used to receive \"presence\" changes from the server about users who joined and left. This makes it easy to maintain a list of online users and update it when changes occur.   Summary  A list of all online users is received when a user joins a chat topic you can combine it with an event handler which notifies when users join or leave. Together it becomes easy to maintain a list of online users.   IList INUserPresence   onlineUsers   =   new   List INUserPresence ();  client . OnTopicPresence   +=   ( object   source ,   NTopicPresenceEventArgs   args )   =   { \n   INTopicPresence   presenceUpdate   =   args . TopicPresence ; \n   // Remove all users who left. \n   foreach   ( var   user   in   presenceUpdate . Leave )   { \n     onlineUsers . Remove ( user ); \n   } \n   // Add all users who joined. \n   onlineUsers . AddRange ( presenceUpdate . Join );  };  byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   // Setup initial online user list. \n   onlineUsers . AddRange ( topic . Presences ); \n   // Remove your own user from list. \n   onlineUsers . Remove ( topic . Self );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });    Tip  The server is optimized to only push presence updates when other users join or leave the chat.", 
            "title": "List online users"
        }, 
        {
            "location": "/realtime-chat/#send-messages", 
            "text": "When a user has  joined a chat topic  it's ID can be used to send messages with JSON encoded strings.  Every message sent returns an acknowledgement when it's received by the server. The acknowledgement returned contains a message ID, timestamp, and details back about the user who sent it.  INTopicId   chatTopicId   =   topic . Topic ;   // A chat topic ID.  var   json   =   { some : data } ;  byte []   data   =   Encoding . UTF8 . GetBytes ( json );  var   message   =   NTopicMessageSendMessage . Default ( chatTopicId ,   data );  client . Send ( message ,   ( INTopicMessageAck   ack )   =   { \n   var   messageId   =   Encoding . UTF8 . GetString ( ack . MessageId );   // convert byte[]. \n   Debug . LogFormat ( New message sent has id  {0} . ,   messageId );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Send messages"
        }, 
        {
            "location": "/realtime-chat/#leave-chat", 
            "text": "A user can leave a chat topic to no longer be sent messages in realtime. This can be useful to \"mute\" a chat while in some other part of the UI.  INTopicId   chatTopicId   =   topic . Topic ;   // A chat topic ID.  var   message   =   NTopicLeaveMessage . Default ( chatTopicId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully left chat. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Leave chat"
        }, 
        {
            "location": "/realtime-chat/#message-history", 
            "text": "Every chat conversation stores a history of messages. The history also contains  event messages  sent by the server with group chat. Each user can retrieve old messages for chat when they next connect online.  Messages can be listed in order of most recent to oldest and also in reverse (oldest to newest). Messages are returned in batches of up to 100 each with a cursor for when there are more messages.   Tip  A user does not have to join a chat topic to see chat history. This is useful to \"peek\" at old messages without the user appearing online in the chat.   byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  // Fetch 10 messages on the chat room with oldest first.  var   message   =   new   NTopicMessagesListMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Forward ( false ) \n     . Limit ( 10 ) \n     . Build ();  client . Send ( message ,   ( INResultSet INTopicMessage   list )   =   { \n   foreach   ( var   msg   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( msg . Topic . Id );       // convert byte[]. \n     var   data   =   Encoding . UTF8 . GetString ( msg . Topic . Data );   // convert byte[]. \n     Debug . LogFormat ( Message has id  {0}  and content  {1} . ,   id ,   data ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A cursor can be used to page after a batch of messages for the next set of results.  We recommend you only list the most recent 100 messages in your UI. A good user experience could be to fetch the next 100 older messages when the user scrolls to the bottom of your UI panel.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  var   messageBuilder   =   new   NTopicMessagesListMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Limit ( 100 );  client . Send ( messageBuilder . Build (),   ( INResultSet INTopicMessage   list )   =   { \n   // Lets get the next page of results. \n   INCursor   cursor   =   list . Cursor ; \n   if   ( cursor   !=   null     list . Results . Count     0 )   { \n     var   message   =   messageBuilder . Cursor ( cursor ). Build (); \n\n     client . Send ( message ,   ( INResultSet INTopicMessage   nextList )   =   { \n       foreach   ( var   msg   in   nextList . Results )   { \n         var   id   =   Encoding . UTF8 . GetString ( msg . Topic . Id );       // convert byte[]. \n         var   data   =   Encoding . UTF8 . GetString ( msg . Topic . Data );   // convert byte[]. \n         Debug . LogFormat ( Message has id  {0}  and content  {1} . ,   id ,   data ); \n       } \n     },   errorHandler ); \n   }  },   errorHandler );", 
            "title": "Message history"
        }, 
        {
            "location": "/in-app-purchase-validation/", 
            "text": "In-app Purchase Validation\n\n\nThe spectrum of monetisation models and tools is extremely varied. From ad-supported, microtransactions, freemium, one-off purchases, and everything in between. A key tool in many of these solutions is the In-App Purchase, which enables single purchases for unlocks, in-game consumables, subscriptions for premium access, and more.\n\n\nThere are a number of readily available attacks against the most common in-app purchase implementations.\n\n\nThese are usually focused around:\n\n\n\n\nFeeding the client fake purchase responses which indicate success.\n\n\nReplaying a valid purchase response multiple times.\n\n\nSharing a purchase response with another client, so multiple players can receive the reward from a single purchase.\n\n\n...and more, with new vulnerabilities emerging occasionally.\n\n\n\n\nFor in-app purchases, a trusted source of truth is required. Nakama checks and tracks purchases and purchase history, solving a significant set of possible vulnerabilities and pain points.\n\n\nIn-App Purchase Validation is available for Apple and Google purchases, regardless of platform. Both single product and subscription purchases are supported.\n\n\nFake Purchases\n\n\nNakama directly connects to Apple and Google services to check the validity of all incoming payments. This verification is completely outside the client's code, and cannot be intercepted and tampered with.\n\n\nEvery transaction is verified, every time, and invalid ones are rejected.\n\n\nReplay Attacks\n\n\nAll transactions are logged, preventing multiple submissions of the same purchase token or receipt.\n\n\nReceipt Sharing\n\n\nSuccessful transactions are bound to the account that submits them. Different users cannot submit the same transaction, even a valid one, in an attempt to receive the associated reward.\n\n\nProduct Mismatches\n\n\nThe transaction is checked to ensure the correct reward is tied to each purchase. This prevents attacks that attempt to use a valid (cheap) purchase to unlock a different (expensive) reward.\n\n\nSubscription Expiry\n\n\nNakama checks subscriptions to see if they've expired, and rejects the transaction as needed.\n\n\nPurchase Cancellation\n\n\nValid receipts that link to cancelled purchases are flagged and rejected.\n\n\nSingle Source of Truth\n\n\nWhile Nakama maintains an internal record of all transactions, the remote payment provider is always given priority. Valid purchases that have been checked, logged, then subsequently cancelled, will be rejected appropriately.\n\n\nApple\n\n\nNakama supports validating purchases made for products and subscription in iOS.\n\n\nApple purchase receipts are sent to Apple for validation. As suggested by Apple, both Production and Sandbox servers are used to validate receipts depending on the priority setup in the Nakama configuration.\n\n\nSetup\n\n\nTo validate receipts against the App Store, Nakama requires your app's shared secret. You can setup a shared secret in \niTunes Connect\n.\n\n\n\n\nMake a record of your shared secret:\n\n\n\n\nYou'll need to set the value of \npurchase.apple.password\n to the value of the Shared Secret above. For more info, take a look at the \nconfiguration\n page.\n\n\nIf your app is in production, you'll need to set the value of \npurchase.apple.production\n to true to give priority Apple's Production servers.\n\n\nValidate Purchase\n\n\nNakama only supports validating iOS 7+ receipts. In addition, Nakama only validates the first item in the receipt as Apple receipts can contain more than one in-app purchase item.\n\n\nvar\n \nproductId\n \n=\n \ncom.yourcompany.product\n;\n\n\nvar\n \nreceiptData\n \n=\n \n...some-base64-encoded-data...\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNPurchaseValidateMessage\n.\nApple\n(\nproductId\n,\n \nreceiptData\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINPurchaseRecord\n \nrecord\n)\n \n=\n\n\n{\n\n  \nif\n \n(!\nrecord\n.\nSuccess\n)\n \n{\n\n    \nDebug\n.\nLog\n(\nPurchase was not validation. Reason: {0}.\n,\n \nrecord\n.\nMessage\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nrecord\n.\nSeenBefore\n)\n \n{\n\n      \n// This is useful for recovering previous purchases\n\n      \nDebug\n.\nLog\n(\nThis is a valid purchase but the purchase item was redeemed once before.\n);\n\n    \n}\n \nelse\n \n{\n\n      \nDebug\n.\nLog\n(\nNew purchase was validated\n);\n\n    \n}\n\n  \n}\n\n\n},\n \n(\nINError\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreceipt_data\n\n\nstring\n\n\nBase-64 encoded receipt data returned by the purchase operation itself.\n\n\n\n\n\n\nproduct_id\n\n\nstring\n\n\nThe product, item, or subscription package ID the purchase relates to.\n\n\n\n\n\n\n\n\nGoogle\n\n\nNakama supports validating purchases made for products and subscription on Android.\n\n\nSetup\n\n\nTo validate receipts against the Play Store, Nakama requires your app's package name, as well as a service file. You can setup a service account and download the service file on \nGoogle Play Developer Console\n.\n\n\nFirstly, you'll need to setup a Service Account in the \nGoogle API Console\n.\n\n\n\n\nOnce a service account is created, you'll need to create a key:\n\n\n\n\nDownload the key as a JSON file. You'll need to put this file somewhere that Nakama server can access.\n\n\n\n\nOnce the key is created, navigate back to \nGoogle Play Developer Console\n and navigate to \nSettings\n \n \nAPI Access\n.\n\n\nThe service account you created in the previous steps should be listed above. You'll need to grant access to the service account to access the API:\n\n\n\n\nMake sure that you give the service account access to \nVisibility\n, \nView Financial Data\n, and \nManage Orders\n. These permissions are required for Nakama to validate receipts against Google Play.\n\n\n\n\nNavigate to \nUsers \n Permissions\n to check that the service account is setup correctly.\n\n\n\n\nLastly, you'll need to update Nakama's configuration with the following information:\n\n\n\n\n\n\npurchase.google.package_name\n: Package name for your Android app, as you've listed in Google Play.\n\n\n\n\n\n\npurchase.google.service_key_file\n: Path of the JSON file you download in previous steps. This file contains authentication information that allows Nakama to communicate with Google Play on your behalf. Make sure that the file is kept safe and is only accessible by Nakama and other authorized parties.\n\n\n\n\n\n\nValidate Purchase\n\n\nvar\n \nproductId\n \n=\n \ncom.yourcompany.product\n;\n\n\nvar\n \npurchaseType\n \n=\n \nproduct\n;\n\n\nvar\n \npurchaseToken\n \n=\n \nsome-token-from-google\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNPurchaseValidateMessage\n.\nGoogle\n(\nproductId\n,\n \npurchaseType\n,\n \npurchaseToken\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINPurchaseRecord\n \nrecord\n)\n \n=\n\n\n{\n\n  \nif\n \n(!\nrecord\n.\nSuccess\n)\n \n{\n\n    \nDebug\n.\nLog\n(\nPurchase was not validation. Reason: {0}.\n,\n \nrecord\n.\nMessage\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nrecord\n.\nSeenBefore\n)\n \n{\n\n      \n// This is useful for recovering previous purchases\n\n      \nDebug\n.\nLog\n(\nThis is a valid purchase but the purchase item was redeemed once before.\n);\n\n    \n}\n \nelse\n \n{\n\n      \nDebug\n.\nLog\n(\nNew purchase was validated\n);\n\n    \n}\n\n  \n}\n\n\n},\n \n(\nINError\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nproduct_type\n\n\nstring\n\n\nWhether the purchase is for a \nproduct\n or a \nsubscription\n\n\n\n\n\n\npurchase_token\n\n\nstring\n\n\nThe token returned in the purchase operation response, acts as a transaction identifier.\n\n\n\n\n\n\nproduct_id\n\n\nstring\n\n\nThe identifier of the product or subscription being purchased.\n\n\n\n\n\n\n\n\nInterpreting Responses\n\n\nResponses contain the following information:\n\n\n\n\nsuccess\n - Whether or not the transaction is valid and all the information matches.\n\n\nseen_before\n - If this is a new transaction or if Nakama has a log of it.\n\n\npurchase_provider_reachable\n - Indicates whether or not Nakama was able to reach the remote purchase service.\n\n\nmessage\n - A string indicating why the purchase verification failed, if appropriate.\n\n\ndata\n - The complete response Nakama received from the remote service.\n\n\n\n\n\n\nNote\n\n\nIf \npurchase_provider_reachable\n is \nfalse\n it indicates that Nakama was unable to query the remote purchase service. In this situation the client should use its discretion to decide if the purchase should be accepted, and must queue up the verification request for a later retry.\n\n\n\n\nEach response contains all the information needed to take the appropriate action. Below is a quick reference for interpreting the key fields:\n\n\n\n\n\n\n\n\n\n\nseen_before\n = \ntrue\n\n\nseen_before\n = \nfalse\n\n\n\n\n\n\n\n\n\n\n\n\nsuccess\n = \ntrue\n\n\nValid, but Nakama has an existing record of it.\n\n\nValid and new.\n\n\n\n\n\n\n\n\nsuccess\n = \nfalse\n\n\n Rejected, check \nmessage\n field for reason.\n\n\nRejected, check \nmessage\n field for reason.\n\n\n\n\n\n\n\n\n\n\nRecovering Purchases\n\n\nWhen users change devices, it's common to offer an option (or fully automated process) to re-apply the benefits of any previous purchases to their new client installation.\n\n\nClients should always refer to the platform purchase provider for a list of purchases, then verify each one with Nakama. In this case clients should accommodate responses where the \nseen_before\n indicator is true and act accordingly.", 
            "title": "In-app Purchase Validation"
        }, 
        {
            "location": "/in-app-purchase-validation/#in-app-purchase-validation", 
            "text": "The spectrum of monetisation models and tools is extremely varied. From ad-supported, microtransactions, freemium, one-off purchases, and everything in between. A key tool in many of these solutions is the In-App Purchase, which enables single purchases for unlocks, in-game consumables, subscriptions for premium access, and more.  There are a number of readily available attacks against the most common in-app purchase implementations.  These are usually focused around:   Feeding the client fake purchase responses which indicate success.  Replaying a valid purchase response multiple times.  Sharing a purchase response with another client, so multiple players can receive the reward from a single purchase.  ...and more, with new vulnerabilities emerging occasionally.   For in-app purchases, a trusted source of truth is required. Nakama checks and tracks purchases and purchase history, solving a significant set of possible vulnerabilities and pain points.  In-App Purchase Validation is available for Apple and Google purchases, regardless of platform. Both single product and subscription purchases are supported.  Fake Purchases  Nakama directly connects to Apple and Google services to check the validity of all incoming payments. This verification is completely outside the client's code, and cannot be intercepted and tampered with.  Every transaction is verified, every time, and invalid ones are rejected.  Replay Attacks  All transactions are logged, preventing multiple submissions of the same purchase token or receipt.  Receipt Sharing  Successful transactions are bound to the account that submits them. Different users cannot submit the same transaction, even a valid one, in an attempt to receive the associated reward.  Product Mismatches  The transaction is checked to ensure the correct reward is tied to each purchase. This prevents attacks that attempt to use a valid (cheap) purchase to unlock a different (expensive) reward.  Subscription Expiry  Nakama checks subscriptions to see if they've expired, and rejects the transaction as needed.  Purchase Cancellation  Valid receipts that link to cancelled purchases are flagged and rejected.  Single Source of Truth  While Nakama maintains an internal record of all transactions, the remote payment provider is always given priority. Valid purchases that have been checked, logged, then subsequently cancelled, will be rejected appropriately.", 
            "title": "In-app Purchase Validation"
        }, 
        {
            "location": "/in-app-purchase-validation/#apple", 
            "text": "Nakama supports validating purchases made for products and subscription in iOS.  Apple purchase receipts are sent to Apple for validation. As suggested by Apple, both Production and Sandbox servers are used to validate receipts depending on the priority setup in the Nakama configuration.", 
            "title": "Apple"
        }, 
        {
            "location": "/in-app-purchase-validation/#setup", 
            "text": "To validate receipts against the App Store, Nakama requires your app's shared secret. You can setup a shared secret in  iTunes Connect .   Make a record of your shared secret:   You'll need to set the value of  purchase.apple.password  to the value of the Shared Secret above. For more info, take a look at the  configuration  page.  If your app is in production, you'll need to set the value of  purchase.apple.production  to true to give priority Apple's Production servers.", 
            "title": "Setup"
        }, 
        {
            "location": "/in-app-purchase-validation/#validate-purchase", 
            "text": "Nakama only supports validating iOS 7+ receipts. In addition, Nakama only validates the first item in the receipt as Apple receipts can contain more than one in-app purchase item.  var   productId   =   com.yourcompany.product ;  var   receiptData   =   ...some-base64-encoded-data... ;  var   message   =   NPurchaseValidateMessage . Apple ( productId ,   receiptData );  client . Send ( message ,   ( INPurchaseRecord   record )   =  { \n   if   (! record . Success )   { \n     Debug . Log ( Purchase was not validation. Reason: {0}. ,   record . Message ); \n   }   else   { \n     if   ( record . SeenBefore )   { \n       // This is useful for recovering previous purchases \n       Debug . Log ( This is a valid purchase but the purchase item was redeemed once before. ); \n     }   else   { \n       Debug . Log ( New purchase was validated ); \n     } \n   }  },   ( INError   e )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });      Param  Type  Description      receipt_data  string  Base-64 encoded receipt data returned by the purchase operation itself.    product_id  string  The product, item, or subscription package ID the purchase relates to.", 
            "title": "Validate Purchase"
        }, 
        {
            "location": "/in-app-purchase-validation/#google", 
            "text": "Nakama supports validating purchases made for products and subscription on Android.", 
            "title": "Google"
        }, 
        {
            "location": "/in-app-purchase-validation/#setup_1", 
            "text": "To validate receipts against the Play Store, Nakama requires your app's package name, as well as a service file. You can setup a service account and download the service file on  Google Play Developer Console .  Firstly, you'll need to setup a Service Account in the  Google API Console .   Once a service account is created, you'll need to create a key:   Download the key as a JSON file. You'll need to put this file somewhere that Nakama server can access.   Once the key is created, navigate back to  Google Play Developer Console  and navigate to  Settings     API Access .  The service account you created in the previous steps should be listed above. You'll need to grant access to the service account to access the API:   Make sure that you give the service account access to  Visibility ,  View Financial Data , and  Manage Orders . These permissions are required for Nakama to validate receipts against Google Play.   Navigate to  Users   Permissions  to check that the service account is setup correctly.   Lastly, you'll need to update Nakama's configuration with the following information:    purchase.google.package_name : Package name for your Android app, as you've listed in Google Play.    purchase.google.service_key_file : Path of the JSON file you download in previous steps. This file contains authentication information that allows Nakama to communicate with Google Play on your behalf. Make sure that the file is kept safe and is only accessible by Nakama and other authorized parties.", 
            "title": "Setup"
        }, 
        {
            "location": "/in-app-purchase-validation/#validate-purchase_1", 
            "text": "var   productId   =   com.yourcompany.product ;  var   purchaseType   =   product ;  var   purchaseToken   =   some-token-from-google ;  var   message   =   NPurchaseValidateMessage . Google ( productId ,   purchaseType ,   purchaseToken );  client . Send ( message ,   ( INPurchaseRecord   record )   =  { \n   if   (! record . Success )   { \n     Debug . Log ( Purchase was not validation. Reason: {0}. ,   record . Message ); \n   }   else   { \n     if   ( record . SeenBefore )   { \n       // This is useful for recovering previous purchases \n       Debug . Log ( This is a valid purchase but the purchase item was redeemed once before. ); \n     }   else   { \n       Debug . Log ( New purchase was validated ); \n     } \n   }  },   ( INError   e )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });      Param  Type  Description      product_type  string  Whether the purchase is for a  product  or a  subscription    purchase_token  string  The token returned in the purchase operation response, acts as a transaction identifier.    product_id  string  The identifier of the product or subscription being purchased.", 
            "title": "Validate Purchase"
        }, 
        {
            "location": "/in-app-purchase-validation/#interpreting-responses", 
            "text": "Responses contain the following information:   success  - Whether or not the transaction is valid and all the information matches.  seen_before  - If this is a new transaction or if Nakama has a log of it.  purchase_provider_reachable  - Indicates whether or not Nakama was able to reach the remote purchase service.  message  - A string indicating why the purchase verification failed, if appropriate.  data  - The complete response Nakama received from the remote service.    Note  If  purchase_provider_reachable  is  false  it indicates that Nakama was unable to query the remote purchase service. In this situation the client should use its discretion to decide if the purchase should be accepted, and must queue up the verification request for a later retry.   Each response contains all the information needed to take the appropriate action. Below is a quick reference for interpreting the key fields:      seen_before  =  true  seen_before  =  false       success  =  true  Valid, but Nakama has an existing record of it.  Valid and new.     success  =  false   Rejected, check  message  field for reason.  Rejected, check  message  field for reason.", 
            "title": "Interpreting Responses"
        }, 
        {
            "location": "/in-app-purchase-validation/#recovering-purchases", 
            "text": "When users change devices, it's common to offer an option (or fully automated process) to re-apply the benefits of any previous purchases to their new client installation.  Clients should always refer to the platform purchase provider for a list of purchases, then verify each one with Nakama. In this case clients should accommodate responses where the  seen_before  indicator is true and act accordingly.", 
            "title": "Recovering Purchases"
        }, 
        {
            "location": "/runtime-function-reference/", 
            "text": "Function Reference\n\n\nThe code runtime built into the server includes a module with functions to implement various logic and custom behavior. It is easy to define authoritative code and conditions on input received by clients.\n\n\nNakama module\n\n\nThis module contains all the core gameplay APIs, all registration functions used at server startup, utilities for various codecs, and cryptographic primitives.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n\n\n\n\n\nNote\n\n\nAll code examples assume the \"nakama\" module has been imported.\n\n\n\n\nbase16\n\n\nbase16_decode (input)\n\n\nBase 16 decode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base16 decoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 16 decoded input.\n\n\nExample\n\n\nlocal\n \ndecoded\n \n=\n \nnk\n.\nbase16_decode\n(\n48656C6C6F20776F726C64\n)\n\n\nprint\n(\ndecoded\n)\n \n-- outputs \nHello world\n\n\n\n\n\n\n\n\nbase16_encode (input)\n\n\nBase 16 encode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base16 encoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 16 encoded input.\n\n\nExample\n\n\nlocal\n \nencoded\n \n=\n \nnk\n.\nbase16_encode\n(\nHello world\n)\n\n\nprint\n(\nencoded\n)\n \n-- outputs \n48656C6C6F20776F726C64\n\n\n\n\n\n\nbase64\n\n\nbase64_decode (input)\n\n\nBase 64 decode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base64 decoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 64 decoded input.\n\n\nExample\n\n\nlocal\n \ndecoded\n \n=\n \nnk\n.\nbase64_decode\n(\nSGVsbG8gd29ybGQ=\n)\n\n\nprint\n(\ndecoded\n)\n \n-- outputs \nHello world\n\n\n\n\n\n\n\n\nbase64_encode (input)\n\n\nBase 64 encode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base64 encoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 64 encoded input.\n\n\nExample\n\n\nlocal\n \nencoded\n \n=\n \nnk\n.\nbase64_encode\n(\nHello world\n)\n\n\nprint\n(\nencoded\n)\n \n-- outputs \nSGVsbG8gd29ybGQ=\n\n\n\n\n\n\ngroups\n\n\ngroups_create (new_groups)\n\n\nSetup one or more groups with various configuration settings. The groups will be created if they don't exist or fail if the group names are taken.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_groups\n\n\ntable\n\n\nThe Lua table array of new groups to create.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nmetadata\n \n=\n \n{\n \n-- Add whatever custom fields you want.\n\n  \nmy_custom_field\n \n=\n \nsome value\n\n\n}\n\n\nlocal\n \ngroup\n \n=\n \n{\n\n  \nName\n \n=\n \nSome unique group name\n,\n\n  \nDescription\n \n=\n \nMy awesome group.\n,\n\n  \nLang\n \n=\n \nen\n,\n\n  \nPrivate\n \n=\n \ntrue\n,\n\n  \nCreatorId\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n,\n\n  \nAvatarUrl\n \n=\n \nurl://somelink\n,\n\n  \nMetadata\n \n=\n \nmetadata\n\n\n}\n\n\nlocal\n \nnew_groups\n \n=\n \n{\n \ngroup\n \n}\n\n\nnk\n.\ngroups_create\n(\nnew_groups\n)\n\n\n\n\n\n\nhttp\n\n\nhttp_request (url, method, headers, content)\n\n\nSend a HTTP request and receive the result as a Lua table.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nstring\n\n\nThe URL of the web resource to request.\n\n\n\n\n\n\nmethod\n\n\nstring\n\n\nThe HTTP method verb used with the request.\n\n\n\n\n\n\nheaders\n\n\ntable\n\n\nA table of headers used with the request.\n\n\n\n\n\n\ncontent\n\n\nstring\n\n\nThe bytes to send with the request.\n\n\n\n\n\n\n\n\nReturns\n\n\ncode, headers, body\n - Multiple return values for the HTTP response.\n\n\nExample\n\n\nlocal\n \nurl\n \n=\n \nhttps://google.com/\n\n\nlocal\n \nmethod\n \n=\n \nHEAD\n\n\nlocal\n \nheaders\n \n=\n \n{\n\n  \n[\nContent-Type\n]\n \n=\n \napplication/json\n,\n\n  \n[\nAccept\n]\n \n=\n \napplication/json\n\n\n}\n\n\nlocal\n \ncontent\n \n=\n \nnk\n.\njson_encode\n({})\n \n-- encode table as JSON string\n\n\nlocal\n \nsuccess\n,\n \ncode\n,\n \nheaders\n,\n \nbody\n \n=\n \npcall\n(\nnk\n.\nhttp_request\n,\n \nurl\n,\n \nmethod\n,\n \nheaders\n,\n \ncontent\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nFailed %q\n):\nformat\n(\ncode\n))\n\n\nelseif\n \n(\ncode\n \n=\n \n400\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nFailed %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n\nelse\n\n  \nnk\n.\nlogger_info\n((\nSuccess %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n\nend\n\n\n\n\n\n\njson\n\n\njson_decode (input)\n\n\nDecode the JSON input as a Lua table.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe JSON encoded input.\n\n\n\n\n\n\n\n\nReturns\n\n\nA Lua table with the decoded JSON.\n\n\nExample\n\n\nlocal\n \njson\n \n=\n \nnk\n.\njson_decode\n(\n{\nhello\n: \nworld\n}\n)\n\n\nprint\n(\njson\n.\nhello\n)\n\n\n\n\n\n\n\n\njson_encode (input)\n\n\nEncode the input as JSON.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe input to encode as JSON.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe encoded JSON string.\n\n\nExample\n\n\nlocal\n \ninput\n \n=\n \n{[\nsome\n]\n \n=\n \njson\n}\n\n\nlocal\n \njson\n \n=\n \nnk\n.\njson_encode\n(\ninput\n)\n\n\nprint\n(\njson\n)\n \n-- outputs \n{\nsome\n: \njson\n}\n\n\n\n\n\n\nleaderboard\n\n\nleaderboard_create (id, sort, reset, metadata, authoritative)\n\n\nSetup a new dynamic leaderboard with the specified ID and various configuration settings. The leaderboard will be created if it doesn't already exist.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe unique identifier for the new leaderboard. This is used by clients to submit scores.\n\n\n\n\n\n\nsort\n\n\nstring\n\n\nThe sort order for records in the leaderboard; possible values are \"asc\" or \"desc\".\n\n\n\n\n\n\nreset\n\n\nstring\n\n\nThe cron format used to define the reset schedule for the leaderboard. This controls when a leaderboard is reset and can be used to power daily/weekly/monthly leaderboards.\n\n\n\n\n\n\nmetadata\n\n\ntable\n\n\nThe metadata you want associated to the leaderboard. Some good examples are weather conditions for a racing game.\n\n\n\n\n\n\nauthoritative\n\n\nbool\n\n\nMark the leaderboard as authoritative which ensures updates can only be made via the Lua runtime. No client can submit a score directly.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nmetadata\n \n=\n \n{\n\n  \nweather_conditions\n \n=\n \nrain\n\n\n}\n\n\nlocal\n \nid\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n\n\nnk\n.\nleaderboard_create\n(\nid\n,\n \ndesc\n,\n \n0 0 * * 1\n,\n \nmetadata\n,\n \nfalse\n)\n\n\n\n\n\n\nlogger\n\n\nlogger_error (message)\n\n\nWrite an ERROR level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with ERROR level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_error\n(\nmessage\n)\n\n\n\n\n\n\n\n\nlogger_info (message)\n\n\nWrite an INFO level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with INFO level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_info\n(\nmessage\n)\n\n\n\n\n\n\n\n\nlogger_warn (message)\n\n\nWrite an WARN level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with WARN level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_warn\n(\nmessage\n)\n\n\n\n\n\n\nnotifications\n\n\nnotifications_send_id (new_notifications)\n\n\nSend one or more in-app notifications to a user. Have a look at the section on \nin-app notifications\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_notifications\n\n\ntable\n\n\nThe Lua table array of notifications to send.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nsubject\n \n=\n \nYou\nve unlocked level 100!\n\n\nlocal\n \ncontent\n \n=\n \nnk\n.\njson_encode\n({\n\n  \nreward_coins\n \n=\n \n1000\n\n\n})\n\n\nlocal\n \nuser_id\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n \n-- who to send\n\n\nlocal\n \ncode\n \n=\n \n101\n\n\n\nlocal\n \nnew_notifications\n \n=\n \n{\n\n  \n{\n \nSubject\n \n=\n \nsubject\n,\n \nContent\n \n=\n \ncontent\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nCode\n \n=\n \ncode\n,\n \nPersistent\n \n=\n \ntrue\n}\n\n\n}\n\n\nnk\n.\nnotifications_send_id\n(\nnew_notifications\n)\n\n\n\n\n\n\nregister hooks\n\n\nregister_after (func, msgname)\n\n\nRegister a function with the server which will be executed after every message with the specified message name.\n\n\nThis can be used to apply custom logic to standard features in the server. Similar to the \nregister_before\n function but it will not block the execution pipeline. The logic will be executed in parallel to any response message sent back to a client. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each \nmsgname\n message.\n\n\n\n\n\n\nmsgname\n\n\nstring\n\n\nThe specific message name to execute the \nfunc\n function after.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n\nend\n\n\nnk\n.\nregister_after\n(\nmy_func\n,\n \nTFriendsAdd\n)\n\n\n\n\n\n\n\n\nregister_before (func, msgname)\n\n\nRegister a function with the server which will be executed before every message with the specified message name.\n\n\nFor example \nregister_before(somefunc, \"TFriendAdd\")\n will execute the function before the Friend Add message is executed by the server's message pipeline. This can be used to apply custom conditions to standard features in the server. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each \nmsgname\n message.\n\n\n\n\n\n\nmsgname\n\n\nstring\n\n\nThe specific message name to execute the \nfunc\n function before.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n should pass the \npayload\n back as a return argument so the pipeline can continue to execute the standard logic.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n  \nreturn\n \npayload\n \n-- important!\n\n\nend\n\n\nnk\n.\nregister_before\n(\nmy_func\n,\n \nTFriendsAdd\n)\n\n\n\n\n\n\n\n\nregister_http (func, path)\n\n\nRegisters a HTTP endpoint within the server.\n\n\n\n\nWarning\n\n\nThis should not be used to implement custom client functions instead have a look at \nregister_rpc\n.\n\n\n\n\nThis can be useful to define web callbacks to handle various Ad networks. It can also be used to enable server to server communication to ease the integration of Nakama server into various server stacks. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each HTTP call.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nThe path that should be registered as a HTTP endpoint.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n can pass \nnil\n or \ntable\n back as a return argument which will determine the HTTP response code returned.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- let\ns return the \ncontext\n as JSON back in the HTTP response body\n\n  \nreturn\n \ncontext\n\n\nend\n\n\nnk\n.\nregister_http\n(\nmy_func\n,\n \n/my_endpoint\n)\n\n\n-- \nmy_func\n will be registered at \nPOST /runtime/my_endpoint\n\n\n\n\n\n\nYou can send a request to the HTTP endpoint with JSON and responses will be returned in JSON.\n\n\ncurl -X POST http://127.0.0.1:7350/runtime/my_endpoint?key\n=\ndefaultkey \n\\\n\n     -d \n{\nsome\n: \ndata\n}\n \n\\\n\n     -H \nContent-Type: application/json\n \n\\\n\n     -H \nAccept: application/json\n\n\n\n\n\n\n\n\nregister_rpc (func, id)\n\n\nRegisters a function for use with client RPC to the server.\n\n\nThe ID can be any string identifier and is sent by the client. The ID is used to map the client RPC message to the specific function to execute. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each RPC message.\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe unique identifier used to register the \nfunc\n function for RPC.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n can pass \nnil\n or \nstring\n back as a return argument which will returned as bytes in the RPC response.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n\nend\n\n\nnk\n.\nregister_rpc\n(\nmy_func\n,\n \nmy_func_id\n)\n\n\n\n\n\n\nstorage\n\n\nstorage_fetch (record_keys)\n\n\nFetch one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of record identifiers to be fetched.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the records result set.\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n}\n\n\n}\n\n\nlocal\n \nrecords\n \n=\n \nnk\n.\nstorage_fetch\n(\nrecord_keys\n)\n\n\nfor\n \n_\n,\n \nr\n \nin\n \nipairs\n(\nrecords\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nread: %q, write: %q, value: %q\n):\nformat\n(\nr\n.\nPermissionRead\n,\n \nr\n.\nPermissionWrite\n,\n \nr\n.\nValue\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nstorage_remove (record_keys)\n\n\nRemove one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of record identifiers to be removed.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n}\n\n\n}\n\n\nnk\n.\nstorage_remove\n(\nrecord_keys\n)\n\n\n\n\n\n\n\n\nstorage_update (record_keys)\n\n\nUpdate one or more records by their bucket/collection/keyname and optional user. Have a look at the section on \nstorage collections\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of records to update.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nnow\n \n=\n \nos.time\n()\n \n*\n \n1000\n \n-- current time converted for msec\n\n\nlocal\n \nupdate_ops\n \n=\n \n{\n\n  \n{\nOp\n \n=\n \ninit\n,\n \nPath\n \n=\n \n/\n,\n \nValue\n \n=\n \n{\n \nprogress\n \n=\n \n1\n \n}},\n\n  \n{\nOp\n \n=\n \nincr\n,\n \nPath\n \n=\n \n/progress\n,\n \nValue\n \n=\n \n1\n},\n\n  \n{\nOp\n \n=\n \nreplace\n,\n \nPath\n \n=\n \n/updated_at\n,\n \nValue\n \n=\n \nnow\n}\n\n\n}\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nb\n,\n \nCollection\n \n=\n \nc\n,\n \nRecord\n \n=\n \nr\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nUpdateOps\n \n=\n \nupdate_ops\n}\n\n\n}\n\n\nnk\n.\nstorage_update\n(\nrecord_keys\n)\n\n\n\n\n\n\n\n\nstorage_write (new_records)\n\n\nWrite one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_records\n\n\ntable\n\n\nA table array of new records to write.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nnew_records\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}}\n\n\n}\n\n\nnk\n.\nstorage_write\n(\nnew_records\n)\n\n\n\n\n\n\nusers\n\n\nusers_ban (user_ids)\n\n\nBan one or more users from the server.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_ids\n\n\ntable\n\n\nA table array of user IDs to be banned.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n4c2ae592-b2a7-445e-98ec-697694478b1c\n}\n\n\nlocal\n \nstatus\n,\n \nresult\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nuser_ids\n)\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nprint\n(\nresult\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_fetch_handle (user_handles)\n\n\nFetch a set of users by handle.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_handles\n\n\ntable\n\n\nA table array of user handles to fetch.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the user result set.\n\n\nExample\n\n\nlocal\n \nuser_handles\n \n=\n \n{\nb7865e7e\n,\n \nc048ba7a\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nusers_fetch_handle\n(\nuser_handles\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nid: %q, fullname: %q\n):\nformat\n(\nu\n.\nId\n,\n \nu\n.\nFullname\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_fetch_id (user_ids)\n\n\nFetch one or more users by ID.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_ids\n\n\ntable\n\n\nA table array of user IDs to fetch.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the user result set.\n\n\nExample\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n\n  \n3ea5608a-43c3-11e7-90f9-7b9397165f34\n,\n\n  \n447524be-43c3-11e7-af09-3f7172f05936\n\n\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nuser_fetch_id\n(\nuser_ids\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nhandle: %q, fullname: %q\n):\nformat\n(\nu\n.\nHandle\n,\n \nu\n.\nFullname\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_update (user_updates)\n\n\nUpdate one or more users.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_updates\n\n\ntable\n\n\nThe table array of users to update.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nuser_updates\n \n=\n \n{\n\n  \n{\n \nUserId\n \n=\n \nuser_id\n,\n \nMetadata\n \n=\n \n{}\n \n}\n\n\n}\n\n\nlocal\n \nstatus\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_update\n,\n \nuser_updates\n)\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nprint\n((\nUser update error: %q\n):\nformat\n(\nerr\n))\n\n\nend\n\n\n\n\n\n\nuuid\n\n\nuuid_v4 ()\n\n\nGenerate a version 4 UUID.\n\n\nReturns\n\n\nThe generated version 4 UUID identifier.\n\n\nExample\n\n\nlocal\n \nuuid\n \n=\n \nnk\n.\nuuid_v4\n()\n\n\nprint\n(\nuuid\n)", 
            "title": "Function Reference"
        }, 
        {
            "location": "/runtime-function-reference/#function-reference", 
            "text": "The code runtime built into the server includes a module with functions to implement various logic and custom behavior. It is easy to define authoritative code and conditions on input received by clients.", 
            "title": "Function Reference"
        }, 
        {
            "location": "/runtime-function-reference/#nakama-module", 
            "text": "This module contains all the core gameplay APIs, all registration functions used at server startup, utilities for various codecs, and cryptographic primitives.  local   nk   =   require ( nakama )    Note  All code examples assume the \"nakama\" module has been imported.", 
            "title": "Nakama module"
        }, 
        {
            "location": "/runtime-function-reference/#base16", 
            "text": "base16_decode (input)  Base 16 decode the input.  Parameters     Param  Type  Description      input  string  The string which will be base16 decoded.     Returns  The base 16 decoded input.  Example  local   decoded   =   nk . base16_decode ( 48656C6C6F20776F726C64 )  print ( decoded )   -- outputs  Hello world    base16_encode (input)  Base 16 encode the input.  Parameters     Param  Type  Description      input  string  The string which will be base16 encoded.     Returns  The base 16 encoded input.  Example  local   encoded   =   nk . base16_encode ( Hello world )  print ( encoded )   -- outputs  48656C6C6F20776F726C64", 
            "title": "base16"
        }, 
        {
            "location": "/runtime-function-reference/#base64", 
            "text": "base64_decode (input)  Base 64 decode the input.  Parameters     Param  Type  Description      input  string  The string which will be base64 decoded.     Returns  The base 64 decoded input.  Example  local   decoded   =   nk . base64_decode ( SGVsbG8gd29ybGQ= )  print ( decoded )   -- outputs  Hello world    base64_encode (input)  Base 64 encode the input.  Parameters     Param  Type  Description      input  string  The string which will be base64 encoded.     Returns  The base 64 encoded input.  Example  local   encoded   =   nk . base64_encode ( Hello world )  print ( encoded )   -- outputs  SGVsbG8gd29ybGQ=", 
            "title": "base64"
        }, 
        {
            "location": "/runtime-function-reference/#groups", 
            "text": "groups_create (new_groups)  Setup one or more groups with various configuration settings. The groups will be created if they don't exist or fail if the group names are taken.  Parameters     Param  Type  Description      new_groups  table  The Lua table array of new groups to create.     Example  local   metadata   =   {   -- Add whatever custom fields you want. \n   my_custom_field   =   some value  }  local   group   =   { \n   Name   =   Some unique group name , \n   Description   =   My awesome group. , \n   Lang   =   en , \n   Private   =   true , \n   CreatorId   =   4c2ae592-b2a7-445e-98ec-697694478b1c , \n   AvatarUrl   =   url://somelink , \n   Metadata   =   metadata  }  local   new_groups   =   {   group   }  nk . groups_create ( new_groups )", 
            "title": "groups"
        }, 
        {
            "location": "/runtime-function-reference/#http", 
            "text": "http_request (url, method, headers, content)  Send a HTTP request and receive the result as a Lua table.  Parameters     Param  Type  Description      url  string  The URL of the web resource to request.    method  string  The HTTP method verb used with the request.    headers  table  A table of headers used with the request.    content  string  The bytes to send with the request.     Returns  code, headers, body  - Multiple return values for the HTTP response.  Example  local   url   =   https://google.com/  local   method   =   HEAD  local   headers   =   { \n   [ Content-Type ]   =   application/json , \n   [ Accept ]   =   application/json  }  local   content   =   nk . json_encode ({})   -- encode table as JSON string  local   success ,   code ,   headers ,   body   =   pcall ( nk . http_request ,   url ,   method ,   headers ,   content )  if   ( not   success )   then \n   nk . logger_error (( Failed %q ): format ( code ))  elseif   ( code   =   400 )   then \n   nk . logger_error (( Failed %q %q ): format ( code ,   body ))  else \n   nk . logger_info (( Success %q %q ): format ( code ,   body ))  end", 
            "title": "http"
        }, 
        {
            "location": "/runtime-function-reference/#json", 
            "text": "json_decode (input)  Decode the JSON input as a Lua table.  Parameters     Param  Type  Description      input  string  The JSON encoded input.     Returns  A Lua table with the decoded JSON.  Example  local   json   =   nk . json_decode ( { hello :  world } )  print ( json . hello )    json_encode (input)  Encode the input as JSON.  Parameters     Param  Type  Description      input  string  The input to encode as JSON.     Returns  The encoded JSON string.  Example  local   input   =   {[ some ]   =   json }  local   json   =   nk . json_encode ( input )  print ( json )   -- outputs  { some :  json }", 
            "title": "json"
        }, 
        {
            "location": "/runtime-function-reference/#leaderboard", 
            "text": "leaderboard_create (id, sort, reset, metadata, authoritative)  Setup a new dynamic leaderboard with the specified ID and various configuration settings. The leaderboard will be created if it doesn't already exist.  Parameters     Param  Type  Description      id  string  The unique identifier for the new leaderboard. This is used by clients to submit scores.    sort  string  The sort order for records in the leaderboard; possible values are \"asc\" or \"desc\".    reset  string  The cron format used to define the reset schedule for the leaderboard. This controls when a leaderboard is reset and can be used to power daily/weekly/monthly leaderboards.    metadata  table  The metadata you want associated to the leaderboard. Some good examples are weather conditions for a racing game.    authoritative  bool  Mark the leaderboard as authoritative which ensures updates can only be made via the Lua runtime. No client can submit a score directly.     Example  local   metadata   =   { \n   weather_conditions   =   rain  }  local   id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521  nk . leaderboard_create ( id ,   desc ,   0 0 * * 1 ,   metadata ,   false )", 
            "title": "leaderboard"
        }, 
        {
            "location": "/runtime-function-reference/#logger", 
            "text": "logger_error (message)  Write an ERROR level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with ERROR level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_error ( message )    logger_info (message)  Write an INFO level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with INFO level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_info ( message )    logger_warn (message)  Write an WARN level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with WARN level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_warn ( message )", 
            "title": "logger"
        }, 
        {
            "location": "/runtime-function-reference/#notifications", 
            "text": "notifications_send_id (new_notifications)  Send one or more in-app notifications to a user. Have a look at the section on  in-app notifications .  Parameters     Param  Type  Description      new_notifications  table  The Lua table array of notifications to send.     Example  local   subject   =   You ve unlocked level 100!  local   content   =   nk . json_encode ({ \n   reward_coins   =   1000  })  local   user_id   =   4c2ae592-b2a7-445e-98ec-697694478b1c   -- who to send  local   code   =   101  local   new_notifications   =   { \n   {   Subject   =   subject ,   Content   =   content ,   UserId   =   user_id ,   Code   =   code ,   Persistent   =   true }  }  nk . notifications_send_id ( new_notifications )", 
            "title": "notifications"
        }, 
        {
            "location": "/runtime-function-reference/#register-hooks", 
            "text": "register_after (func, msgname)  Register a function with the server which will be executed after every message with the specified message name.  This can be used to apply custom logic to standard features in the server. Similar to the  register_before  function but it will not block the execution pipeline. The logic will be executed in parallel to any response message sent back to a client. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each  msgname  message.    msgname  string  The specific message name to execute the  func  function after.     Example  local   function   my_func ( context ,   payload ) \n   -- run some code  end  nk . register_after ( my_func ,   TFriendsAdd )    register_before (func, msgname)  Register a function with the server which will be executed before every message with the specified message name.  For example  register_before(somefunc, \"TFriendAdd\")  will execute the function before the Friend Add message is executed by the server's message pipeline. This can be used to apply custom conditions to standard features in the server. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each  msgname  message.    msgname  string  The specific message name to execute the  func  function before.      Note  The  func  should pass the  payload  back as a return argument so the pipeline can continue to execute the standard logic.   Example  local   function   my_func ( context ,   payload ) \n   -- run some code \n   return   payload   -- important!  end  nk . register_before ( my_func ,   TFriendsAdd )    register_http (func, path)  Registers a HTTP endpoint within the server.   Warning  This should not be used to implement custom client functions instead have a look at  register_rpc .   This can be useful to define web callbacks to handle various Ad networks. It can also be used to enable server to server communication to ease the integration of Nakama server into various server stacks. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each HTTP call.    path  string  The path that should be registered as a HTTP endpoint.      Note  The  func  can pass  nil  or  table  back as a return argument which will determine the HTTP response code returned.   Example  local   function   my_func ( context ,   payload ) \n   -- let s return the  context  as JSON back in the HTTP response body \n   return   context  end  nk . register_http ( my_func ,   /my_endpoint )  --  my_func  will be registered at  POST /runtime/my_endpoint   You can send a request to the HTTP endpoint with JSON and responses will be returned in JSON.  curl -X POST http://127.0.0.1:7350/runtime/my_endpoint?key = defaultkey  \\ \n     -d  { some :  data }   \\ \n     -H  Content-Type: application/json   \\ \n     -H  Accept: application/json    register_rpc (func, id)  Registers a function for use with client RPC to the server.  The ID can be any string identifier and is sent by the client. The ID is used to map the client RPC message to the specific function to execute. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each RPC message.    id  string  The unique identifier used to register the  func  function for RPC.      Note  The  func  can pass  nil  or  string  back as a return argument which will returned as bytes in the RPC response.   Example  local   function   my_func ( context ,   payload ) \n   -- run some code  end  nk . register_rpc ( my_func ,   my_func_id )", 
            "title": "register hooks"
        }, 
        {
            "location": "/runtime-function-reference/#storage", 
            "text": "storage_fetch (record_keys)  Fetch one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      record_keys  table  A table array of record identifiers to be fetched.     Returns  A table array of the records result set.  Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   record_keys   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id }  }  local   records   =   nk . storage_fetch ( record_keys )  for   _ ,   r   in   ipairs ( records )  do \n   local   message   =   ( read: %q, write: %q, value: %q ): format ( r . PermissionRead ,   r . PermissionWrite ,   r . Value ) \n   print ( message )  end    storage_remove (record_keys)  Remove one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      record_keys  table  A table array of record identifiers to be removed.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   record_keys   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id }  }  nk . storage_remove ( record_keys )    storage_update (record_keys)  Update one or more records by their bucket/collection/keyname and optional user. Have a look at the section on  storage collections .  Parameters     Param  Type  Description      record_keys  table  A table array of records to update.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   now   =   os.time ()   *   1000   -- current time converted for msec  local   update_ops   =   { \n   { Op   =   init ,   Path   =   / ,   Value   =   {   progress   =   1   }}, \n   { Op   =   incr ,   Path   =   /progress ,   Value   =   1 }, \n   { Op   =   replace ,   Path   =   /updated_at ,   Value   =   now }  }  local   record_keys   =   { \n   { Bucket   =   b ,   Collection   =   c ,   Record   =   r ,   UserId   =   user_id ,   UpdateOps   =   update_ops }  }  nk . storage_update ( record_keys )    storage_write (new_records)  Write one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      new_records  table  A table array of new records to write.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   new_records   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id ,   Value   =   {}}, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id ,   Value   =   {}}, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id ,   Value   =   {}}  }  nk . storage_write ( new_records )", 
            "title": "storage"
        }, 
        {
            "location": "/runtime-function-reference/#users", 
            "text": "users_ban (user_ids)  Ban one or more users from the server.  Parameters     Param  Type  Description      user_ids  table  A table array of user IDs to be banned.     Example  local   user_ids   =   { 4c2ae592-b2a7-445e-98ec-697694478b1c }  local   status ,   result   =   pcall ( nk . users_ban ,   user_ids )  if   ( not   status )   then \n   print ( result )  end    users_fetch_handle (user_handles)  Fetch a set of users by handle.  Parameters     Param  Type  Description      user_handles  table  A table array of user handles to fetch.     Returns  A table array of the user result set.  Example  local   user_handles   =   { b7865e7e ,   c048ba7a }  local   users   =   nk . users_fetch_handle ( user_handles )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( id: %q, fullname: %q ): format ( u . Id ,   u . Fullname ) \n   print ( message )  end    users_fetch_id (user_ids)  Fetch one or more users by ID.  Parameters     Param  Type  Description      user_ids  table  A table array of user IDs to fetch.     Returns  A table array of the user result set.  Example  local   user_ids   =   { \n   3ea5608a-43c3-11e7-90f9-7b9397165f34 , \n   447524be-43c3-11e7-af09-3f7172f05936  }  local   users   =   nk . user_fetch_id ( user_ids )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( handle: %q, fullname: %q ): format ( u . Handle ,   u . Fullname ) \n   print ( message )  end    users_update (user_updates)  Update one or more users.  Parameters     Param  Type  Description      user_updates  table  The table array of users to update.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   user_updates   =   { \n   {   UserId   =   user_id ,   Metadata   =   {}   }  }  local   status ,   err   =   pcall ( nk . users_update ,   user_updates )  if   ( not   status )   then \n   print (( User update error: %q ): format ( err ))  end", 
            "title": "users"
        }, 
        {
            "location": "/runtime-function-reference/#uuid", 
            "text": "uuid_v4 ()  Generate a version 4 UUID.  Returns  The generated version 4 UUID identifier.  Example  local   uuid   =   nk . uuid_v4 ()  print ( uuid )", 
            "title": "uuid"
        }, 
        {
            "location": "/tutorials/initialize-new-user/", 
            "text": "Initialize a new user\n\n\nIt's often useful when a new user registers to have a bunch of records setup for them. In games this could be needed for a user's virtual wallet, initial inventory items, etc. In this tutorial we'll cover a few different ways to handle this use case.\n\n\n\n\nSummary\n\n\nWhile there are various ways to solve this use case we highly recommend you \ninitialize the records on usage\n.\n\n\n\n\nAfter register callback\n\n\nThe simplest approach is to write records in the success callback for the register function in a client.\n\n\nThis code demonstrates how to do it with a condensed example. In real application code you'll break up the \nauthentication\n and connect logic from the storage writes based on how you manage connect and reconnect.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nvar\n \nid\n \n=\n \nSystemInfo\n.\ndeviceUniqueIdentifier\n;\n\n\n// Use one of the user register messages.\n\n\nvar\n \nauthMessage\n \n=\n \nNAuthenticateMessage\n.\nDevice\n(\nid\n);\n\n\nclient\n.\nRegister\n(\nauthMessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nclient\n.\nConnect\n(\nsession\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n    \nvar\n \njsonString\n \n=\n \n{\ncoins\n: 100, \ngems\n: 10, \nartifacts\n: 0}\n;\n\n    \nbyte\n[]\n \njson\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njsonString\n);\n\n\n    \nvar\n \nmessage\n \n=\n \nnew\n \nNStorageWriteMessage\n.\nBuilder\n()\n\n        \n.\nWrite\n(\nmygame\n,\n \nwallets\n,\n \nmywallet\n,\n \njson\n)\n\n        \n.\nBuild\n();\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINStorageKey\n \nlist\n)\n \n=\n \n{\n\n      \nDebug\n.\nLog\n(\nSuccessfully setup new user\ns records.\n);\n\n    \n},\n \nerrorHandler\n);\n\n  \n});\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nThis code has tradeoffs which should be noted. A disconnect can happen before the records are written to storage. This may leave the setup of the user incomplete and the application in a bad state.\n\n\nThis option is only worth choosing when you want to avoid writing server-side code or have built retry logic on top of a client.\n\n\nServer-side hook\n\n\nAnother way to write records for the new user is to run server-side code after registration has completed. This can be done with a \nregister hook\n.\n\n\nThe \n\"register_after\"\n hook can be used with one of the \n\"authenticaterequest_*\"\n message types to tell the server to run a function after that message has been processed. It's important to note that the server does not distinguish between register and login messages so we use a \nconditional write\n to store the records.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \ninitialize_user\n(\ncontext\n,\n \n_payload\n)\n\n  \nlocal\n \nvalue\n \n=\n \n{\n\n    \ncoins\n \n=\n \n100\n,\n\n    \ngems\n \n=\n \n10\n,\n\n    \nartifacts\n \n=\n \n0\n\n  \n}\n\n  \nlocal\n \nrecord\n \n=\n \n{\n\n    \nBucket\n \n=\n \nmygame\n,\n\n    \nCollection\n \n=\n \nwallets\n,\n\n    \nRecord\n \n=\n \nmywallet\n,\n\n    \nUserId\n \n=\n \ncontext\n.\nUserId\n,\n\n    \nValue\n \n=\n \nvalue\n,\n\n    \nVersion\n \n=\n \n*\n   \n-- only write record if one doesn\nt already exist.\n\n  \n}\n\n  \npcall\n(\nnk\n.\nstorage_write\n,\n \n{\n \nrecord\n \n})\n \n-- write record, ignore errors.\n\n\nend\n\n\n\n-- change to whatever message name matches your authentication type.\n\n\nnk\n.\nregister_after\n(\ninitialize_user\n,\n \nauthenticaterequest_device\n)\n\n\n\n\n\n\nThis approach avoids the tradeoff with client disconnects but requires a database write to happen after every login or register message. This could be acceptable depending on how frequently you write data to the storage engine and can be minimized if you \ncache a user's session\n for quick reconnects.\n\n\nInitialize record when used\n\n\nThe last way to write initial records for the user is to \n\"init\"\n the record with a storage update wherever it's written to in other application code. With this approach you never use storage writes and always perform all write operations as updates.\n\n\nIn our example it means wherever you will update the \"mywallet\" record you ensure it's been initialized first.\n\n\nvar\n \njsonString\n \n=\n \n{\ncoins\n: 100, \ngems\n: 10, \nartifacts\n: 0}\n;\n\n\nbyte\n[]\n \njson\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njsonString\n);\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNStorageUpdateMessage\n.\nBuilder\n()\n\n    \n.\nUpdate\n(\nmygame\n,\n \nwallets\n,\n \nmywallet\n,\n \nnew\n \nStorageUpdateBuilder\n()\n\n        \n.\nInit\n(\n/\n,\n \njson\n)\n     \n// make sure record is setup.\n\n        \n.\nIncr\n(\n/coins\n,\n \n-\n10\n)\n \n// perform other updates to the record.\n\n        \n.\nBuild\n())\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINStorageKey\n \nlist\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nUpdated user\ns storage records.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can also perform the \"initialize before update\" with server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nvalue\n \n=\n \n{\n\n  \ncoins\n \n=\n \n100\n,\n\n  \ngems\n \n=\n \n10\n,\n\n  \nartifacts\n \n=\n \n0\n\n\n}\n\n\nlocal\n \nupdate_ops\n \n=\n \n{\n\n  \n{\n \nOp\n \n=\n \ninit\n,\n \nPath\n \n=\n \n/\n,\n \nValue\n \n=\n \nvalue\n \n},\n \n-- make sure record is setup.\n\n\n  \n-- perform other updates to the record.\n\n  \n{\n \nOp\n \n=\n \nincr\n,\n \nPath\n \n=\n \n/coins\n,\n \nValue\n \n=\n \n-\n10\n \n}\n\n\n}\n\n\nlocal\n \nrecord\n \n=\n \n{\n\n  \nBucket\n \n=\n \nmygame\n,\n\n  \nCollection\n \n=\n \nwallets\n,\n\n  \nRecord\n \n=\n \nmywallet\n,\n\n  \nUserId\n \n=\n \ncontext\n.\nUserId\n,\n\n  \nUpdate\n \n=\n \nupdate_ops\n\n\n}\n\n\nnk\n.\nstorage_update\n({\n \nrecord\n \n})\n\n\n\n\n\n\nThis is our recommended approach. It has no tradeoffs compared with the other approaches except that you must remember to add \n\"init\"\n logic wherever the record would be updated.", 
            "title": "Initialize a new user"
        }, 
        {
            "location": "/tutorials/initialize-new-user/#initialize-a-new-user", 
            "text": "It's often useful when a new user registers to have a bunch of records setup for them. In games this could be needed for a user's virtual wallet, initial inventory items, etc. In this tutorial we'll cover a few different ways to handle this use case.   Summary  While there are various ways to solve this use case we highly recommend you  initialize the records on usage .", 
            "title": "Initialize a new user"
        }, 
        {
            "location": "/tutorials/initialize-new-user/#after-register-callback", 
            "text": "The simplest approach is to write records in the success callback for the register function in a client.  This code demonstrates how to do it with a condensed example. In real application code you'll break up the  authentication  and connect logic from the storage writes based on how you manage connect and reconnect.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  var   id   =   SystemInfo . deviceUniqueIdentifier ;  // Use one of the user register messages.  var   authMessage   =   NAuthenticateMessage . Device ( id );  client . Register ( authMessage ,   ( INSession   session )   =   { \n   client . Connect ( session ,   ( bool   done )   =   { \n     var   jsonString   =   { coins : 100,  gems : 10,  artifacts : 0} ; \n     byte []   json   =   Encoding . UTF8 . GetBytes ( jsonString ); \n\n     var   message   =   new   NStorageWriteMessage . Builder () \n         . Write ( mygame ,   wallets ,   mywallet ,   json ) \n         . Build (); \n     client . Send ( message ,   ( INResultSet INStorageKey   list )   =   { \n       Debug . Log ( Successfully setup new user s records. ); \n     },   errorHandler ); \n   });  },   errorHandler );   This code has tradeoffs which should be noted. A disconnect can happen before the records are written to storage. This may leave the setup of the user incomplete and the application in a bad state.  This option is only worth choosing when you want to avoid writing server-side code or have built retry logic on top of a client.", 
            "title": "After register callback"
        }, 
        {
            "location": "/tutorials/initialize-new-user/#server-side-hook", 
            "text": "Another way to write records for the new user is to run server-side code after registration has completed. This can be done with a  register hook .  The  \"register_after\"  hook can be used with one of the  \"authenticaterequest_*\"  message types to tell the server to run a function after that message has been processed. It's important to note that the server does not distinguish between register and login messages so we use a  conditional write  to store the records.  local   nk   =   require ( nakama )  local   function   initialize_user ( context ,   _payload ) \n   local   value   =   { \n     coins   =   100 , \n     gems   =   10 , \n     artifacts   =   0 \n   } \n   local   record   =   { \n     Bucket   =   mygame , \n     Collection   =   wallets , \n     Record   =   mywallet , \n     UserId   =   context . UserId , \n     Value   =   value , \n     Version   =   *     -- only write record if one doesn t already exist. \n   } \n   pcall ( nk . storage_write ,   {   record   })   -- write record, ignore errors.  end  -- change to whatever message name matches your authentication type.  nk . register_after ( initialize_user ,   authenticaterequest_device )   This approach avoids the tradeoff with client disconnects but requires a database write to happen after every login or register message. This could be acceptable depending on how frequently you write data to the storage engine and can be minimized if you  cache a user's session  for quick reconnects.", 
            "title": "Server-side hook"
        }, 
        {
            "location": "/tutorials/initialize-new-user/#initialize-record-when-used", 
            "text": "The last way to write initial records for the user is to  \"init\"  the record with a storage update wherever it's written to in other application code. With this approach you never use storage writes and always perform all write operations as updates.  In our example it means wherever you will update the \"mywallet\" record you ensure it's been initialized first.  var   jsonString   =   { coins : 100,  gems : 10,  artifacts : 0} ;  byte []   json   =   Encoding . UTF8 . GetBytes ( jsonString );  var   message   =   new   NStorageUpdateMessage . Builder () \n     . Update ( mygame ,   wallets ,   mywallet ,   new   StorageUpdateBuilder () \n         . Init ( / ,   json )       // make sure record is setup. \n         . Incr ( /coins ,   - 10 )   // perform other updates to the record. \n         . Build ()) \n     . Build ();  client . Send ( message ,   ( INResultSet INStorageKey   list )   =   { \n   Debug . Log ( Updated user s storage records. );  },   ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can also perform the \"initialize before update\" with server-side code.  local   nk   =   require ( nakama )  local   value   =   { \n   coins   =   100 , \n   gems   =   10 , \n   artifacts   =   0  }  local   update_ops   =   { \n   {   Op   =   init ,   Path   =   / ,   Value   =   value   },   -- make sure record is setup. \n\n   -- perform other updates to the record. \n   {   Op   =   incr ,   Path   =   /coins ,   Value   =   - 10   }  }  local   record   =   { \n   Bucket   =   mygame , \n   Collection   =   wallets , \n   Record   =   mywallet , \n   UserId   =   context . UserId , \n   Update   =   update_ops  }  nk . storage_update ({   record   })   This is our recommended approach. It has no tradeoffs compared with the other approaches except that you must remember to add  \"init\"  logic wherever the record would be updated.", 
            "title": "Initialize record when used"
        }, 
        {
            "location": "/tutorials/remote-configuration/", 
            "text": "Remote configuration\n\n\nRemote configuration is a way to customize the behavior of an app or game via in-app parameters stored on a remote server. This can be used to implement \nfeature flags\n or adjust settings which change the appearance or behavior of the app or game.\n\n\nDevelopers can use remote configuration to remove the hassle of a lengthy review process or modifying the game or app and then waiting for users to update. This makes it especially useful with mobile projects.\n\n\nManage In-app parameters\n\n\nThe configuration settings sent to the app or game need to be stored on the server. The best way to store the information depends on how often the data will be changed.\n\n\nFor mostly static data it's most efficient to embed it as data structures in server-side code and for more dynamic data it's better to use a read-only \nstorage record\n.\n\n\nWith both of these approaches you can access remote configuration before you've done \nregister/login\n or connected with a \nuser session\n. The in-app parameters you configure can be initialized at the earliest point of application startup.\n\n\nStatic parameters\n\n\nThe simplest approach uses server-side code to represent the in-app parameters as a static variable. A change to the parameters after the server has started would require an update to the Lua code and a server restart.\n\n\nThe code could be stored in a module named \n\"rc.lua\"\n and placed in the runtime path for the server.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n-- In-app parameters stored in a static variable.\n\n\nlocal\n \nparameters\n \n=\n \n{\n\n  \nreachable_levels\n \n=\n \n10\n,\n\n  \nmax_player_level\n \n=\n \n90\n,\n\n  \nmin_version\n \n=\n \n12\n\n\n}\n\n\n\nlocal\n \nfunction\n \nremote_configuration\n(\n_context\n,\n \n_payload\n)\n\n  \nreturn\n \n{\n \nrc\n \n=\n \nparameters\n \n}\n\n\nend\n\n\n\nnk\n.\nregister_http\n(\nremote_configuration\n,\n \nrc\n)\n\n\n\n\n\n\nDynamic parameters\n\n\nFor in-app parameters which may be changed via Analytics or with a Liveops dashboard it's more flexible to store the configuration settings in the \nstorage engine\n as a read-only record.\n\n\nSame as above we'll use server-side code with a module named \n\"rc.lua\"\n and placed in the runtime path for the server.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nparameters\n \n=\n \n{\n\n  \nreachable_levels\n \n=\n \n10\n,\n\n  \nmax_player_level\n \n=\n \n90\n,\n\n  \nmin_version\n \n=\n \n12\n\n\n}\n\n\n\nlocal\n \nrecord\n \n=\n \n{\n\n  \nBucket\n \n=\n \napp\n,\n\n  \nCollection\n \n=\n \nconfiguration\n,\n\n  \nRecord\n \n=\n \nrc\n,\n\n  \nUserId\n \n=\n \nnil\n,\n\n  \nValue\n \n=\n \nparameters\n,\n\n  \nPermissionRead\n \n=\n \n1\n,\n\n  \nPermissionWrite\n \n=\n \n0\n,\n\n  \nVersion\n \n=\n \n*\n       \n-- only write record if it does not already exist.\n\n\n}\n\n\npcall\n(\nnk\n.\nstorage_write\n,\n \n{\n \nrecord\n \n})\n \n-- write record, ignore errors.\n\n\n\nlocal\n \nfunction\n \nremote_configuration\n(\n_context\n,\n \n_payload\n)\n\n  \nlocal\n \nrc\n \n=\n \n{\n\n    \nBucket\n \n=\n \nrecord\n.\nBucket\n,\n\n    \nCollection\n \n=\n \nrecord\n.\nCollection\n,\n\n    \nRecord\n \n=\n \nrecord\n.\nRecord\n,\n\n    \nUserId\n \n=\n \nnil\n\n  \n}\n\n  \nlocal\n \nrecords\n \n=\n \nnk\n.\nstorage_fetch\n({\n \nrc\n \n})\n\n  \nreturn\n \nrecords\n[\n1\n].\nValue\n\n\nend\n\n\n\nnk\n.\nregister_http\n(\nremote_configuration\n,\n \nrc\n)\n\n\n\n\n\n\nFetch In-app parameters\n\n\nWith either approach used to store in-app parameters you can fetch the configuration with a HTTP request.\n\n\n\n\nTip\n\n\nRemember to change the host, port, and auth values for how you've setup your server.\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nUnity\n\n        \n\n    \n        \n\n            \ncURL\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nvar\n \nhost\n \n=\n \n127.0.0.1\n;\n\n\nvar\n \nport\n \n=\n \n7350\n;\n\n\nvar\n \npath\n \n=\n \nrc\n;\n\n\nvar\n \nauth\n \n=\n \ndefaultkey\n;\n\n\n\nvar\n \nformat\n \n=\n \nhttp://{0}:{1}/runtime/{2}?key={3}\n;\n\n\nvar\n \nurl\n \n=\n \nstring\n.\nFormat\n(\nformat\n,\n \nHost\n,\n \nPort\n,\n \nPath\n,\n \nAuth\n);\n\n\nvar\n \nheaders\n \n=\n \nnew\n \nDictionary\nstring\n,\n \nstring\n();\n\n\nheaders\n.\nAdd\n(\nContent-Type\n,\n \napplication/json\n);\n\n\nheaders\n.\nAdd\n(\nAccept\n,\n \napplication/json\n);\n\n\nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{}\n);\n\n\n\nWWW\n \nwww\n \n=\n \nnew\n \nWWW\n(\nurl\n,\n \ncontent\n,\n \nheaders\n);\n\n\nyield\n \nreturn\n \nwww\n;\n\n\nif\n \n(!\nstring\n.\nIsNullOrEmpty\n(\nwww\n.\nerror\n))\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError occurred: {0}\n,\n \nwww\n.\nerror\n);\n\n\n}\n \nelse\n \n{\n\n    \nvar\n \nresponse\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nwww\n.\nbytes\n);\n\n    \nDebug\n.\nLog\n(\nresponse\n);\n\n    \n// output\n\n    \n// {\nrc\n:{\nmax_player_level\n:90,\nmin_version\n:12,\nreachable_levels\n:10}}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \ncurl -X POST http://127.0.0.1:7350/runtime/rc?key\n=\ndefaultkey \n\\\n\n     -d \n{}\n \n\\\n\n     -H \nContent-Type: application/json\n \n\\\n\n     -H \nAccept: application/json\n\n\n# output\n\n\n# {\nrc\n:{\nmax_player_level\n:90,\nmin_version\n:12,\nreachable_levels\n:10}}", 
            "title": "Remote configuration"
        }, 
        {
            "location": "/tutorials/remote-configuration/#remote-configuration", 
            "text": "Remote configuration is a way to customize the behavior of an app or game via in-app parameters stored on a remote server. This can be used to implement  feature flags  or adjust settings which change the appearance or behavior of the app or game.  Developers can use remote configuration to remove the hassle of a lengthy review process or modifying the game or app and then waiting for users to update. This makes it especially useful with mobile projects.", 
            "title": "Remote configuration"
        }, 
        {
            "location": "/tutorials/remote-configuration/#manage-in-app-parameters", 
            "text": "The configuration settings sent to the app or game need to be stored on the server. The best way to store the information depends on how often the data will be changed.  For mostly static data it's most efficient to embed it as data structures in server-side code and for more dynamic data it's better to use a read-only  storage record .  With both of these approaches you can access remote configuration before you've done  register/login  or connected with a  user session . The in-app parameters you configure can be initialized at the earliest point of application startup.", 
            "title": "Manage In-app parameters"
        }, 
        {
            "location": "/tutorials/remote-configuration/#static-parameters", 
            "text": "The simplest approach uses server-side code to represent the in-app parameters as a static variable. A change to the parameters after the server has started would require an update to the Lua code and a server restart.  The code could be stored in a module named  \"rc.lua\"  and placed in the runtime path for the server.  local   nk   =   require ( nakama )  -- In-app parameters stored in a static variable.  local   parameters   =   { \n   reachable_levels   =   10 , \n   max_player_level   =   90 , \n   min_version   =   12  }  local   function   remote_configuration ( _context ,   _payload ) \n   return   {   rc   =   parameters   }  end  nk . register_http ( remote_configuration ,   rc )", 
            "title": "Static parameters"
        }, 
        {
            "location": "/tutorials/remote-configuration/#dynamic-parameters", 
            "text": "For in-app parameters which may be changed via Analytics or with a Liveops dashboard it's more flexible to store the configuration settings in the  storage engine  as a read-only record.  Same as above we'll use server-side code with a module named  \"rc.lua\"  and placed in the runtime path for the server.  local   nk   =   require ( nakama )  local   parameters   =   { \n   reachable_levels   =   10 , \n   max_player_level   =   90 , \n   min_version   =   12  }  local   record   =   { \n   Bucket   =   app , \n   Collection   =   configuration , \n   Record   =   rc , \n   UserId   =   nil , \n   Value   =   parameters , \n   PermissionRead   =   1 , \n   PermissionWrite   =   0 , \n   Version   =   *         -- only write record if it does not already exist.  }  pcall ( nk . storage_write ,   {   record   })   -- write record, ignore errors.  local   function   remote_configuration ( _context ,   _payload ) \n   local   rc   =   { \n     Bucket   =   record . Bucket , \n     Collection   =   record . Collection , \n     Record   =   record . Record , \n     UserId   =   nil \n   } \n   local   records   =   nk . storage_fetch ({   rc   }) \n   return   records [ 1 ]. Value  end  nk . register_http ( remote_configuration ,   rc )", 
            "title": "Dynamic parameters"
        }, 
        {
            "location": "/tutorials/remote-configuration/#fetch-in-app-parameters", 
            "text": "With either approach used to store in-app parameters you can fetch the configuration with a HTTP request.   Tip  Remember to change the host, port, and auth values for how you've setup your server.   \n                 \n                    \n         \n            \n         \n             Unity \n         \n    \n         \n             cURL \n         \n    \n         \n    \n         \n            \n         \n             var   host   =   127.0.0.1 ;  var   port   =   7350 ;  var   path   =   rc ;  var   auth   =   defaultkey ;  var   format   =   http://{0}:{1}/runtime/{2}?key={3} ;  var   url   =   string . Format ( format ,   Host ,   Port ,   Path ,   Auth );  var   headers   =   new   Dictionary string ,   string ();  headers . Add ( Content-Type ,   application/json );  headers . Add ( Accept ,   application/json );  var   content   =   Encoding . UTF8 . GetBytes ( {} );  WWW   www   =   new   WWW ( url ,   content ,   headers );  yield   return   www ;  if   (! string . IsNullOrEmpty ( www . error ))   { \n     Debug . LogErrorFormat ( Error occurred: {0} ,   www . error );  }   else   { \n     var   response   =   Encoding . UTF8 . GetString ( www . bytes ); \n     Debug . Log ( response ); \n     // output \n     // { rc :{ max_player_level :90, min_version :12, reachable_levels :10}}  }  \n\n         \n    \n         \n             curl -X POST http://127.0.0.1:7350/runtime/rc?key = defaultkey  \\ \n     -d  {}   \\ \n     -H  Content-Type: application/json   \\ \n     -H  Accept: application/json  # output  # { rc :{ max_player_level :90, min_version :12, reachable_levels :10}}", 
            "title": "Fetch In-app parameters"
        }
    ]
}