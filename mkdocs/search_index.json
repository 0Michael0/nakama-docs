{
    "docs": [
        {
            "location": "/in-app-notifications/", 
            "text": "In-app Notifications\n\n\nIn-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts. A notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.\n\n\nThese notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.\n\n\nSend notifications\n\n\nYou can send a notification to one or more users via the Lua runtime. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.\n\n\nNotifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_ids\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n,\n \netc\n}\n\n\nlocal\n \nsender_id\n \n=\n \nnil\n \n-- \nnil\n for server sent.\n\n\nlocal\n \nsubject\n \n=\n \nYou earned a secret item!\n\n\nlocal\n \ncontent\n \n=\n \n{\n\n  \nitem_id\n \n=\n \n192308394345345\n,\n\n  \nitem_icon\n \n=\n \nstorm_bringer_sword.png\n\n\n}\n\n\nlocal\n \ncode\n \n=\n \n101\n\n\nlocal\n \nexpires_at\n \n=\n \n1000\n \n*\n \n60\n \n*\n \n60\n \n*\n \n24\n \n*\n \n7\n \n-- expires in 7 days.\n\n\nlocal\n \npersistent\n \n=\n \ntrue\n\n\n\nnk\n.\nsend_notification_id\n(\nuser_ids\n,\n \nsender_id\n,\n \nsubject\n,\n \ncontent\n,\n\n                        \ncode\n,\n \nexpires_at\n,\n \npersistent\n)\n\n\n\n\n\n\nA notification must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.\n\n\n\n\nNote\n\n\nThe code you choose for your notifications must start at \"101\" and upwards. See \nbelow\n for reserved message codes.\n\n\n\n\nReceive notifications\n\n\nAn event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.\n\n\nclient\n.\nOnNotificationReceived\n \n+=\n \n(\nobject\n \nsender\n,\n \nNNotificationEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINNotification\n \nn\n \n=\n \nargs\n.\nNotification\n;\n\n  \nDebug\n.\nLogFormat\n(\nReceived code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nn\n.\nContent\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nReceived id \n{0}\n and content \n{1}\n.\n,\n \nn\n.\nId\n,\n \ncontent\n);\n\n\n};\n\n\n\n\n\n\nList notifications\n\n\nYou can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINNotificationList\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nn\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nNotice code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.\n\n\n\n\nHint\n\n\nYou usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.\n\n\n\n\nIList\nINNotification\n \nallNotifications\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\n\nAction\n \naccumulateNotifications\n \n=\n \ndelegate\n(\nINCursor\n \nresumeCursor\n)\n \n{\n\n  \nvar\n \nmessage\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n      \n.\nCursor\n(\nresumeCursor\n)\n\n      \n.\nBuild\n();\n\n  \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINNotificationList\n \nlist\n)\n \n=\n \n{\n\n    \nif\n \n(\nlist\n.\nResults\n.\nLength\n \n \n1\n)\n \n{\n\n      \nreturn\n;\n\n    \n}\n \nelse\n \n{\n\n      \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n      \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n \n// recursive async call.\n\n    \n}\n\n  \n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n});\n\n\n};\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINNotificationList\n \nlist\n)\n \n=\n \n{\n\n  \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n  \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nIt can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned which each list message.\n\n\nThe resume cursor marks the position of the most recent notification retrieved as part of the list. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.\n\n\nINCursor\n \nresumeCursor\n \n=\n \n...;\n \n// stored from last list retrieval.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n    \n.\nCursor\n(\nresumeCursor\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINNotificationList\n \nlist\n)\n \n=\n \n{\n\n  \n// use notification list.\n\n  \nresumeCursor\n \n=\n \nlist\n.\nCursor\n;\n \n// cache resume cursor.\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nDelete notifications\n\n\nYou can delete one or more notifications from the client. This is useful to purge notifications which has been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.\n\n\nIList\nINNotification\n \nlist\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\nlist\n.\nAdd\n(...);\n \n// Add notification from your internal list\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationRemove\n.\nDefault\n(\nlist\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nNotifications were removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nNotification codes\n\n\nThe server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.\n\n\n\n\n\n\n\n\nCode\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n001\n\n\nUser X wants to chat.\n\n\n\n\n\n\n002\n\n\nUser X wants to add you as a friend.\n\n\n\n\n\n\n003\n\n\nUser X accepted your friend invite.\n\n\n\n\n\n\n004\n\n\nYou've been accepted to X group.\n\n\n\n\n\n\n005\n\n\nUser X wants to join your group.\n\n\n\n\n\n\n006\n\n\nYour friend X has just joined the game.", 
            "title": "In-app notifications"
        }, 
        {
            "location": "/in-app-notifications/#in-app-notifications", 
            "text": "In-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts. A notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.  These notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/in-app-notifications/#send-notifications", 
            "text": "You can send a notification to one or more users via the Lua runtime. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.  Notifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.  local   nk   =   require ( nakama )  local   user_ids   =   { someuserid ,   anotheruserid ,   etc }  local   sender_id   =   nil   --  nil  for server sent.  local   subject   =   You earned a secret item!  local   content   =   { \n   item_id   =   192308394345345 , \n   item_icon   =   storm_bringer_sword.png  }  local   code   =   101  local   expires_at   =   1000   *   60   *   60   *   24   *   7   -- expires in 7 days.  local   persistent   =   true  nk . send_notification_id ( user_ids ,   sender_id ,   subject ,   content , \n                         code ,   expires_at ,   persistent )   A notification must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.   Note  The code you choose for your notifications must start at \"101\" and upwards. See  below  for reserved message codes.", 
            "title": "Send notifications"
        }, 
        {
            "location": "/in-app-notifications/#receive-notifications", 
            "text": "An event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.  client . OnNotificationReceived   +=   ( object   sender ,   NNotificationEventArgs   args )   =   { \n   INNotification   n   =   args . Notification ; \n   Debug . LogFormat ( Received code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   var   content   =   Encoding . UTF8 . GetString ( n . Content );   // convert byte[]. \n   Debug . LogFormat ( Received id  {0}  and content  {1} . ,   n . Id ,   content );  };", 
            "title": "Receive notifications"
        }, 
        {
            "location": "/in-app-notifications/#list-notifications", 
            "text": "You can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.  var   message   =   new   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INNotificationList   list )   =   { \n   foreach   ( var   n   in   list . Results )   { \n     Debug . LogFormat ( Notice code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.   Hint  You usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.   IList INNotification   allNotifications   =   new   List INNotification ();  Action   accumulateNotifications   =   delegate ( INCursor   resumeCursor )   { \n   var   message   new   NNotificationsListMessage . Builder ( 100 ) \n       . Cursor ( resumeCursor ) \n       . Build (); \n   client . Send ( message ,   ( INNotificationList   list )   =   { \n     if   ( list . Results . Length     1 )   { \n       return ; \n     }   else   { \n       allNotifications . AddRange ( list . Results ); \n       accumulateNotifications ( list . Cursor );   // recursive async call. \n     } \n   },   ( INError   err )   =   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   });  };  var   message   =   new   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INNotificationList   list )   =   { \n   allNotifications . AddRange ( list . Results ); \n   accumulateNotifications ( list . Cursor );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   It can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned which each list message.  The resume cursor marks the position of the most recent notification retrieved as part of the list. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.  INCursor   resumeCursor   =   ...;   // stored from last list retrieval.  var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n     . Cursor ( resumeCursor ) \n     . Build ();  client . Send ( message ,   ( INNotificationList   list )   =   { \n   // use notification list. \n   resumeCursor   =   list . Cursor ;   // cache resume cursor.  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List notifications"
        }, 
        {
            "location": "/in-app-notifications/#delete-notifications", 
            "text": "You can delete one or more notifications from the client. This is useful to purge notifications which has been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.  IList INNotification   list   =   new   List INNotification ();  list . Add (...);   // Add notification from your internal list  var   message   =   new   NNotificationRemove . Default ( list );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Notifications were removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Delete notifications"
        }, 
        {
            "location": "/in-app-notifications/#notification-codes", 
            "text": "The server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.     Code  Purpose      001  User X wants to chat.    002  User X wants to add you as a friend.    003  User X accepted your friend invite.    004  You've been accepted to X group.    005  User X wants to join your group.    006  Your friend X has just joined the game.", 
            "title": "Notification codes"
        }
    ]
}