{
    "docs": [
        {
            "location": "/friends/", 
            "text": "Friends\n\n\nFriends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.\n\n\nEach user builds up a list of friends by who they know already from the social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.\n\n\n\n\nFun fact\n\n\nNakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!\n\n\n\n\nAny social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.\n\n\nAdd friends\n\n\nA user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.\n\n\n\n\nHint\n\n\nA user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.\n\n\n\n\nWhen a friend request is sent or the user is added an in-app notification will be sent. See the \nin-app notification\n section for more info.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendAddMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nFriend added or request sent.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nWhen both users have added eachother as friends they are able to initiate realtime chat in a 1-on-1 channel. See the \nrealtime chat\n section for more info.\n\n\nList friends\n\n\nYou can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.\n\n\nvar\n \nmessage\n \n=\n \nNFriendsListMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINFriend\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nf\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nf\n.\nId\n);\n \n// convert byte[].\n\n    \n// f.State is one of: Friend, Invite, Invited, Blocked.\n\n    \nDebug\n.\nLogFormat\n(\nUser {0} has state {1}.\n,\n \nid\n,\n \nf\n.\nState\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nRemove friends\n\n\nA user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.\n\n\n\n\nNote\n\n\nIf a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.\n\n\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendRemoveMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nuserId\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been removed.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBlock a friend\n\n\nYou can stop a user from 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a \nFriend Remove\n message.\n\n\nA user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendBlockMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nid\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been blocked.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBan a user\n\n\nA user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.\n\n\nThis is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team. See the \nruntime code\n section on how to write server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n-- you can use both IDs and handles to ban.\n\n\nlocal\n \nbad_users\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n,\n \nuserhandle\n}\n\n\nlocal\n \nsuccess\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nbad_users\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nBan failed: %q\n):\nformat\n(\nerr\n))\n\n\nend", 
            "title": "Friends"
        }, 
        {
            "location": "/friends/#friends", 
            "text": "Friends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.  Each user builds up a list of friends by who they know already from the social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.   Fun fact  Nakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!   Any social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.", 
            "title": "Friends"
        }, 
        {
            "location": "/friends/#add-friends", 
            "text": "A user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.   Hint  A user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.   When a friend request is sent or the user is added an in-app notification will be sent. See the  in-app notification  section for more info.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendAddMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Friend added or request sent. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   When both users have added eachother as friends they are able to initiate realtime chat in a 1-on-1 channel. See the  realtime chat  section for more info.", 
            "title": "Add friends"
        }, 
        {
            "location": "/friends/#list-friends", 
            "text": "You can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.  var   message   =   NFriendsListMessage . Default ();  client . Send ( message ,   ( INResultSet INFriend   list )   =   { \n   foreach   ( var   f   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( f . Id );   // convert byte[]. \n     // f.State is one of: Friend, Invite, Invited, Blocked. \n     Debug . LogFormat ( User {0} has state {1}. ,   id ,   f . State ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List friends"
        }, 
        {
            "location": "/friends/#remove-friends", 
            "text": "A user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.   Note  If a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.   byte []   userId   =   ...;   // some user ID  var   message   =   NFriendRemoveMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( userId );   // convert byte[]. \n   Debug . Log ( User {0} has been removed. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Remove friends"
        }, 
        {
            "location": "/friends/#block-a-friend", 
            "text": "You can stop a user from 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a  Friend Remove  message.  A user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendBlockMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( id );   // convert byte[]. \n   Debug . Log ( User {0} has been blocked. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Block a friend"
        }, 
        {
            "location": "/friends/#ban-a-user", 
            "text": "A user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.  This is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team. See the  runtime code  section on how to write server-side code.  local   nk   =   require ( nakama )  -- you can use both IDs and handles to ban.  local   bad_users   =   { someuserid ,   anotheruserid ,   userhandle }  local   success ,   err   =   pcall ( nk . users_ban ,   bad_users )  if   ( not   success )   then \n   nk . logger_error (( Ban failed: %q ): format ( err ))  end", 
            "title": "Ban a user"
        }, 
        {
            "location": "/in-app-notifications/", 
            "text": "In-app Notifications\n\n\nIn-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.\n\n\nA notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.\n\n\nThese notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.\n\n\nSend notifications\n\n\nYou can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.\n\n\n\n\nNote\n\n\nThe code you choose for your notifications must start at \"101\" and upwards. See \nbelow\n for reserved message codes.\n\n\n\n\nA notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.\n\n\nNotifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_ids\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n,\n \netc\n}\n\n\nlocal\n \nsender_id\n \n=\n \nnil\n \n-- \nnil\n for server sent.\n\n\nlocal\n \nsubject\n \n=\n \nYou earned a secret item!\n\n\nlocal\n \ncontent\n \n=\n \n{\n\n  \nitem_id\n \n=\n \n192308394345345\n,\n\n  \nitem_icon\n \n=\n \nstorm_bringer_sword.png\n\n\n}\n\n\nlocal\n \ncode\n \n=\n \n101\n\n\nlocal\n \nexpires_at\n \n=\n \n1000\n \n*\n \n60\n \n*\n \n60\n \n*\n \n24\n \n*\n \n7\n \n-- expires in 7 days.\n\n\nlocal\n \npersistent\n \n=\n \ntrue\n\n\n\nnk\n.\nnotification_send_id\n({\nUserIds\n \n=\n \nuser_ids\n,\n \nSenderId\n \n=\n \nsender_id\n,\n \nSubject\n \n=\n \nsubject\n,\n\n                         \nContent\n \n=\n \ncontent\n,\n \nCode\n \n=\n \ncode\n,\n \nExpiresAt\n \n=\n \nexpires_at\n,\n\n                         \nPersistent\n \n=\n \npersistent\n})\n\n\n\n\n\n\nReceive notifications\n\n\nAn event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.\n\n\nclient\n.\nOnNotificationReceived\n \n+=\n \n(\nobject\n \nsender\n,\n \nNNotificationEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINNotification\n \nn\n \n=\n \nargs\n.\nNotification\n;\n\n  \nDebug\n.\nLogFormat\n(\nReceived code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nn\n.\nContent\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nReceived id \n{0}\n and content \n{1}\n.\n,\n \nn\n.\nId\n,\n \ncontent\n);\n\n\n};\n\n\n\n\n\n\nList notifications\n\n\nYou can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nn\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nNotice code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.\n\n\n\n\nHint\n\n\nYou usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.\n\n\n\n\nIList\nINNotification\n \nallNotifications\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\n\nAction\n \naccumulateNotifications\n \n=\n \ndelegate\n(\nINCursor\n \nresumeCursor\n)\n \n{\n\n  \nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n      \n.\nCursor\n(\nresumeCursor\n)\n\n      \n.\nBuild\n();\n\n  \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n    \nif\n \n(\nlist\n.\nResults\n.\nLength\n \n \n1\n)\n \n{\n\n      \nreturn\n;\n\n    \n}\n \nelse\n \n{\n\n      \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n      \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n \n// recursive async call.\n\n    \n}\n\n  \n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n});\n\n\n};\n\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n  \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nIt can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.\n\n\nThe resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.\n\n\nINCursor\n \nresumeCursor\n \n=\n \n...;\n \n// stored from last list retrieval.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n    \n.\nCursor\n(\nresumeCursor\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \n// use notification list.\n\n  \nresumeCursor\n \n=\n \nlist\n.\nCursor\n;\n \n// cache resume cursor.\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nDelete notifications\n\n\nYou can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.\n\n\nIList\nINNotification\n \nlist\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\nlist\n.\nAdd\n(...);\n \n// Add notification from your internal list\n\n\nvar\n \nmessage\n \n=\n \nNNotificationRemove\n.\nDefault\n(\nlist\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nNotifications were removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nNotification codes\n\n\nThe server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.\n\n\n\n\n\n\n\n\nCode\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n001\n\n\nUser X wants to chat.\n\n\n\n\n\n\n002\n\n\nUser X wants to add you as a friend.\n\n\n\n\n\n\n003\n\n\nUser X accepted your friend invite.\n\n\n\n\n\n\n004\n\n\nYou've been accepted to X group.\n\n\n\n\n\n\n005\n\n\nUser X wants to join your group.\n\n\n\n\n\n\n006\n\n\nYour friend X has just joined the game.", 
            "title": "In-app notifications"
        }, 
        {
            "location": "/in-app-notifications/#in-app-notifications", 
            "text": "In-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.  A notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.  These notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/in-app-notifications/#send-notifications", 
            "text": "You can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.   Note  The code you choose for your notifications must start at \"101\" and upwards. See  below  for reserved message codes.   A notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.  Notifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.  local   nk   =   require ( nakama )  local   user_ids   =   { someuserid ,   anotheruserid ,   etc }  local   sender_id   =   nil   --  nil  for server sent.  local   subject   =   You earned a secret item!  local   content   =   { \n   item_id   =   192308394345345 , \n   item_icon   =   storm_bringer_sword.png  }  local   code   =   101  local   expires_at   =   1000   *   60   *   60   *   24   *   7   -- expires in 7 days.  local   persistent   =   true  nk . notification_send_id ({ UserIds   =   user_ids ,   SenderId   =   sender_id ,   Subject   =   subject , \n                          Content   =   content ,   Code   =   code ,   ExpiresAt   =   expires_at , \n                          Persistent   =   persistent })", 
            "title": "Send notifications"
        }, 
        {
            "location": "/in-app-notifications/#receive-notifications", 
            "text": "An event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.  client . OnNotificationReceived   +=   ( object   sender ,   NNotificationEventArgs   args )   =   { \n   INNotification   n   =   args . Notification ; \n   Debug . LogFormat ( Received code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   var   content   =   Encoding . UTF8 . GetString ( n . Content );   // convert byte[]. \n   Debug . LogFormat ( Received id  {0}  and content  {1} . ,   n . Id ,   content );  };", 
            "title": "Receive notifications"
        }, 
        {
            "location": "/in-app-notifications/#list-notifications", 
            "text": "You can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   foreach   ( var   n   in   list . Results )   { \n     Debug . LogFormat ( Notice code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.   Hint  You usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.   IList INNotification   allNotifications   =   new   List INNotification ();  Action   accumulateNotifications   =   delegate ( INCursor   resumeCursor )   { \n   var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n       . Cursor ( resumeCursor ) \n       . Build (); \n   client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n     if   ( list . Results . Length     1 )   { \n       return ; \n     }   else   { \n       allNotifications . AddRange ( list . Results ); \n       accumulateNotifications ( list . Cursor );   // recursive async call. \n     } \n   },   ( INError   err )   =   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   });  };  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   allNotifications . AddRange ( list . Results ); \n   accumulateNotifications ( list . Cursor );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   It can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.  The resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.  INCursor   resumeCursor   =   ...;   // stored from last list retrieval.  var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n     . Cursor ( resumeCursor ) \n     . Build ();  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   // use notification list. \n   resumeCursor   =   list . Cursor ;   // cache resume cursor.  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List notifications"
        }, 
        {
            "location": "/in-app-notifications/#delete-notifications", 
            "text": "You can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.  IList INNotification   list   =   new   List INNotification ();  list . Add (...);   // Add notification from your internal list  var   message   =   NNotificationRemove . Default ( list );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Notifications were removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Delete notifications"
        }, 
        {
            "location": "/in-app-notifications/#notification-codes", 
            "text": "The server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.     Code  Purpose      001  User X wants to chat.    002  User X wants to add you as a friend.    003  User X accepted your friend invite.    004  You've been accepted to X group.    005  User X wants to join your group.    006  Your friend X has just joined the game.", 
            "title": "Notification codes"
        }
    ]
}