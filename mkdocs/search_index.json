{
    "docs": [
        {
            "location": "/friends/", 
            "text": "Friends\n\n\nFriends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.\n\n\n\n\nFun fact\n\n\nNakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!\n\n\n\n\nEach user builds up a list of friends by who they know already from their social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.\n\n\nAny social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.\n\n\nAdd friends\n\n\nA user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.\n\n\n\n\nHint\n\n\nA user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.\n\n\n\n\nWhen a friend request is sent or the user is added an in-app notification will be sent. See the \nin-app notification\n section for more info.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendAddMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nFriend added or request sent.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nWhen both users have added eachother as friends it's easy to initiate realtime chat in a 1-on-1 channel. See the \nrealtime chat\n section for more info.\n\n\nList friends\n\n\nYou can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.\n\n\nvar\n \nmessage\n \n=\n \nNFriendsListMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINFriend\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nf\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nf\n.\nId\n);\n \n// convert byte[].\n\n    \n// f.State is one of: Friend, Invite, Invited, Blocked.\n\n    \nDebug\n.\nLogFormat\n(\nUser {0} has state {1}.\n,\n \nid\n,\n \nf\n.\nState\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nRemove friends\n\n\nA user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.\n\n\n\n\nNote\n\n\nIf a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.\n\n\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendRemoveMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nuserId\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been removed.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBlock a friend\n\n\nYou can stop a user from using 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a \nFriend Remove\n message.\n\n\nA user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendBlockMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nid\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been blocked.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBan a user\n\n\nA user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.\n\n\nThis is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team. See the \nruntime code\n section on how to write server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n-- you can use both IDs and handles to ban.\n\n\nlocal\n \nbad_users\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n,\n \nuserhandle\n}\n\n\nlocal\n \nsuccess\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nbad_users\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nBan failed: %q\n):\nformat\n(\nerr\n))\n\n\nend", 
            "title": "Friends"
        }, 
        {
            "location": "/friends/#friends", 
            "text": "Friends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.   Fun fact  Nakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!   Each user builds up a list of friends by who they know already from their social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.  Any social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.", 
            "title": "Friends"
        }, 
        {
            "location": "/friends/#add-friends", 
            "text": "A user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.   Hint  A user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.   When a friend request is sent or the user is added an in-app notification will be sent. See the  in-app notification  section for more info.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendAddMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Friend added or request sent. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   When both users have added eachother as friends it's easy to initiate realtime chat in a 1-on-1 channel. See the  realtime chat  section for more info.", 
            "title": "Add friends"
        }, 
        {
            "location": "/friends/#list-friends", 
            "text": "You can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.  var   message   =   NFriendsListMessage . Default ();  client . Send ( message ,   ( INResultSet INFriend   list )   =   { \n   foreach   ( var   f   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( f . Id );   // convert byte[]. \n     // f.State is one of: Friend, Invite, Invited, Blocked. \n     Debug . LogFormat ( User {0} has state {1}. ,   id ,   f . State ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List friends"
        }, 
        {
            "location": "/friends/#remove-friends", 
            "text": "A user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.   Note  If a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.   byte []   userId   =   ...;   // some user ID  var   message   =   NFriendRemoveMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( userId );   // convert byte[]. \n   Debug . Log ( User {0} has been removed. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Remove friends"
        }, 
        {
            "location": "/friends/#block-a-friend", 
            "text": "You can stop a user from using 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a  Friend Remove  message.  A user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendBlockMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( id );   // convert byte[]. \n   Debug . Log ( User {0} has been blocked. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Block a friend"
        }, 
        {
            "location": "/friends/#ban-a-user", 
            "text": "A user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.  This is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team. See the  runtime code  section on how to write server-side code.  local   nk   =   require ( nakama )  -- you can use both IDs and handles to ban.  local   bad_users   =   { someuserid ,   anotheruserid ,   userhandle }  local   success ,   err   =   pcall ( nk . users_ban ,   bad_users )  if   ( not   success )   then \n   nk . logger_error (( Ban failed: %q ): format ( err ))  end", 
            "title": "Ban a user"
        }, 
        {
            "location": "/in-app-notifications/", 
            "text": "In-app Notifications\n\n\nIn-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.\n\n\nA notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.\n\n\nThese notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.\n\n\nSend notifications\n\n\nYou can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.\n\n\n\n\nNote\n\n\nThe code you choose for your notifications must start at \"101\" and upwards. See \nbelow\n for reserved message codes.\n\n\n\n\nA notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.\n\n\nNotifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_ids\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n}\n\n\nlocal\n \nnotification\n \n=\n \n{\n\n  \nSenderId\n \n=\n \nnil\n,\n                       \n-- \nnil\n for server sent.\n\n  \nSubject\n \n=\n \nYou earned a secret item!\n,\n\n  \nContent\n \n=\n \n{\n\n    \nitem_id\n \n=\n \n192308394345345\n,\n\n    \nitem_icon\n \n=\n \nstorm_bringer_sword.png\n\n  \n},\n\n  \nCode\n \n=\n \n101\n,\n\n  \nExpiresAt\n \n=\n \n1000\n \n*\n \n60\n \n*\n \n60\n \n*\n \n24\n \n*\n \n7\n,\n  \n-- expires in 7 days.\n\n  \nPersistent\n \n=\n \ntrue\n\n\n}\n\n\n\nlocal\n \nnotifications\n \n=\n \n{}\n\n\nfor\n \n_\n,\n \nuser_id\n \nin\n \nipairs\n(\nuser_ids\n)\n\n\ndo\n\n  \nlocal\n \nn\n \n=\n \n{\nunpack\n(\nnotification\n)}\n\n  \nn\n.\nUserId\n \n=\n \nuser_id\n\n  \ntable.insert\n(\nnotifications\n,\n \nn\n)\n\n\nend\n\n\n\nnk\n.\nnotification_send_id\n(\nnotifications\n)\n\n\n\n\n\n\nReceive notifications\n\n\nAn event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.\n\n\nclient\n.\nOnNotification\n \n+=\n \n(\nobject\n \nsender\n,\n \nNNotificationEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINNotification\n \nn\n \n=\n \nargs\n.\nNotification\n;\n\n  \nDebug\n.\nLogFormat\n(\nReceived code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nn\n.\nContent\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nReceived id \n{0}\n and content \n{1}\n.\n,\n \nn\n.\nId\n,\n \ncontent\n);\n\n\n};\n\n\n\n\n\n\nList notifications\n\n\nYou can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nn\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nNotice code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.\n\n\n\n\nHint\n\n\nYou usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.\n\n\n\n\nIList\nINNotification\n \nallNotifications\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\n\nAction\n \naccumulateNotifications\n \n=\n \ndelegate\n(\nINCursor\n \nresumeCursor\n)\n \n{\n\n  \nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n      \n.\nCursor\n(\nresumeCursor\n)\n\n      \n.\nBuild\n();\n\n  \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n    \nif\n \n(\nlist\n.\nResults\n.\nLength\n \n \n1\n)\n \n{\n\n      \nreturn\n;\n\n    \n}\n \nelse\n \n{\n\n      \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n      \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n \n// recursive async call.\n\n    \n}\n\n  \n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n});\n\n\n};\n\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n  \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nIt can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.\n\n\nThe resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.\n\n\nINCursor\n \nresumeCursor\n \n=\n \n...;\n \n// stored from last list retrieval.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n    \n.\nResumeCursor\n(\nresumeCursor\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \n// use notification list.\n\n  \nresumeCursor\n \n=\n \nlist\n.\nCursor\n;\n \n// cache resume cursor.\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nDelete notifications\n\n\nYou can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.\n\n\nIList\nINNotification\n \nlist\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\nlist\n.\nAdd\n(...);\n \n// Add notification from your internal list\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsRemoveMessage\n.\nDefault\n(\nlist\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nNotifications were removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nNotification codes\n\n\nThe server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.\n\n\n\n\n\n\n\n\nCode\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n001\n\n\nUser X wants to chat.\n\n\n\n\n\n\n002\n\n\nUser X wants to add you as a friend.\n\n\n\n\n\n\n003\n\n\nUser X accepted your friend invite.\n\n\n\n\n\n\n004\n\n\nYou've been accepted to X group.\n\n\n\n\n\n\n005\n\n\nUser X wants to join your group.\n\n\n\n\n\n\n006\n\n\nYour friend X has just joined the game.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/in-app-notifications/#in-app-notifications", 
            "text": "In-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.  A notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.  These notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/in-app-notifications/#send-notifications", 
            "text": "You can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.   Note  The code you choose for your notifications must start at \"101\" and upwards. See  below  for reserved message codes.   A notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.  Notifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.  local   nk   =   require ( nakama )  local   user_ids   =   { someuserid ,   anotheruserid }  local   notification   =   { \n   SenderId   =   nil ,                         --  nil  for server sent. \n   Subject   =   You earned a secret item! , \n   Content   =   { \n     item_id   =   192308394345345 , \n     item_icon   =   storm_bringer_sword.png \n   }, \n   Code   =   101 , \n   ExpiresAt   =   1000   *   60   *   60   *   24   *   7 ,    -- expires in 7 days. \n   Persistent   =   true  }  local   notifications   =   {}  for   _ ,   user_id   in   ipairs ( user_ids )  do \n   local   n   =   { unpack ( notification )} \n   n . UserId   =   user_id \n   table.insert ( notifications ,   n )  end  nk . notification_send_id ( notifications )", 
            "title": "Send notifications"
        }, 
        {
            "location": "/in-app-notifications/#receive-notifications", 
            "text": "An event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.  client . OnNotification   +=   ( object   sender ,   NNotificationEventArgs   args )   =   { \n   INNotification   n   =   args . Notification ; \n   Debug . LogFormat ( Received code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   var   content   =   Encoding . UTF8 . GetString ( n . Content );   // convert byte[]. \n   Debug . LogFormat ( Received id  {0}  and content  {1} . ,   n . Id ,   content );  };", 
            "title": "Receive notifications"
        }, 
        {
            "location": "/in-app-notifications/#list-notifications", 
            "text": "You can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   foreach   ( var   n   in   list . Results )   { \n     Debug . LogFormat ( Notice code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.   Hint  You usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.   IList INNotification   allNotifications   =   new   List INNotification ();  Action   accumulateNotifications   =   delegate ( INCursor   resumeCursor )   { \n   var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n       . Cursor ( resumeCursor ) \n       . Build (); \n   client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n     if   ( list . Results . Length     1 )   { \n       return ; \n     }   else   { \n       allNotifications . AddRange ( list . Results ); \n       accumulateNotifications ( list . Cursor );   // recursive async call. \n     } \n   },   ( INError   err )   =   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   });  };  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   allNotifications . AddRange ( list . Results ); \n   accumulateNotifications ( list . Cursor );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   It can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.  The resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.  INCursor   resumeCursor   =   ...;   // stored from last list retrieval.  var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n     . ResumeCursor ( resumeCursor ) \n     . Build ();  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   // use notification list. \n   resumeCursor   =   list . Cursor ;   // cache resume cursor.  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List notifications"
        }, 
        {
            "location": "/in-app-notifications/#delete-notifications", 
            "text": "You can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.  IList INNotification   list   =   new   List INNotification ();  list . Add (...);   // Add notification from your internal list  var   message   =   NNotificationsRemoveMessage . Default ( list );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Notifications were removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Delete notifications"
        }, 
        {
            "location": "/in-app-notifications/#notification-codes", 
            "text": "The server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.     Code  Purpose      001  User X wants to chat.    002  User X wants to add you as a friend.    003  User X accepted your friend invite.    004  You've been accepted to X group.    005  User X wants to join your group.    006  Your friend X has just joined the game.", 
            "title": "Notification codes"
        }, 
        {
            "location": "/runtime-function-reference/", 
            "text": "Function Reference\n\n\nThe code runtime built into the server includes a module with functions to implement various logic and custom behavior. It is easy to define authoritative code and conditions on input received by clients.\n\n\nNakama module\n\n\nThis module contains all the core gameplay APIs, all registration functions used at server startup, utilities for various codecs, and cryptographic primitives.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n\n\n\n\n\nNote\n\n\nAll code examples assume the \"nakama\" module has been imported.\n\n\n\n\nbase16\n\n\nbase16_decode (input)\n\n\nBase 16 decode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base16 decoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 16 decoded input.\n\n\nExample\n\n\nlocal\n \ndecoded\n \n=\n \nnk\n.\nbase16_decode\n(\n48656C6C6F20776F726C64\n)\n\n\nprint\n(\ndecoded\n)\n \n-- outputs \nHello world\n\n\n\n\n\n\n\n\nbase16_encode (input)\n\n\nBase 16 encode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base16 encoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 16 encoded input.\n\n\nExample\n\n\nlocal\n \nencoded\n \n=\n \nnk\n.\nbase16_encode\n(\nHello world\n)\n\n\nprint\n(\nencoded\n)\n \n-- outputs \n48656C6C6F20776F726C64\n\n\n\n\n\n\nbase64\n\n\nbase64_decode (input)\n\n\nBase 64 decode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base64 decoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 64 decoded input.\n\n\nExample\n\n\nlocal\n \ndecoded\n \n=\n \nnk\n.\nbase64_decode\n(\nSGVsbG8gd29ybGQ=\n)\n\n\nprint\n(\ndecoded\n)\n \n-- outputs \nHello world\n\n\n\n\n\n\n\n\nbase64_encode (input)\n\n\nBase 64 encode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base64 encoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 64 encoded input.\n\n\nExample\n\n\nlocal\n \nencoded\n \n=\n \nnk\n.\nbase64_encode\n(\nHello world\n)\n\n\nprint\n(\nencoded\n)\n \n-- outputs \nSGVsbG8gd29ybGQ=\n\n\n\n\n\n\ngroups\n\n\ngroups_create (new_groups)\n\n\nSetup one or more groups with various configuration settings. The groups will be created if they don't exist or fail if the group names are taken.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_groups\n\n\ntable\n\n\nThe Lua table array of new groups to create.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nnew_groups\n \n=\n \n{\n\n  \n-- The CreatorId should be a user ID.\n\n  \n{\n \nName\n \n=\n \nA\n,\n \nDescription\n \n=\n \nB\n,\n \nLang\n \n=\n \nen\n,\n \nPrivate\n \n=\n \ntrue\n,\n \nCreatorId\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n \n}\n\n\n}\n\n\nnk\n.\ngroups_create\n(\nnew_groups\n)\n\n\n\n\n\n\nhttp\n\n\nhttp_request (url, method, headers, content)\n\n\nSend a HTTP request and receive the result as a Lua table.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nstring\n\n\nThe URL of the web resource to request.\n\n\n\n\n\n\nmethod\n\n\nstring\n\n\nThe HTTP method verb used with the request.\n\n\n\n\n\n\nheaders\n\n\ntable\n\n\nA table of headers used with the request.\n\n\n\n\n\n\ncontent\n\n\nstring\n\n\nThe bytes to send with the request.\n\n\n\n\n\n\n\n\nReturns\n\n\ncode, headers, body\n - Multiple return values for the HTTP response.\n\n\nExample\n\n\nlocal\n \nurl\n \n=\n \nhttps://google.com/\n\n\nlocal\n \nmethod\n \n=\n \nHEAD\n\n\nlocal\n \nheaders\n \n=\n \n{\n\n  \n[\nContent-Type\n]\n \n=\n \napplication/json\n,\n\n  \n[\nAccept\n]\n \n=\n \napplication/json\n\n\n}\n\n\nlocal\n \ncontent\n \n=\n \nnk\n.\njson_encode\n({})\n \n-- encode table as JSON string\n\n\nlocal\n \nsuccess\n,\n \ncode\n,\n \nheaders\n,\n \nbody\n \n=\n \npcall\n(\nnk\n.\nhttp_request\n,\n \nurl\n,\n \nmethod\n,\n \nheaders\n,\n \ncontent\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nFailed %q\n):\nformat\n(\ncode\n))\n\n\nelseif\n \n(\ncode\n \n=\n \n400\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nFailed %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n\nelse\n\n  \nnk\n.\nlogger_info\n((\nSuccess %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n\nend\n\n\n\n\n\n\njson\n\n\njson_decode (input)\n\n\nDecode the JSON input as a Lua table.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe JSON encoded input.\n\n\n\n\n\n\n\n\nReturns\n\n\nA Lua table with the decoded JSON.\n\n\nExample\n\n\nlocal\n \njson\n \n=\n \nnk\n.\njson_decode\n(\n{\nhello\n: \nworld\n}\n)\n\n\nprint\n(\njson\n.\nhello\n)\n\n\n\n\n\n\n\n\njson_encode (input)\n\n\nEncode the input as JSON.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe input to encode as JSON.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe encoded JSON string.\n\n\nExample\n\n\nlocal\n \ninput\n \n=\n \n{[\nsome\n]\n \n=\n \njson\n}\n\n\nlocal\n \njson\n \n=\n \nnk\n.\njson_encode\n(\ninput\n)\n\n\nprint\n(\njson\n)\n \n-- outputs \n{\nsome\n: \njson\n}\n\n\n\n\n\n\nleaderboard\n\n\nleaderboard_create (id, sort, reset, metadata, authoritative)\n\n\nSetup a new dynamic leaderboard with the specified ID and various configuration settings. The leaderboard will be created if it doesn't already exist.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe unique identifier for the new leaderboard. This is used by clients to submit scores.\n\n\n\n\n\n\nsort\n\n\nstring\n\n\nThe sort order for records in the leaderboard; possible values are \"asc\" or \"desc\".\n\n\n\n\n\n\nreset\n\n\nstring\n\n\nThe cron format used to define the reset schedule for the leaderboard. This controls when a leaderboard is reset and can be used to power daily/weekly/monthly leaderboards.\n\n\n\n\n\n\nmetadata\n\n\ntable\n\n\nThe metadata you want associated to the leaderboard. Some good examples are weather conditions for a racing game.\n\n\n\n\n\n\nauthoritative\n\n\nbool\n\n\nMark the leaderboard as authoritative which ensures updates can only be made via the Lua runtime. No client can submit a score directly.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nmetadata\n \n=\n \n{\n\n  \nweather_conditions\n \n=\n \nrain\n\n\n}\n\n\nlocal\n \nid\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n\n\nnk\n.\nleaderboard_create\n(\nid\n,\n \ndesc\n,\n \n0 0 * * 1\n,\n \nmetadata\n,\n \nfalse\n)\n\n\n\n\n\n\nlogger\n\n\nlogger_error (message)\n\n\nWrite an ERROR level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with ERROR level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_error\n(\nmessage\n)\n\n\n\n\n\n\n\n\nlogger_info (message)\n\n\nWrite an INFO level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with INFO level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_info\n(\nmessage\n)\n\n\n\n\n\n\n\n\nlogger_warn (message)\n\n\nWrite an WARN level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with WARN level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_warn\n(\nmessage\n)\n\n\n\n\n\n\nnotifications\n\n\nnotifications_send_id (new_notifications)\n\n\nSend one or more in-app notifications to a user. Have a look at the section on \nin-app notifications\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_notifications\n\n\ntable\n\n\nThe Lua table array of notifications to send.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nsubject\n \n=\n \nYou\nve unlocked level 100!\n\n\nlocal\n \ncontent\n \n=\n \nnk\n.\njson_encode\n({\n\n  \nreward_coins\n \n=\n \n1000\n\n\n})\n\n\nlocal\n \nuser_id\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n \n-- who to send\n\n\nlocal\n \ncode\n \n=\n \n101\n\n\n\nlocal\n \nnew_notifications\n \n=\n \n{\n\n  \n{\n \nSubject\n \n=\n \nsubject\n,\n \nContent\n \n=\n \ncontent\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nCode\n \n=\n \ncode\n,\n \nPersistent\n \n=\n \ntrue\n}\n\n\n}\n\n\nnk\n.\nnotifications_send_id\n(\nnew_notifications\n)\n\n\n\n\n\n\nregister hooks\n\n\nregister_after (func, msgname)\n\n\nRegister a function with the server which will be executed after every message with the specified message name.\n\n\nThis can be used to apply custom logic to standard features in the server. Similar to the \nregister_before\n function but it will not block the execution pipeline. The logic will be executed in parallel to any response message sent back to a client.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each \nmsgname\n message.\n\n\n\n\n\n\nmsgname\n\n\nstring\n\n\nThe specific message name to execute the \nfunc\n function after.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n\nend\n\n\nnk\n.\nregister_after\n(\nmy_func\n,\n \nTFriendAdd\n)\n\n\n\n\n\n\n\n\nregister_before (func, msgname)\n\n\nRegister a function with the server which will be executed before every message with the specified message name.\n\n\nFor example \nregister_before(somefunc, \"TFriendAdd\")\n will execute the function before the Friend Add message is executed by the server\ns message pipeline. This can be used to apply custom conditions to standard features in the server.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each \nmsgname\n message.\n\n\n\n\n\n\nmsgname\n\n\nstring\n\n\nThe specific message name to execute the \nfunc\n function before.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n should pass the \npayload\n back as a return argument so the pipeline can continue to execute the standard logic.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n  \nreturn\n \npayload\n \n-- important!\n\n\nend\n\n\nnk\n.\nregister_before\n(\nmy_func\n,\n \nTFriendAdd\n)\n\n\n\n\n\n\n\n\nregister_http (func, path)\n\n\nRegisters a HTTP endpoint within the server.\n\n\n\n\nWarning\n\n\nThis should not be used to implement custom client functions use \nregister_rpc\n instead.\n\n\n\n\nThis can be useful to define web callbacks to handle various Ad networks. It can also be used to enable server to server communication to ease the integration of Nakama server into various server stacks.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each HTTP call.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nThe path that should be registered as a HTTP endpoint.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n can pass \nnil\n or \ntable\n back as a return argument which will determine the HTTP response code returned.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- let\ns return the \ncontext\n as JSON back in the HTTP response body\n\n  \nreturn\n \ncontext\n\n\nend\n\n\nnk\n.\nregister_http\n(\nmy_func\n,\n \n/my_endpoint\n)\n\n\n-- \nmy_func\n will be registered at \nPOST /runtime/my_endpoint\n\n\n\n\n\n\nYou can send a request to the HTTP endpoint with JSON and responses will be returned in JSON.\n\n\ncurl -X POST http://127.0.0.1:7350/runtime/my_endpoint?key\n=\ndefaultkey \n\\\n\n     -d \n{\nsome\n: \ndata\n}\n \n\\\n\n     -H \nContent-Type: application/json\n \n\\\n\n     -H \nAccept: application/json\n\n\n\n\n\n\n\n\nregister_rpc (func, id)\n\n\nRegisters a function for use with client RPC to the server.\n\n\nThe ID can be any string identifier and is sent by the client. The ID is used to map the client RPC message to the specific function to execute.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each RPC message.\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe unique identifier used to register the \nfunc\n function for RPC.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n can pass \nnil\n or \nstring\n back as a return argument which will returned as bytes in the RPC response.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n\nend\n\n\nnk\n.\nregister_rpc\n(\nmy_func\n,\n \nmy_func_id\n)\n\n\n\n\n\n\nstorage\n\n\nstorage_fetch (record_keys)\n\n\nFetch one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of record identifiers to be fetched.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the records result set.\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n}\n\n\n}\n\n\nlocal\n \nrecords\n \n=\n \nnk\n.\nstorage_fetch\n(\nrecord_keys\n)\n\n\nfor\n \n_\n,\n \nr\n \nin\n \nipairs\n(\nrecords\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nread: %q, write: %q, value: %q\n):\nformat\n(\nr\n.\nPermissionRead\n,\n \nr\n.\nPermissionWrite\n,\n \nr\n.\nValue\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nstorage_remove (record_keys)\n\n\nRemove one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of record identifiers to be removed.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n}\n\n\n}\n\n\nnk\n.\nstorage_remove\n(\nrecord_keys\n)\n\n\n\n\n\n\n\n\nstorage_update (record_keys)\n\n\nUpdate one or more records by their bucket/collection/keyname and optional user. Have a look at the section on \nstorage collections\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of records to update.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nnow\n \n=\n \nos.time\n()\n \n*\n \n1000\n \n-- current time converted for msec\n\n\nlocal\n \nupdate_ops\n \n=\n \n{\n\n  \n{\nOp\n \n=\n \ninit\n,\n \nPath\n \n=\n \n/\n,\n \nValue\n \n=\n \n{\n \nprogress\n \n=\n \n1\n \n}},\n\n  \n{\nOp\n \n=\n \nincr\n,\n \nPath\n \n=\n \n/progress\n,\n \nValue\n \n=\n \n1\n},\n\n  \n{\nOp\n \n=\n \nreplace\n,\n \nPath\n \n=\n \n/updated_at\n,\n \nValue\n \n=\n \nnow\n}\n\n\n}\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nb\n,\n \nCollection\n \n=\n \nc\n,\n \nRecord\n \n=\n \nr\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nUpdateOps\n \n=\n \nupdate_ops\n}\n\n\n}\n\n\nnk\n.\nstorage_update\n(\nrecord_keys\n)\n\n\n\n\n\n\n\n\nstorage_write (new_records)\n\n\nWrite one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_records\n\n\ntable\n\n\nA table array of new records to write.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nnew_records\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}}\n\n\n}\n\n\nnk\n.\nstorage_write\n(\nnew_records\n)\n\n\n\n\n\n\nusers\n\n\nusers_ban (user_ids)\n\n\nBan one or more users from the server.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_ids\n\n\ntable\n\n\nA table array of user IDs to be banned.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n4c2ae592-b2a7-445e-98ec-697694478b1c\n}\n\n\nlocal\n \nstatus\n,\n \nresult\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nuser_ids\n)\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nprint\n(\nresult\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_fetch_handle (user_handles)\n\n\nFetch a set of users by handle.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_handles\n\n\ntable\n\n\nA table array of user handles to fetch.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the user result set.\n\n\nExample\n\n\nlocal\n \nuser_handles\n \n=\n \n{\nb7865e7e\n,\n \nc048ba7a\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nusers_fetch_handle\n(\nuser_handles\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nid: %q, fullname: %q\n):\nformat\n(\nu\n.\nId\n,\n \nu\n.\nFullname\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_fetch_id (user_ids)\n\n\nFetch one or more users by ID.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_ids\n\n\ntable\n\n\nA table array of user IDs to fetch.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the user result set.\n\n\nExample\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n\n  \n3ea5608a-43c3-11e7-90f9-7b9397165f34\n,\n\n  \n447524be-43c3-11e7-af09-3f7172f05936\n\n\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nuser_fetch_id\n(\nuser_ids\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nhandle: %q, fullname: %q\n):\nformat\n(\nu\n.\nHandle\n,\n \nu\n.\nFullname\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_update (user_updates)\n\n\nUpdate one or more users.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_updates\n\n\ntable\n\n\nThe table array of users to update.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nuser_updates\n \n=\n \n{\n\n  \n{\n \nUserId\n \n=\n \nuser_id\n,\n \nMetadata\n \n=\n \n{}\n \n}\n\n\n}\n\n\nlocal\n \nstatus\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_update\n,\n \nuser_updates\n)\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nprint\n((\nUser update error: %q\n):\nformat\n(\nerr\n))\n\n\nend\n\n\n\n\n\n\nuuid\n\n\nuuid_v4 ()\n\n\nGenerate a version 4 UUID.\n\n\nReturns\n\n\nThe generated version 4 UUID identifier.\n\n\nExample\n\n\nlocal\n \nuuid\n \n=\n \nnk\n.\nuuid_v4\n()\n\n\nprint\n(\nuuid\n)", 
            "title": "Function Reference"
        }, 
        {
            "location": "/runtime-function-reference/#function-reference", 
            "text": "The code runtime built into the server includes a module with functions to implement various logic and custom behavior. It is easy to define authoritative code and conditions on input received by clients.", 
            "title": "Function Reference"
        }, 
        {
            "location": "/runtime-function-reference/#nakama-module", 
            "text": "This module contains all the core gameplay APIs, all registration functions used at server startup, utilities for various codecs, and cryptographic primitives.  local   nk   =   require ( nakama )    Note  All code examples assume the \"nakama\" module has been imported.", 
            "title": "Nakama module"
        }, 
        {
            "location": "/runtime-function-reference/#base16", 
            "text": "base16_decode (input)  Base 16 decode the input.  Parameters     Param  Type  Description      input  string  The string which will be base16 decoded.     Returns  The base 16 decoded input.  Example  local   decoded   =   nk . base16_decode ( 48656C6C6F20776F726C64 )  print ( decoded )   -- outputs  Hello world    base16_encode (input)  Base 16 encode the input.  Parameters     Param  Type  Description      input  string  The string which will be base16 encoded.     Returns  The base 16 encoded input.  Example  local   encoded   =   nk . base16_encode ( Hello world )  print ( encoded )   -- outputs  48656C6C6F20776F726C64", 
            "title": "base16"
        }, 
        {
            "location": "/runtime-function-reference/#base64", 
            "text": "base64_decode (input)  Base 64 decode the input.  Parameters     Param  Type  Description      input  string  The string which will be base64 decoded.     Returns  The base 64 decoded input.  Example  local   decoded   =   nk . base64_decode ( SGVsbG8gd29ybGQ= )  print ( decoded )   -- outputs  Hello world    base64_encode (input)  Base 64 encode the input.  Parameters     Param  Type  Description      input  string  The string which will be base64 encoded.     Returns  The base 64 encoded input.  Example  local   encoded   =   nk . base64_encode ( Hello world )  print ( encoded )   -- outputs  SGVsbG8gd29ybGQ=", 
            "title": "base64"
        }, 
        {
            "location": "/runtime-function-reference/#groups", 
            "text": "groups_create (new_groups)  Setup one or more groups with various configuration settings. The groups will be created if they don't exist or fail if the group names are taken.  Parameters     Param  Type  Description      new_groups  table  The Lua table array of new groups to create.     Example  local   new_groups   =   { \n   -- The CreatorId should be a user ID. \n   {   Name   =   A ,   Description   =   B ,   Lang   =   en ,   Private   =   true ,   CreatorId   =   4c2ae592-b2a7-445e-98ec-697694478b1c   }  }  nk . groups_create ( new_groups )", 
            "title": "groups"
        }, 
        {
            "location": "/runtime-function-reference/#http", 
            "text": "http_request (url, method, headers, content)  Send a HTTP request and receive the result as a Lua table.  Parameters     Param  Type  Description      url  string  The URL of the web resource to request.    method  string  The HTTP method verb used with the request.    headers  table  A table of headers used with the request.    content  string  The bytes to send with the request.     Returns  code, headers, body  - Multiple return values for the HTTP response.  Example  local   url   =   https://google.com/  local   method   =   HEAD  local   headers   =   { \n   [ Content-Type ]   =   application/json , \n   [ Accept ]   =   application/json  }  local   content   =   nk . json_encode ({})   -- encode table as JSON string  local   success ,   code ,   headers ,   body   =   pcall ( nk . http_request ,   url ,   method ,   headers ,   content )  if   ( not   success )   then \n   nk . logger_error (( Failed %q ): format ( code ))  elseif   ( code   =   400 )   then \n   nk . logger_error (( Failed %q %q ): format ( code ,   body ))  else \n   nk . logger_info (( Success %q %q ): format ( code ,   body ))  end", 
            "title": "http"
        }, 
        {
            "location": "/runtime-function-reference/#json", 
            "text": "json_decode (input)  Decode the JSON input as a Lua table.  Parameters     Param  Type  Description      input  string  The JSON encoded input.     Returns  A Lua table with the decoded JSON.  Example  local   json   =   nk . json_decode ( { hello :  world } )  print ( json . hello )    json_encode (input)  Encode the input as JSON.  Parameters     Param  Type  Description      input  string  The input to encode as JSON.     Returns  The encoded JSON string.  Example  local   input   =   {[ some ]   =   json }  local   json   =   nk . json_encode ( input )  print ( json )   -- outputs  { some :  json }", 
            "title": "json"
        }, 
        {
            "location": "/runtime-function-reference/#leaderboard", 
            "text": "leaderboard_create (id, sort, reset, metadata, authoritative)  Setup a new dynamic leaderboard with the specified ID and various configuration settings. The leaderboard will be created if it doesn't already exist.  Parameters     Param  Type  Description      id  string  The unique identifier for the new leaderboard. This is used by clients to submit scores.    sort  string  The sort order for records in the leaderboard; possible values are \"asc\" or \"desc\".    reset  string  The cron format used to define the reset schedule for the leaderboard. This controls when a leaderboard is reset and can be used to power daily/weekly/monthly leaderboards.    metadata  table  The metadata you want associated to the leaderboard. Some good examples are weather conditions for a racing game.    authoritative  bool  Mark the leaderboard as authoritative which ensures updates can only be made via the Lua runtime. No client can submit a score directly.     Example  local   metadata   =   { \n   weather_conditions   =   rain  }  local   id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521  nk . leaderboard_create ( id ,   desc ,   0 0 * * 1 ,   metadata ,   false )", 
            "title": "leaderboard"
        }, 
        {
            "location": "/runtime-function-reference/#logger", 
            "text": "logger_error (message)  Write an ERROR level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with ERROR level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_error ( message )    logger_info (message)  Write an INFO level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with INFO level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_info ( message )    logger_warn (message)  Write an WARN level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with WARN level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_warn ( message )", 
            "title": "logger"
        }, 
        {
            "location": "/runtime-function-reference/#notifications", 
            "text": "notifications_send_id (new_notifications)  Send one or more in-app notifications to a user. Have a look at the section on  in-app notifications .  Parameters     Param  Type  Description      new_notifications  table  The Lua table array of notifications to send.     Example  local   subject   =   You ve unlocked level 100!  local   content   =   nk . json_encode ({ \n   reward_coins   =   1000  })  local   user_id   =   4c2ae592-b2a7-445e-98ec-697694478b1c   -- who to send  local   code   =   101  local   new_notifications   =   { \n   {   Subject   =   subject ,   Content   =   content ,   UserId   =   user_id ,   Code   =   code ,   Persistent   =   true }  }  nk . notifications_send_id ( new_notifications )", 
            "title": "notifications"
        }, 
        {
            "location": "/runtime-function-reference/#register-hooks", 
            "text": "register_after (func, msgname)  Register a function with the server which will be executed after every message with the specified message name.  This can be used to apply custom logic to standard features in the server. Similar to the  register_before  function but it will not block the execution pipeline. The logic will be executed in parallel to any response message sent back to a client.  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each  msgname  message.    msgname  string  The specific message name to execute the  func  function after.     Example  local   function   my_func ( context ,   payload ) \n   -- run some code  end  nk . register_after ( my_func ,   TFriendAdd )    register_before (func, msgname)  Register a function with the server which will be executed before every message with the specified message name.  For example  register_before(somefunc, \"TFriendAdd\")  will execute the function before the Friend Add message is executed by the server s message pipeline. This can be used to apply custom conditions to standard features in the server.  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each  msgname  message.    msgname  string  The specific message name to execute the  func  function before.      Note  The  func  should pass the  payload  back as a return argument so the pipeline can continue to execute the standard logic.   Example  local   function   my_func ( context ,   payload ) \n   -- run some code \n   return   payload   -- important!  end  nk . register_before ( my_func ,   TFriendAdd )    register_http (func, path)  Registers a HTTP endpoint within the server.   Warning  This should not be used to implement custom client functions use  register_rpc  instead.   This can be useful to define web callbacks to handle various Ad networks. It can also be used to enable server to server communication to ease the integration of Nakama server into various server stacks.  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each HTTP call.    path  string  The path that should be registered as a HTTP endpoint.      Note  The  func  can pass  nil  or  table  back as a return argument which will determine the HTTP response code returned.   Example  local   function   my_func ( context ,   payload ) \n   -- let s return the  context  as JSON back in the HTTP response body \n   return   context  end  nk . register_http ( my_func ,   /my_endpoint )  --  my_func  will be registered at  POST /runtime/my_endpoint   You can send a request to the HTTP endpoint with JSON and responses will be returned in JSON.  curl -X POST http://127.0.0.1:7350/runtime/my_endpoint?key = defaultkey  \\ \n     -d  { some :  data }   \\ \n     -H  Content-Type: application/json   \\ \n     -H  Accept: application/json    register_rpc (func, id)  Registers a function for use with client RPC to the server.  The ID can be any string identifier and is sent by the client. The ID is used to map the client RPC message to the specific function to execute.  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each RPC message.    id  string  The unique identifier used to register the  func  function for RPC.      Note  The  func  can pass  nil  or  string  back as a return argument which will returned as bytes in the RPC response.   Example  local   function   my_func ( context ,   payload ) \n   -- run some code  end  nk . register_rpc ( my_func ,   my_func_id )", 
            "title": "register hooks"
        }, 
        {
            "location": "/runtime-function-reference/#storage", 
            "text": "storage_fetch (record_keys)  Fetch one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      record_keys  table  A table array of record identifiers to be fetched.     Returns  A table array of the records result set.  Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   record_keys   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id }  }  local   records   =   nk . storage_fetch ( record_keys )  for   _ ,   r   in   ipairs ( records )  do \n   local   message   =   ( read: %q, write: %q, value: %q ): format ( r . PermissionRead ,   r . PermissionWrite ,   r . Value ) \n   print ( message )  end    storage_remove (record_keys)  Remove one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      record_keys  table  A table array of record identifiers to be removed.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   record_keys   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id }  }  nk . storage_remove ( record_keys )    storage_update (record_keys)  Update one or more records by their bucket/collection/keyname and optional user. Have a look at the section on  storage collections .  Parameters     Param  Type  Description      record_keys  table  A table array of records to update.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   now   =   os.time ()   *   1000   -- current time converted for msec  local   update_ops   =   { \n   { Op   =   init ,   Path   =   / ,   Value   =   {   progress   =   1   }}, \n   { Op   =   incr ,   Path   =   /progress ,   Value   =   1 }, \n   { Op   =   replace ,   Path   =   /updated_at ,   Value   =   now }  }  local   record_keys   =   { \n   { Bucket   =   b ,   Collection   =   c ,   Record   =   r ,   UserId   =   user_id ,   UpdateOps   =   update_ops }  }  nk . storage_update ( record_keys )    storage_write (new_records)  Write one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      new_records  table  A table array of new records to write.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   new_records   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id ,   Value   =   {}}, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id ,   Value   =   {}}, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id ,   Value   =   {}}  }  nk . storage_write ( new_records )", 
            "title": "storage"
        }, 
        {
            "location": "/runtime-function-reference/#users", 
            "text": "users_ban (user_ids)  Ban one or more users from the server.  Parameters     Param  Type  Description      user_ids  table  A table array of user IDs to be banned.     Example  local   user_ids   =   { 4c2ae592-b2a7-445e-98ec-697694478b1c }  local   status ,   result   =   pcall ( nk . users_ban ,   user_ids )  if   ( not   status )   then \n   print ( result )  end    users_fetch_handle (user_handles)  Fetch a set of users by handle.  Parameters     Param  Type  Description      user_handles  table  A table array of user handles to fetch.     Returns  A table array of the user result set.  Example  local   user_handles   =   { b7865e7e ,   c048ba7a }  local   users   =   nk . users_fetch_handle ( user_handles )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( id: %q, fullname: %q ): format ( u . Id ,   u . Fullname ) \n   print ( message )  end    users_fetch_id (user_ids)  Fetch one or more users by ID.  Parameters     Param  Type  Description      user_ids  table  A table array of user IDs to fetch.     Returns  A table array of the user result set.  Example  local   user_ids   =   { \n   3ea5608a-43c3-11e7-90f9-7b9397165f34 , \n   447524be-43c3-11e7-af09-3f7172f05936  }  local   users   =   nk . user_fetch_id ( user_ids )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( handle: %q, fullname: %q ): format ( u . Handle ,   u . Fullname ) \n   print ( message )  end    users_update (user_updates)  Update one or more users.  Parameters     Param  Type  Description      user_updates  table  The table array of users to update.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   user_updates   =   { \n   {   UserId   =   user_id ,   Metadata   =   {}   }  }  local   status ,   err   =   pcall ( nk . users_update ,   user_updates )  if   ( not   status )   then \n   print (( User update error: %q ): format ( err ))  end", 
            "title": "users"
        }, 
        {
            "location": "/runtime-function-reference/#uuid", 
            "text": "uuid_v4 ()  Generate a version 4 UUID.  Returns  The generated version 4 UUID identifier.  Example  local   uuid   =   nk . uuid_v4 ()  print ( uuid )", 
            "title": "uuid"
        }
    ]
}