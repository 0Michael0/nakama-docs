{
    "docs": [
        {
            "location": "/", 
            "text": "Nakama server\n\n\nDistributed server for social and realtime games and apps.\n\n\nNakama is a suite of APIs that will make you a more productive developer. It is built by \nHeroic Labs\n to handle the difficult but essential services that go into all social and realtime games and apps.\n\n\nThe server is designed to run at massive scale. Nakama works as a \ndistributed cluster\n so when your game or app gets featured in the App Store then all you need do is launch a few more instances and you'll handle the extra load with ease.\n\n\nDuring development you can run the server on your macOS, Linux, or Windows machine. When it's time to move into production either move into the cloud or use the Heroic Labs \nManaged cloud\n service.\n\n\nFeatures\n\n\nYou get to focus on building your project while the server handles all \nuser accounts\n, \nsocial profiles\n, \nrealtime chat\n, \ndata storage\n, \nmultiplayer matches\n, and lots more.\n\n\n\n  \n\n    \nUser accounts\n\n    \nEvery \nuser\n is registered and has a profile for other users to find and become friends with or join groups and chat.\n\n  \n\n  \n\n    \nFriends\n\n    \nFriends\n are a great way to build a social community.\n\n  \n\n\n\n\n\n\n  \n\n    \nGroups and Clans\n\n    \nA \ngroup\n brings together a bunch of users into a small community or team.\n\n  \n\n  \n\n    \nRealtime chat\n\n    \nUsers can \nchat\n with each other 1-on-1, as part of a group, and in chat rooms.\n\n  \n\n\n\n\n\n\n  \n\n    \nIn-app notifications\n\n    \nIn-app notifications\n make it easy to broadcast a message to one or more users.\n\n  \n\n  \n\n    \nLeaderboards\n\n    \nLeaderboards\n are a great way to add a social and competitive element to any game.\n\n  \n\n\n\n\n\n\n  \n\n    \nMatchmaker\n\n    \nThe \nmatchmaker\n makes it easy in realtime and turn-based games to find active opponents to play against.\n\n  \n\n  \n\n    \nMultiplayer\n\n    \nThe \nmultiplayer engine\n makes it easy for users to set up and join matches where they can rapidly exchange data with opponents.\n\n  \n\n\n\n\n\nServer-side code\n\n\nThe server integrates the Lua programming language as a fast embedded \ncode runtime\n.\n\n\nThis is useful to run custom logic which isn't running on the device or browser. The code you deploy with the server can be used immediately by clients so you can change behavior on the fly and add new features faster.\n\n\nNext steps\n\n\nBuild the next big hit for mobile, console, desktop, and web with Nakama. We have first-class game engine integration including \nUnity\n for ease of development.\n\n\nTo get the most out of Nakama you should follow the rest of this guide. And if you need help \nget in touch\n with the Heroic Labs team about our developer training.\n\n\nThe first step to building your project with Nakama is to \ninstall it\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#nakama-server", 
            "text": "Distributed server for social and realtime games and apps.  Nakama is a suite of APIs that will make you a more productive developer. It is built by  Heroic Labs  to handle the difficult but essential services that go into all social and realtime games and apps.  The server is designed to run at massive scale. Nakama works as a  distributed cluster  so when your game or app gets featured in the App Store then all you need do is launch a few more instances and you'll handle the extra load with ease.  During development you can run the server on your macOS, Linux, or Windows machine. When it's time to move into production either move into the cloud or use the Heroic Labs  Managed cloud  service.", 
            "title": "Nakama server"
        }, 
        {
            "location": "/#features", 
            "text": "You get to focus on building your project while the server handles all  user accounts ,  social profiles ,  realtime chat ,  data storage ,  multiplayer matches , and lots more.  \n   \n     User accounts \n     Every  user  is registered and has a profile for other users to find and become friends with or join groups and chat. \n   \n   \n     Friends \n     Friends  are a great way to build a social community. \n     \n   \n     Groups and Clans \n     A  group  brings together a bunch of users into a small community or team. \n   \n   \n     Realtime chat \n     Users can  chat  with each other 1-on-1, as part of a group, and in chat rooms. \n     \n   \n     In-app notifications \n     In-app notifications  make it easy to broadcast a message to one or more users. \n   \n   \n     Leaderboards \n     Leaderboards  are a great way to add a social and competitive element to any game. \n     \n   \n     Matchmaker \n     The  matchmaker  makes it easy in realtime and turn-based games to find active opponents to play against. \n   \n   \n     Multiplayer \n     The  multiplayer engine  makes it easy for users to set up and join matches where they can rapidly exchange data with opponents. \n     Server-side code  The server integrates the Lua programming language as a fast embedded  code runtime .  This is useful to run custom logic which isn't running on the device or browser. The code you deploy with the server can be used immediately by clients so you can change behavior on the fly and add new features faster.", 
            "title": "Features"
        }, 
        {
            "location": "/#next-steps", 
            "text": "Build the next big hit for mobile, console, desktop, and web with Nakama. We have first-class game engine integration including  Unity  for ease of development.  To get the most out of Nakama you should follow the rest of this guide. And if you need help  get in touch  with the Heroic Labs team about our developer training.  The first step to building your project with Nakama is to  install it .", 
            "title": "Next steps"
        }, 
        {
            "location": "/install-docker-quickstart/", 
            "text": "Docker quickstart\n\n\nTo start developing with Nakama, you\nll first need to install it on your development machine. It\ns straightforward and takes just a few minutes. In this guide we\nre going to focus on installing your Nakama development instance using Docker.\n\n\n\n\nRecommended Approach\n\n\nDocker is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a \nbinary\n to ensure all system resources are available to Nakama.\n\n\n\n\nThere is a single, minimal Nakama image that contains the Nakama binary. The basic format is:\n\n\ndocker run heroiclabs/nakama \ncommand\n \n[\noptions\n]\n\n\n\n\n\n\nInstalling Nakama using Docker is ideal for a few reasons, including:\n\n\n\n\n\n\nyou install to a pristine environment\n\n\n\n\n\n\nyou get everything you need in one go, including CockroachDB\n\n\n\n\n\n\nyou can take snapshots, re-install and remove Nakama without affecting your primary operating system.\n\n\n\n\n\n\nIt also means that the installation instructions are the same whether your development machine runs Windows, MacOS and Linux.\n\n\n\n\n\n\nWhat is Docker?\n\n\nIf you\nre new to Docker, then here\ns what you need to know: Docker is an open soure containerization tool that lets you create multiple distinct Linux environments, each separate from the other.\n\n\nIn a Docker container you run a suite of tools to do a particular job; in this case we\nll have one container running Nakama and another running CockroachDB. You can think of Docker containers as lightweight virtual machines.\n\n\n\n\n\n\nFollow this \nguide\n, if you are trying to install Docker on Mac, Linux and Windows 10 Pro edition.\n\n\n\n\n\n\nDocker Toolbox\n is needed, if you are installing Docker on Windows 7, 8 or 10 Home (non-Pro) editions.\n\n\n\n\n\n\nUse the \nDocker Store\n to find the right version of Docker Community Edition for your environment.\n\n\n\n\n\n\nConnecting the Nakama client\n\n\nOnce Nakama is running via Docker, use the following connection detail to configure your client to connect to the server:\n\n\nHost\n: \n127.0.0.1\n (or \nlocalhost\n)  \n\n\nPort\n : \n7350\n   \n\n\nSSL\n: \nFalse\n  \n\n\nServer Key\n: \ndefaultkey\n     \n\n\nIn the Unity client, you can create an \nNClient\n like this:\n\n\nINClient\n \nclient\n \n=\n \nnew\n \nNClient\n.\nBuilder\n(\ndefaultkey\n)\n\n    \n.\nHost\n(\n127.0.0.1\n)\n\n    \n.\nPort\n(\n7350\n)\n\n    \n.\nSSL\n(\nfalse\n)\n\n    \n.\nBuild\n();\n\n\n\n\n\n\nRunning Nakama\n\n\nYou can run Nakama and Cockroach without using Docker-Compose. This will mean you have greater control over how they are started, and various data volumes options but in return, you'll have to configure the two containers:\n\n\n# Let\ns pull and start CockroachDB\n\ndocker run --name\n=\ndb cockroachdb/cockroach start --insecure\n\n# Let\ns pull and migrate the database\n\ndocker run --link\n=\ndb heroiclabs/nakama migrate up --db root@db:26257\n\n# start Nakama server\n\ndocker run --link\n=\ndb -p \n7350\n:7350 heroiclabs/nakama --db root@db:26257\n\n\n\n\n\nUsing Docker-Compose\n\n\nDocker Compose simplifies running more than one Docker container in conjunction. For Nakama, we\nll need two containers: one for Nakama itself and one for the database it relies on, CockroachDB.\n\n\nYou can choose to configure the Nakama and CockroachDB containers without Docker Compose but we do not recommend it when you\nre starting out.\n\n\nDocker Compose uses YAML configuration files to declare which containers to use and how they should work together.\n\n\n1. Let\ns start by downloading the \nNakama Docker Compose file\n:\n\n\nwget https://raw.githubusercontent.com/heroiclabs/nakama/master/install/docker/docker-compose.yml\n\n\n\n\n\n\n\nWindows users\n\n\nIf you are trying to run Nakama via Docker-Compose on Windows, you'll need to make a small change to the downloaded \ndocker-compose.yml\n file. Follow this \ninstruction\n to bind the correct path.\n\n\n\n\nThis will download \ndocker-compose.yml\n to your current working directory.\n\n\n2. Next, we\nll ask Docker Compose to follow the instructions in the file we just downloaded:\n\n\ndocker-compose -f docker-compose.yml up\n\n\n\n\n\nDocker Compose will download the latest CockroachDB and Nakama images published on Docker Hub.\n\n\n3. You now have both CockroachDB and Nakama running on your machine, available at \n127.0.0.1:26257\n and \n127.0.0.1:7350\n respectively.\n\n\nData\n\n\nDocker containers are ephemeral by design: when you remove the container, you lose the data stored inside them.\n\n\nFor development purposes, we suggest that you bind a folder in the local machine's filesystem to the Docker file system. The easiest way to achieve this is by editing the \ndocker-compose.yml\n file:\n\n\n...\nnakama:\n  image: heroiclabs/nakama:latest\n  entrypoint:\n    - /bin/bash\n    - -ecx\n    - /nakama/nakama migrate up --db \nroot@cockroachdb:26257\n \n /nakama/nakama --db \nroot@cockroachdb:26257\n\n  volumes:\n\n    - ./nakama/data:/nakama/data # Edit this line\n\n  expose:\n    - \n7350\n\n...\n\n\n\n\n\n\n\nOn Mac and Linux systems, the path highlighted above will create a folder called \nnakama\n in the same directory as where you are running \ndocker-compose\n from.\n\n\nOn Windows, you'll need to update the path above so that Docker can bind the folder properly. A valid value can look like this: \nC:/users/\nusername\n/projects/docker\n.\n\n\n\n\n\n\nDrive Binding on Windows\n\n\nDocker will complain about an unshared Drive if the path above is not changed or is not available. The error looks like this:\n\n\nERROR: for bin_nakama_1 Cannot create container for service nakama: Drive has not been shared\n\n\nMake sure to change the line highlighted above to the correct path and restart Nakama.\n\n\n\n\nYou can put your Lua scripts in the \ndata/modules\n directory and restart Nakama using \ndocker-compose --restart\n.\n\n\nLogs\n\n\nLogs generated within the containers are printed to the console as part of the docker-compose output, and you can access them with \ndocker-compose logs\n from within the same the directory as the \ndocker-compose.yml\n file.\n\n\nStopping containers\n\n\nIf you need to temporarily pause the Docker containers, without losing the state of those containers, you have two options:\n\n\n\n\nIn the terminal where docker-compose is currently running, hit CTRL-C.\n\n\nOr run \ndocker-compose stop\n in the same directory as docker-compose.yml and all containers will be shut down gracefully.\n\n\n\n\nYou can re-activate them by running \ndocker-compose up\n.\n\n\nTo stop the containers and purge all stored data, run \ndocker-compose down\n.", 
            "title": "Docker quickstart"
        }, 
        {
            "location": "/install-docker-quickstart/#docker-quickstart", 
            "text": "To start developing with Nakama, you ll first need to install it on your development machine. It s straightforward and takes just a few minutes. In this guide we re going to focus on installing your Nakama development instance using Docker.   Recommended Approach  Docker is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a  binary  to ensure all system resources are available to Nakama.   There is a single, minimal Nakama image that contains the Nakama binary. The basic format is:  docker run heroiclabs/nakama  command   [ options ]   Installing Nakama using Docker is ideal for a few reasons, including:    you install to a pristine environment    you get everything you need in one go, including CockroachDB    you can take snapshots, re-install and remove Nakama without affecting your primary operating system.    It also means that the installation instructions are the same whether your development machine runs Windows, MacOS and Linux.", 
            "title": "Docker quickstart"
        }, 
        {
            "location": "/install-docker-quickstart/#what-is-docker", 
            "text": "If you re new to Docker, then here s what you need to know: Docker is an open soure containerization tool that lets you create multiple distinct Linux environments, each separate from the other.  In a Docker container you run a suite of tools to do a particular job; in this case we ll have one container running Nakama and another running CockroachDB. You can think of Docker containers as lightweight virtual machines.    Follow this  guide , if you are trying to install Docker on Mac, Linux and Windows 10 Pro edition.    Docker Toolbox  is needed, if you are installing Docker on Windows 7, 8 or 10 Home (non-Pro) editions.    Use the  Docker Store  to find the right version of Docker Community Edition for your environment.", 
            "title": "What is Docker?"
        }, 
        {
            "location": "/install-docker-quickstart/#connecting-the-nakama-client", 
            "text": "Once Nakama is running via Docker, use the following connection detail to configure your client to connect to the server:  Host :  127.0.0.1  (or  localhost )    Port  :  7350      SSL :  False     Server Key :  defaultkey        In the Unity client, you can create an  NClient  like this:  INClient   client   =   new   NClient . Builder ( defaultkey ) \n     . Host ( 127.0.0.1 ) \n     . Port ( 7350 ) \n     . SSL ( false ) \n     . Build ();", 
            "title": "Connecting the Nakama client"
        }, 
        {
            "location": "/install-docker-quickstart/#running-nakama", 
            "text": "You can run Nakama and Cockroach without using Docker-Compose. This will mean you have greater control over how they are started, and various data volumes options but in return, you'll have to configure the two containers:  # Let s pull and start CockroachDB \ndocker run --name = db cockroachdb/cockroach start --insecure # Let s pull and migrate the database \ndocker run --link = db heroiclabs/nakama migrate up --db root@db:26257 # start Nakama server \ndocker run --link = db -p  7350 :7350 heroiclabs/nakama --db root@db:26257", 
            "title": "Running Nakama"
        }, 
        {
            "location": "/install-docker-quickstart/#using-docker-compose", 
            "text": "Docker Compose simplifies running more than one Docker container in conjunction. For Nakama, we ll need two containers: one for Nakama itself and one for the database it relies on, CockroachDB.  You can choose to configure the Nakama and CockroachDB containers without Docker Compose but we do not recommend it when you re starting out.  Docker Compose uses YAML configuration files to declare which containers to use and how they should work together.  1. Let s start by downloading the  Nakama Docker Compose file :  wget https://raw.githubusercontent.com/heroiclabs/nakama/master/install/docker/docker-compose.yml   Windows users  If you are trying to run Nakama via Docker-Compose on Windows, you'll need to make a small change to the downloaded  docker-compose.yml  file. Follow this  instruction  to bind the correct path.   This will download  docker-compose.yml  to your current working directory.  2. Next, we ll ask Docker Compose to follow the instructions in the file we just downloaded:  docker-compose -f docker-compose.yml up  Docker Compose will download the latest CockroachDB and Nakama images published on Docker Hub.  3. You now have both CockroachDB and Nakama running on your machine, available at  127.0.0.1:26257  and  127.0.0.1:7350  respectively.", 
            "title": "Using Docker-Compose"
        }, 
        {
            "location": "/install-docker-quickstart/#data", 
            "text": "Docker containers are ephemeral by design: when you remove the container, you lose the data stored inside them.  For development purposes, we suggest that you bind a folder in the local machine's filesystem to the Docker file system. The easiest way to achieve this is by editing the  docker-compose.yml  file:  ...\nnakama:\n  image: heroiclabs/nakama:latest\n  entrypoint:\n    - /bin/bash\n    - -ecx\n    - /nakama/nakama migrate up --db  root@cockroachdb:26257    /nakama/nakama --db  root@cockroachdb:26257 \n  volumes:     - ./nakama/data:/nakama/data # Edit this line   expose:\n    -  7350 \n...   On Mac and Linux systems, the path highlighted above will create a folder called  nakama  in the same directory as where you are running  docker-compose  from.  On Windows, you'll need to update the path above so that Docker can bind the folder properly. A valid value can look like this:  C:/users/ username /projects/docker .    Drive Binding on Windows  Docker will complain about an unshared Drive if the path above is not changed or is not available. The error looks like this:  ERROR: for bin_nakama_1 Cannot create container for service nakama: Drive has not been shared  Make sure to change the line highlighted above to the correct path and restart Nakama.   You can put your Lua scripts in the  data/modules  directory and restart Nakama using  docker-compose --restart .", 
            "title": "Data"
        }, 
        {
            "location": "/install-docker-quickstart/#logs", 
            "text": "Logs generated within the containers are printed to the console as part of the docker-compose output, and you can access them with  docker-compose logs  from within the same the directory as the  docker-compose.yml  file.", 
            "title": "Logs"
        }, 
        {
            "location": "/install-docker-quickstart/#stopping-containers", 
            "text": "If you need to temporarily pause the Docker containers, without losing the state of those containers, you have two options:   In the terminal where docker-compose is currently running, hit CTRL-C.  Or run  docker-compose stop  in the same directory as docker-compose.yml and all containers will be shut down gracefully.   You can re-activate them by running  docker-compose up .  To stop the containers and purge all stored data, run  docker-compose down .", 
            "title": "Stopping containers"
        }, 
        {
            "location": "/install-binary/", 
            "text": "Binary install\n\n\nTo start developing with Nakama, you\nll first need to install it on your development machine. It\ns straightforward and takes just a few minutes. In this guide we\nre going to focus on installing your Nakama development instance using the binary executable.\n\n\n\n\nRecommended Approach\n\n\nDocker\n is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a binary to ensure all system resources are available to Nakama.\n\n\n\n\nRequirement\n\n\nThere are a few things you\nll need to know or have to hand before you install Nakama:\n\n\n\n\nOperating system: Windows 10 64-bit or above, MacOS 10.9 or above, or a modern Linux.\n\n\nArchitecture: X86_64 (64bit) processor architecture\n\n\nDependent software: Nakama relies on \nCockroachDB\n.\n\n\n\n\nInstall CockroachDB\n\n\nNakama relies on CockroachDB as the main and only database. Nakama uses CockroachDB to store server configuration, user data, chat messages and more persistent data.\n\n\nYou'll first need to install CockroachDB. Follow \nthis guide\n to install CockroachDB on your machine before installing Nakama.\n\n\n\n\nCockroachDB Alternative\n\n\nNakama unofficially supports \nPostgreSQL\n for environments where CockroachDB is not available.\n\n\nFor production settings, Nakama should be used with CockroachDB as queries are optimised for the way data is stored on the disk.\n\n\n\n\nInstall Nakama on MacOS\n\n\nYou\nll need to be running MacOS 10.9 (Mavericks) or greater to run Nakama.\n\n\nHomebrew\n\n\nHomebrew is a community-developed package manager for MacOS. If you\nve used \napt\n or \nyum\n on Linux systems then you\nll find Homebrew to be familiar.\n\n\nIf this is your first time using Homebrew, take a look at \ntheir website\n for installation instructions. Once you\nve installed Homebrew, follow the instructions below.\n\n\n# run our brew recipe to download the Nakama code and build the binary\n\nbrew install https://raw.githubusercontent.com/heroiclabs/nakama/master/install/local/nakama.rb\n\n\n\n\n\nNow you have Nakama running and you\nre ready to start developing.\n\n\nWithout Homebrew\n\n\nInstalling the binaries directly rather than via Homebrew allows you the flexibility of placing the server in your prefered workspace. However, installing through \nHomebrew\n is the simplest and easiest \n including for updates \n as everything is handled using the Homebrew workflow.\n\n\n1. Download the latest \nNakama tarball for MacOS\n.\n\n\n2. Then extract the binary:\n\n\n# replace the X.X.X with the version number you have downloaded\n\ntar xfz nakama-X.X.X-darwin-amd64.tar.gz\n\n\n\n\n\n3. Add the directory containing the binary to your \nPATH\n. This makes it easy to execute Nakama commands from your terminal.\n\n\ncp -i nakama /usr/local/bin\n\n\n\n\n\nYou may come across a permissions error. If you\nre happy to perform the action with root permissions then prefix the command with \nsudo\n.\n\n\n4. Migrate the database schema and then start Nakama\n\n\n# migrate schema\n\nnakama migration up\n\n# start the server and output logs to the terminal\n\nnakama --log.stdout\n\n\n\n\n\nInstall Nakama on Windows\n\n\nNakama is also available as a \nWindows binary\n. However, \nDocker\n is the recommended way to install CockroachDB and Nakama on Windows.\n\n\n\n\nDownload the binary\n and decompress the downloaded file.\n\n\nOpen a Powershell terminal and navigate to the folder you downloaded Nakama into.\n\n\nMigrate the database schema and then start Nakama\n\n\n\n\n# migrate schema\n\nnakama.exe migration up\n\n# start the server and output logs to the terminal\n\nnakama.exe --log.stdout\n\n\n\n\n\nInstall Nakama on Linux\n\n\nUsing \nDocker\n - This is the recommended approach. We will soon provide packages for various Linux package managers to ease the installation procedure. \nLet us know\n if you have requests for specific package managers.\n\n\nFirst you\nll need to create a suitable directory to install Nakama. To some extent its location will depend on your particular flavor of Linux and your own preferences.\n\n\n1. \nDownload the binary\n and decompress the downloaded file.\n\n\n2. Then extract the binary:\n\n\n# replace the X.X.X with the version number you have downloaded\n\ntar xfz nakama-X.X.X-linux-amd64.tar.gz\n\n\n\n\n\n3. Add the directory containing the binary to your \nPATH\n. This makes it easy to execute Nakama commands from your terminal.\n\n\ncp -i nakama /usr/local/bin\n\n\n\n\n\n4. Migrate the database schema and then start Nakama\n\n\n# migrate schema\n\nnakama migration up\n\n# start the server and output logs to the terminal\n\nnakama --log.stdout\n\n\n\n\n\nYou may come across a permissions error. If you\nre happy to perform the action with root permissions then prefix the command with \nsudo\n.\n\n\nsystemd\n\n\nIf you prefer to run Nakama as a service, and you\nre running a distro that uses systemd, you can optionally use the following script.\n\n\n\n\nNote\n\n\nYou\nll need to update the paths within the systemd configuration.\n\n\n\n\n1. Create the service file: \n/usr/lib/systemd/system/nakama.service\n\n\n[Unit]\n\n\nDescription\n=\nNakama server\n\n\n\n[Service]\n\n\nExecStart\n=\n/path/to/nakama --config /path/to/nakama/config.yml\n\n\nKillMode\n=\nprocess\n\n\n\n[Install]\n\n\nWantedBy\n=\nmulti-user.target\n\n\n\n\n\n\n2. Update file permission so it's readable by the \nsystemd\n daemon process\n\n\nsudo chmod \n644\n /usr/lib/systemd/system/nakama.service\n\n\n\n\n\n3. Enable and run the service\n\n\nsudo systemctl \nenable\n nakama\nsudo systemctl start nakama", 
            "title": "Binary install"
        }, 
        {
            "location": "/install-binary/#binary-install", 
            "text": "To start developing with Nakama, you ll first need to install it on your development machine. It s straightforward and takes just a few minutes. In this guide we re going to focus on installing your Nakama development instance using the binary executable.   Recommended Approach  Docker  is the quickest way to download and get started with Nakama for development purposes. For production settings, we recommend that you install Nakama as a binary to ensure all system resources are available to Nakama.", 
            "title": "Binary install"
        }, 
        {
            "location": "/install-binary/#requirement", 
            "text": "There are a few things you ll need to know or have to hand before you install Nakama:   Operating system: Windows 10 64-bit or above, MacOS 10.9 or above, or a modern Linux.  Architecture: X86_64 (64bit) processor architecture  Dependent software: Nakama relies on  CockroachDB .", 
            "title": "Requirement"
        }, 
        {
            "location": "/install-binary/#install-cockroachdb", 
            "text": "Nakama relies on CockroachDB as the main and only database. Nakama uses CockroachDB to store server configuration, user data, chat messages and more persistent data.  You'll first need to install CockroachDB. Follow  this guide  to install CockroachDB on your machine before installing Nakama.   CockroachDB Alternative  Nakama unofficially supports  PostgreSQL  for environments where CockroachDB is not available.  For production settings, Nakama should be used with CockroachDB as queries are optimised for the way data is stored on the disk.", 
            "title": "Install CockroachDB"
        }, 
        {
            "location": "/install-binary/#install-nakama-on-macos", 
            "text": "You ll need to be running MacOS 10.9 (Mavericks) or greater to run Nakama.", 
            "title": "Install Nakama on MacOS"
        }, 
        {
            "location": "/install-binary/#homebrew", 
            "text": "Homebrew is a community-developed package manager for MacOS. If you ve used  apt  or  yum  on Linux systems then you ll find Homebrew to be familiar.  If this is your first time using Homebrew, take a look at  their website  for installation instructions. Once you ve installed Homebrew, follow the instructions below.  # run our brew recipe to download the Nakama code and build the binary \nbrew install https://raw.githubusercontent.com/heroiclabs/nakama/master/install/local/nakama.rb  Now you have Nakama running and you re ready to start developing.", 
            "title": "Homebrew"
        }, 
        {
            "location": "/install-binary/#without-homebrew", 
            "text": "Installing the binaries directly rather than via Homebrew allows you the flexibility of placing the server in your prefered workspace. However, installing through  Homebrew  is the simplest and easiest   including for updates   as everything is handled using the Homebrew workflow.  1. Download the latest  Nakama tarball for MacOS .  2. Then extract the binary:  # replace the X.X.X with the version number you have downloaded \ntar xfz nakama-X.X.X-darwin-amd64.tar.gz  3. Add the directory containing the binary to your  PATH . This makes it easy to execute Nakama commands from your terminal.  cp -i nakama /usr/local/bin  You may come across a permissions error. If you re happy to perform the action with root permissions then prefix the command with  sudo .  4. Migrate the database schema and then start Nakama  # migrate schema \nnakama migration up # start the server and output logs to the terminal \nnakama --log.stdout", 
            "title": "Without Homebrew"
        }, 
        {
            "location": "/install-binary/#install-nakama-on-windows", 
            "text": "Nakama is also available as a  Windows binary . However,  Docker  is the recommended way to install CockroachDB and Nakama on Windows.   Download the binary  and decompress the downloaded file.  Open a Powershell terminal and navigate to the folder you downloaded Nakama into.  Migrate the database schema and then start Nakama   # migrate schema \nnakama.exe migration up # start the server and output logs to the terminal \nnakama.exe --log.stdout", 
            "title": "Install Nakama on Windows"
        }, 
        {
            "location": "/install-binary/#install-nakama-on-linux", 
            "text": "Using  Docker  - This is the recommended approach. We will soon provide packages for various Linux package managers to ease the installation procedure.  Let us know  if you have requests for specific package managers.  First you ll need to create a suitable directory to install Nakama. To some extent its location will depend on your particular flavor of Linux and your own preferences.  1.  Download the binary  and decompress the downloaded file.  2. Then extract the binary:  # replace the X.X.X with the version number you have downloaded \ntar xfz nakama-X.X.X-linux-amd64.tar.gz  3. Add the directory containing the binary to your  PATH . This makes it easy to execute Nakama commands from your terminal.  cp -i nakama /usr/local/bin  4. Migrate the database schema and then start Nakama  # migrate schema \nnakama migration up # start the server and output logs to the terminal \nnakama --log.stdout  You may come across a permissions error. If you re happy to perform the action with root permissions then prefix the command with  sudo .", 
            "title": "Install Nakama on Linux"
        }, 
        {
            "location": "/install-binary/#systemd", 
            "text": "If you prefer to run Nakama as a service, and you re running a distro that uses systemd, you can optionally use the following script.   Note  You ll need to update the paths within the systemd configuration.   1. Create the service file:  /usr/lib/systemd/system/nakama.service  [Unit]  Description = Nakama server  [Service]  ExecStart = /path/to/nakama --config /path/to/nakama/config.yml  KillMode = process  [Install]  WantedBy = multi-user.target   2. Update file permission so it's readable by the  systemd  daemon process  sudo chmod  644  /usr/lib/systemd/system/nakama.service  3. Enable and run the service  sudo systemctl  enable  nakama\nsudo systemctl start nakama", 
            "title": "systemd"
        }, 
        {
            "location": "/install-configuration/", 
            "text": "Configuration\n\n\nA YAML configuration file configures many aspects of how your Nakama server runs. You can run Nakama without specifying a configuration file and rely on the the default settings instead.\n\n\nSpecifying a config file\n\n\nYou can specify a configuration file at run-time using --config flag.\n\n\nnakama --config my-special-config.yml\n\n\n\n\n\nIf you are running Nakama via Docker-Compose, you'll need to bind a folder in your machine so that it's available in Docker. Follow this guide to \nsetup folder binding\n.\n\n\nCommon properties\n\n\nThere are a few configuration properties that need to be changed in most environments. The full list of configurations is at the \nbottom of the page\n.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nNakama node name (must be unique) - It will default to \nnakama-xxxx\n where \nxxxx\n is 4 random characters.\n\n\n\n\n\n\ndata_dir\n\n\nAn absolute path to a writeable folder where Nakama will store its data, including logs. Default value is the working directory that Nakama was started on.\n\n\n\n\n\n\nruntime.path\n\n\nPath of modules to scan and load. Defaults to \ndata_dir/modules\n.\n\n\n\n\n\n\ndatabase.address\n\n\nList of database nodes to connect to. It should follow the form of \nusername:password@address:port/dbname\n (\npostgres://\n protocol is appended to the path automatically). Defaults to \nroot@localhost:26257\n.\n\n\n\n\n\n\nsocket.server_key\n\n\nServer key to use to establish a connection to the server. Default value is \ndefaultkey\n.\n\n\n\n\n\n\nsession.encryption_key\n\n\nThe encryption key used to produce the client token. Default value is \ndefaultencryptionkey\n.\n\n\n\n\n\n\nruntime.http_key\n\n\nKey is used to protect the server's runtime HTTP invocations. Default value is \ndefaultkey\n.\n\n\n\n\n\n\n\n\n\n\nProduction settings\n\n\nYou must change the values of \nsocket.server_key\n, \nsession.encryption_key\n and \nruntime.http_key\n before you deploy Nakama to a live production environment.\n\n\nFollow the \nproduction settings deployment guide\n for more information.\n\n\n\n\nServer Configuration\n\n\nNakama has various configuration options to make it as flexible as possible for various use cases and deployment environments.\n\n\nNakama ships with sane default values for all config options, therefore you'll only need to override a subset of the options. You can also setup your own config file, and override the values in the config file via command-line flags. For instance, to override Runtime Path:\n\n\nnakama --runtime.path /tmp/my-modules\n\n\n\n\n\nIf fields are not specific, default values will be used. For more information on how to override flags, have a look at the \nserver command-line\n page.\n\n\n\n\nOverride configuration\n\n\nEvery configuration option can set from a config file, as a command line flag or both where the command-line argument takes precedence and will override the configuration values.\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nname\n\n\nNakama node name (must be unique) - It will default to \nnakama-xxxx\n where \nxxxx\n is 4 random characters.  This name is also used in the log files.\n\n\n\n\n\n\ndata_dir\n\n\ndata_dir\n\n\nAn absolute path to a writeable folder where Nakama will store its data, including logs. Default value is the working directory that Nakama was started on.\n\n\n\n\n\n\n\n\nLog\n\n\nNakama produces logs in JSON format so various systems can interact with the logs. By default they are written to log files inside \ndata_dir/logs\n folder.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstdout\n\n\nlog.stdout\n\n\nRedirect logs to console standard output. The log file will no longer be used. Default is \nfalse\n.\n\n\n\n\n\n\nverbose\n\n\nlog.verbose\n\n\nTurn on verbose logging. You'll see a lot more logs including debug-level information. This is useful for debugging purposes. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nDatabase\n\n\nNakama requires a CockroachDB server instance to be available. Nakama creates and manages its own database called \nnakama\n within the CockroachDB database.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddress\n\n\ndatabase.address\n\n\nList of database nodes to connect to. It should follow the form of \nusername:password@address:port/dbname\n (\npostgres://\n protocol is appended to the path automatically). Defaults to \nroot@localhost:26257\n.\n\n\n\n\n\n\nconn_max_lifetime_ms\n\n\ndatabase.conn_max_lifetime_ms\n\n\nTime in milliseconds to reuse a database connection before the connection is killed and a new one is created.. Default value is 60000.\n\n\n\n\n\n\nmax_open_conns\n\n\ndatabase.max_open_conns\n\n\nMaximum number of allowed open connections to the database. Default value is 0 (no limit).\n\n\n\n\n\n\nmax_idle_conns\n\n\ndatabase.max_idle_conns\n\n\nMaximum number of allowed open but unused connections to the database. Default value is 0 (no limit).\n\n\n\n\n\n\n\n\n\n\nDatabase addresses\n\n\nYou can pass in multiple database addresses to Nakama via command like:\n\n\nnakama --database.address \"root@db1:26257\" --database.address \"root@db2:26257\"\n\n\n\n\nRuntime\n\n\nOptions related to Lua-based runtime engine.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenv\n\n\nN/A\n\n\nList of Key-Value properties that are exposed to the Runtime scripts as environment variables.\n\n\n\n\n\n\npath\n\n\nruntime.path\n\n\nPath of modules for the server to scan and load at startup. Default value is \ndata_dir/modules\n.\n\n\n\n\n\n\nhttp_key\n\n\nruntime.http_key\n\n\nA key used to authenticate HTTP Runtime invocations. Default value is \ndefaultkey\n.\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nYou must change \nhttp_key\n before going live with your app!\n\n\n\n\nSocket\n\n\nOptions related to connection socket and transport protocol between the server and clients.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserver_key\n\n\nsocket.server_key\n\n\nServer key to use to establish a connection to the server. Default value is \ndefaultkey\n.\n\n\n\n\n\n\nport\n\n\nsocket.port\n\n\nThe port for accepting connections from the client, listening on all interfaces. Default value is 7350.\n\n\n\n\n\n\nmax_message_size_bytes\n\n\nsocket.max_message_size_bytes\n\n\nMaximum amount of data in bytes allowed to be read from the client socket per message. Default value is 1024.\n\n\n\n\n\n\nwrite_wait_ms\n\n\nsocket.write_wait_ms\n\n\nTime in milliseconds to wait for an ack from the client when writing data. Default value is 5000.\n\n\n\n\n\n\npong_wait_ms\n\n\nsocket.pong_wait_ms\n\n\nTime in milliseconds to wait for a pong message from the client after sending a ping. Default value is 10000.\n\n\n\n\n\n\nping_period_ms\n\n\nsocket.ping_period_ms\n\n\nTime in milliseconds to wait between client ping messages. This value must be less than the \npong_wait_ms\n. Default value is 8000.\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nYou must change \nserver_key\n before going live with your app!\n\n\n\n\nSession\n\n\nYou can change configuration options related to each user session, such as the encryption key used to create the token.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nencryption_key\n\n\nsession.encryption_key\n\n\nThe encryption key used to produce the client token. Default value is \ndefaultencryptionkey\n.\n\n\n\n\n\n\ntoken_expiry_ms\n\n\nsession.token_expiry_ms\n\n\nToken expiry in milliseconds. Default value is 60000.\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nYou must change \nencryption_key\n before going live with your app!\n\n\n\n\nPurchase\n\n\nNakama can verify in-app purchases by connecting to various stores and keeps a ledger of valid purchases. This is useful for preventing common in-app purchase replay attacks with valid receipts, as well as restoring purchases for user accounts as needed.\n\n\nApple\n\n\nApple In-App Purchase configuration\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npassword\n\n\napple.password\n\n\nYour application's shared secret.\n\n\n\n\n\n\nproduction\n\n\napple.production\n\n\nThe order in which the reciept verification server will be contacted. Set \nfalse\n for test apps and \ntrue\n for live apps. Default is \nfalse\n.\n\n\n\n\n\n\ntimeout_ms\n\n\napple.timeout_ms\n\n\nConnection timeout to connect to Apple services. Default value is 1500.\n\n\n\n\n\n\n\n\nGoogle\n\n\nGoogle In-App Purchase configuration\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npackage\n\n\ngoogle.package\n\n\nThe package name the app is published under, such as \ncom.myapp.testapp\n.\n\n\n\n\n\n\nservice_key_file\n\n\ngoogle.service_key_file\n\n\nAbsolute file path to the service key JSON file.\n\n\n\n\n\n\ntimeout_ms\n\n\ngoogle..timeout_ms\n\n\nConnection timeout to connect to Google services. Default value is 1500.\n\n\n\n\n\n\n\n\nSocial\n\n\nNakama can connect to various social networks to fetch user information. It can also act as a notification center for delivering and persisting notifications.\n\n\nNotification\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexpiry_ms\n\n\nnotification.expiry_ms\n\n\nSet notification expiry in milliseconds. Default value is 86400000 (1 day).\n\n\n\n\n\n\n\n\nSteam\n\n\nConfigure Steam network settings. Facebook, Google and GameCenter don't require any server settings.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npublisher_key\n\n\nsteam.publisher_key\n\n\nSteam Publisher Key.\n\n\n\n\n\n\napp_id\n\n\nsteam.app_id\n\n\nSteam App ID.\n\n\n\n\n\n\n\n\nDashboard\n\n\nThis section defined the configuration related for the embedded Dashboard.\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nport\n\n\ndashboard.port\n\n\nThe port for accepting connections to the dashboard, listening on all interfaces. Default value is 7351.\n\n\n\n\n\n\n\n\nCluster\n\n\nThis section configures how the nodes should connect to each to other form a cluster.\n\n\n\n\nNakama Enterprise Only\n\n\nThe following configuration options are available only in the Nakama Enterprise version of the Nakama server\n\n\nNakama is designed to run in production as a highly available cluster. You can start a cluster locally on your development machine if you\nre running \nNakama Enterprise\n. In production you can use either Nakama Enterprise or our \nManaged Cloud\n service.\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\njoin\n\n\ncluster.join\n\n\nList of hostname and port of other Nakama nodes to connect to.\n\n\n\n\n\n\ngossip_bindaddr\n\n\ncluster.gossip_bindaddr\n\n\nInterface address to bind Nakama to for discovery. By default listening on all interfaces.\n\n\n\n\n\n\ngossip_bindport\n\n\ncluster.gossip_bindport\n\n\nPort number to bind Nakama to for discovery. Default value is 7352.\n\n\n\n\n\n\nrpc_port\n\n\ncluster.rpc_port\n\n\nPort number to use to send data between Nakama nodes. Default value is 7353.\n\n\n\n\n\n\n\n\nExample File\n\n\nYou can use the entire file or just a subset of the configuration.\n\n\nname\n:\n \nnakama-node-1\n\n\ndata_dir\n:\n \n./data/\n\n\n\nlog\n:\n\n  \nstdout\n:\n \nfalse\n\n  \nverbose\n:\n \nfalse\n\n\n\ndatabase\n:\n\n  \naddress\n:\n\n    \n-\n \nroot@localhost:26257\n\n  \nconn_max_lifetime_ms\n:\n \n60000\n\n  \nmax_open_conns\n:\n \n0\n\n  \nmax_idle_conns\n:\n \n0\n\n\n\nruntime\n:\n\n  \nenv\n:\n\n    \n-\n \nexample_apikey\n:\n \nexample_apivalue\n\n  \npath\n:\n \n/tmp/modules/folders\n\n  \nhttp_key\n:\n \ndefaultkey\n\n\n\nsocket\n:\n\n  \nserver_key\n:\n \ndefaultkey\n\n  \nport\n:\n \n7350\n\n  \nmax_message_size_bytes\n:\n \n1024\n \n# bytes\n\n  \nwrite_wait_ms\n:\n \n5000\n\n  \npong_wait_ms\n:\n \n10000\n\n  \nping_period_ms\n:\n \n8000\n \n# Must be less than pong_wait_ms\n\n\n\nsession\n:\n\n  \nencryption_key\n:\n \ndefaultencryptionkey\n\n  \ntoken_expiry_ms\n:\n \n60000\n\n\n\npurchase\n:\n\n  \napple\n:\n\n    \npassword\n:\n \n\n    \nproduction\n:\n \nfalse\n\n    \nexpiry_ms\n:\n \n1500\n\n  \ngoogle\n:\n\n    \npackage\n:\n \n\n    \nservice_key_file\n:\n \n\n    \nexpiry_ms\n:\n \n1500\n\n\n\nsocial\n:\n\n  \nnotification\n:\n\n    \nexpiry_ms\n:\n \n86400000\n\n  \nsteam\n:\n\n    \npublisher_key\n:\n \n\n    \napp_id\n:\n \n0\n\n\n\ndashboard\n:\n\n  \nport\n:\n \n7351\n\n\n\ncluster\n:\n\n  \njoin\n:\n\n    \n-\n \n10.0.0.2:7352\n\n    \n-\n \n10.0.0.3:7352\n\n  \ngossip_bindaddr\n:\n \n0.0.0.0\n\n  \ngossip_bindport\n:\n \n7352\n\n  \nrpc_port\n:\n \n7353", 
            "title": "Configuration"
        }, 
        {
            "location": "/install-configuration/#configuration", 
            "text": "A YAML configuration file configures many aspects of how your Nakama server runs. You can run Nakama without specifying a configuration file and rely on the the default settings instead.", 
            "title": "Configuration"
        }, 
        {
            "location": "/install-configuration/#specifying-a-config-file", 
            "text": "You can specify a configuration file at run-time using --config flag.  nakama --config my-special-config.yml  If you are running Nakama via Docker-Compose, you'll need to bind a folder in your machine so that it's available in Docker. Follow this guide to  setup folder binding .", 
            "title": "Specifying a config file"
        }, 
        {
            "location": "/install-configuration/#common-properties", 
            "text": "There are a few configuration properties that need to be changed in most environments. The full list of configurations is at the  bottom of the page .     Parameter  Description      name  Nakama node name (must be unique) - It will default to  nakama-xxxx  where  xxxx  is 4 random characters.    data_dir  An absolute path to a writeable folder where Nakama will store its data, including logs. Default value is the working directory that Nakama was started on.    runtime.path  Path of modules to scan and load. Defaults to  data_dir/modules .    database.address  List of database nodes to connect to. It should follow the form of  username:password@address:port/dbname  ( postgres://  protocol is appended to the path automatically). Defaults to  root@localhost:26257 .    socket.server_key  Server key to use to establish a connection to the server. Default value is  defaultkey .    session.encryption_key  The encryption key used to produce the client token. Default value is  defaultencryptionkey .    runtime.http_key  Key is used to protect the server's runtime HTTP invocations. Default value is  defaultkey .      Production settings  You must change the values of  socket.server_key ,  session.encryption_key  and  runtime.http_key  before you deploy Nakama to a live production environment.  Follow the  production settings deployment guide  for more information.", 
            "title": "Common properties"
        }, 
        {
            "location": "/install-configuration/#server-configuration", 
            "text": "Nakama has various configuration options to make it as flexible as possible for various use cases and deployment environments.  Nakama ships with sane default values for all config options, therefore you'll only need to override a subset of the options. You can also setup your own config file, and override the values in the config file via command-line flags. For instance, to override Runtime Path:  nakama --runtime.path /tmp/my-modules  If fields are not specific, default values will be used. For more information on how to override flags, have a look at the  server command-line  page.   Override configuration  Every configuration option can set from a config file, as a command line flag or both where the command-line argument takes precedence and will override the configuration values.      Parameter  Flag  Description      name  name  Nakama node name (must be unique) - It will default to  nakama-xxxx  where  xxxx  is 4 random characters.  This name is also used in the log files.    data_dir  data_dir  An absolute path to a writeable folder where Nakama will store its data, including logs. Default value is the working directory that Nakama was started on.", 
            "title": "Server Configuration"
        }, 
        {
            "location": "/install-configuration/#log", 
            "text": "Nakama produces logs in JSON format so various systems can interact with the logs. By default they are written to log files inside  data_dir/logs  folder.     Parameter  Flag  Description      stdout  log.stdout  Redirect logs to console standard output. The log file will no longer be used. Default is  false .    verbose  log.verbose  Turn on verbose logging. You'll see a lot more logs including debug-level information. This is useful for debugging purposes. Default is  false .", 
            "title": "Log"
        }, 
        {
            "location": "/install-configuration/#database", 
            "text": "Nakama requires a CockroachDB server instance to be available. Nakama creates and manages its own database called  nakama  within the CockroachDB database.     Parameter  Flag  Description      address  database.address  List of database nodes to connect to. It should follow the form of  username:password@address:port/dbname  ( postgres://  protocol is appended to the path automatically). Defaults to  root@localhost:26257 .    conn_max_lifetime_ms  database.conn_max_lifetime_ms  Time in milliseconds to reuse a database connection before the connection is killed and a new one is created.. Default value is 60000.    max_open_conns  database.max_open_conns  Maximum number of allowed open connections to the database. Default value is 0 (no limit).    max_idle_conns  database.max_idle_conns  Maximum number of allowed open but unused connections to the database. Default value is 0 (no limit).      Database addresses  You can pass in multiple database addresses to Nakama via command like:  nakama --database.address \"root@db1:26257\" --database.address \"root@db2:26257\"", 
            "title": "Database"
        }, 
        {
            "location": "/install-configuration/#runtime", 
            "text": "Options related to Lua-based runtime engine.     Parameter  Flag  Description      env  N/A  List of Key-Value properties that are exposed to the Runtime scripts as environment variables.    path  runtime.path  Path of modules for the server to scan and load at startup. Default value is  data_dir/modules .    http_key  runtime.http_key  A key used to authenticate HTTP Runtime invocations. Default value is  defaultkey .      Important  You must change  http_key  before going live with your app!", 
            "title": "Runtime"
        }, 
        {
            "location": "/install-configuration/#socket", 
            "text": "Options related to connection socket and transport protocol between the server and clients.     Parameter  Flag  Description      server_key  socket.server_key  Server key to use to establish a connection to the server. Default value is  defaultkey .    port  socket.port  The port for accepting connections from the client, listening on all interfaces. Default value is 7350.    max_message_size_bytes  socket.max_message_size_bytes  Maximum amount of data in bytes allowed to be read from the client socket per message. Default value is 1024.    write_wait_ms  socket.write_wait_ms  Time in milliseconds to wait for an ack from the client when writing data. Default value is 5000.    pong_wait_ms  socket.pong_wait_ms  Time in milliseconds to wait for a pong message from the client after sending a ping. Default value is 10000.    ping_period_ms  socket.ping_period_ms  Time in milliseconds to wait between client ping messages. This value must be less than the  pong_wait_ms . Default value is 8000.      Important  You must change  server_key  before going live with your app!", 
            "title": "Socket"
        }, 
        {
            "location": "/install-configuration/#session", 
            "text": "You can change configuration options related to each user session, such as the encryption key used to create the token.     Parameter  Flag  Description      encryption_key  session.encryption_key  The encryption key used to produce the client token. Default value is  defaultencryptionkey .    token_expiry_ms  session.token_expiry_ms  Token expiry in milliseconds. Default value is 60000.      Important  You must change  encryption_key  before going live with your app!", 
            "title": "Session"
        }, 
        {
            "location": "/install-configuration/#purchase", 
            "text": "Nakama can verify in-app purchases by connecting to various stores and keeps a ledger of valid purchases. This is useful for preventing common in-app purchase replay attacks with valid receipts, as well as restoring purchases for user accounts as needed.", 
            "title": "Purchase"
        }, 
        {
            "location": "/install-configuration/#apple", 
            "text": "Apple In-App Purchase configuration     Parameter  Flag  Description      password  apple.password  Your application's shared secret.    production  apple.production  The order in which the reciept verification server will be contacted. Set  false  for test apps and  true  for live apps. Default is  false .    timeout_ms  apple.timeout_ms  Connection timeout to connect to Apple services. Default value is 1500.", 
            "title": "Apple"
        }, 
        {
            "location": "/install-configuration/#google", 
            "text": "Google In-App Purchase configuration     Parameter  Flag  Description      package  google.package  The package name the app is published under, such as  com.myapp.testapp .    service_key_file  google.service_key_file  Absolute file path to the service key JSON file.    timeout_ms  google..timeout_ms  Connection timeout to connect to Google services. Default value is 1500.", 
            "title": "Google"
        }, 
        {
            "location": "/install-configuration/#social", 
            "text": "Nakama can connect to various social networks to fetch user information. It can also act as a notification center for delivering and persisting notifications.", 
            "title": "Social"
        }, 
        {
            "location": "/install-configuration/#notification", 
            "text": "Parameter  Flag  Description      expiry_ms  notification.expiry_ms  Set notification expiry in milliseconds. Default value is 86400000 (1 day).", 
            "title": "Notification"
        }, 
        {
            "location": "/install-configuration/#steam", 
            "text": "Configure Steam network settings. Facebook, Google and GameCenter don't require any server settings.     Parameter  Flag  Description      publisher_key  steam.publisher_key  Steam Publisher Key.    app_id  steam.app_id  Steam App ID.", 
            "title": "Steam"
        }, 
        {
            "location": "/install-configuration/#dashboard", 
            "text": "This section defined the configuration related for the embedded Dashboard.     Parameter  Flag  Description      port  dashboard.port  The port for accepting connections to the dashboard, listening on all interfaces. Default value is 7351.", 
            "title": "Dashboard"
        }, 
        {
            "location": "/install-configuration/#cluster", 
            "text": "This section configures how the nodes should connect to each to other form a cluster.   Nakama Enterprise Only  The following configuration options are available only in the Nakama Enterprise version of the Nakama server  Nakama is designed to run in production as a highly available cluster. You can start a cluster locally on your development machine if you re running  Nakama Enterprise . In production you can use either Nakama Enterprise or our  Managed Cloud  service.      Parameter  Flag  Description      join  cluster.join  List of hostname and port of other Nakama nodes to connect to.    gossip_bindaddr  cluster.gossip_bindaddr  Interface address to bind Nakama to for discovery. By default listening on all interfaces.    gossip_bindport  cluster.gossip_bindport  Port number to bind Nakama to for discovery. Default value is 7352.    rpc_port  cluster.rpc_port  Port number to use to send data between Nakama nodes. Default value is 7353.", 
            "title": "Cluster"
        }, 
        {
            "location": "/install-configuration/#example-file", 
            "text": "You can use the entire file or just a subset of the configuration.  name :   nakama-node-1  data_dir :   ./data/  log : \n   stdout :   false \n   verbose :   false  database : \n   address : \n     -   root@localhost:26257 \n   conn_max_lifetime_ms :   60000 \n   max_open_conns :   0 \n   max_idle_conns :   0  runtime : \n   env : \n     -   example_apikey :   example_apivalue \n   path :   /tmp/modules/folders \n   http_key :   defaultkey  socket : \n   server_key :   defaultkey \n   port :   7350 \n   max_message_size_bytes :   1024   # bytes \n   write_wait_ms :   5000 \n   pong_wait_ms :   10000 \n   ping_period_ms :   8000   # Must be less than pong_wait_ms  session : \n   encryption_key :   defaultencryptionkey \n   token_expiry_ms :   60000  purchase : \n   apple : \n     password :   \n     production :   false \n     expiry_ms :   1500 \n   google : \n     package :   \n     service_key_file :   \n     expiry_ms :   1500  social : \n   notification : \n     expiry_ms :   86400000 \n   steam : \n     publisher_key :   \n     app_id :   0  dashboard : \n   port :   7351  cluster : \n   join : \n     -   10.0.0.2:7352 \n     -   10.0.0.3:7352 \n   gossip_bindaddr :   0.0.0.0 \n   gossip_bindport :   7352 \n   rpc_port :   7353", 
            "title": "Example File"
        }, 
        {
            "location": "/install-server-cli/", 
            "text": "Nakama Commands\n\n\nDay to day operation of Nakama is straightforward, requiring minimal intervention. There are just three nakama commands that you\nll need.\n\n\nRunning the \nnakama\n command by itself will start the server with the default configuration. You can \noverride the configuration\n used using command line flags.\n\n\nmigrate\n\n\nThe Nakama binary contains the schema and a way to upgrade an existing database schema. When you first run Nakama, you need to setup the database schema that Nakama interacts with. Similarly, when a new Nakama version is released, you need to migrate the data schema to that of the new version.\n\n\n\n\n\n\n\n\nCommand\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nmigrate up\n\n\nCreates and updates the database schema to the latest version required by nakama. By default, the schema is updated sequentially to the latest available.\n\n\n\n\n\n\nmigrate down\n\n\nDowngrades the database schema to the version requested. By default, it downgrades one schema change at a time.\n\n\n\n\n\n\nmigrate redo\n\n\nDowngrades one schema change, and re-applies the change.\n\n\n\n\n\n\nmigrate status\n\n\nProvides information on the schema's currently applied to the database, and if there any are unapplied schemas.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFlags\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\ndatabase.address\n\n\nDatabase node to connect to. It should follow the form of \nusername:password@address:port/dbname\n (\npostgres://\n protocol is appended to the path automatically). Defaults to \nroot@localhost:26257\n.\n\n\n\n\n\n\n--limit\n\n\nNumber of migrations to use when running either up, down, or redo.\n\n\n\n\n\n\n\n\ndoctor\n\n\nNakama ships with a built-in diagnostic tool which is particularly useful when you need support or otherwise are looking to diagnose an issue.\n\n\nRunning \nnakama doctor\n generates a report that details the server's configuration and environment. By default, the diagnostic tool looks for a Nakama node to connect to on the local machine, but this can be changed:\n\n\n\n\n\n\n\n\nFlags\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nThe host running the Nakama instance you want to diagnose. Default value is \n127.0.0.1\n.\n\n\n\n\n\n\nlimit\n\n\nDashboard port used by nakama. Default value is 7351.\n\n\n\n\n\n\n\n\nConfig override\n\n\nNakama comes with a default configuration which can be overriden by using a \nYML Configuration\n file or by passing command line flags like below:\n\n\nnakama --config path/to/config.yml --purchase.apple.password \nshared-secret\n --database.address root@localhost:26257 --database.address root@machine-2:26257 \n\n\n\n\n\n\n\nConfiguration Priority\n\n\nCommand line flags override options set in a config file. Configuration file overrides default config options.\n\n\n\n\nHave a look at \nConfiguration documentation\n for the complete list of configuration flags.", 
            "title": "Nakama CLI"
        }, 
        {
            "location": "/install-server-cli/#nakama-commands", 
            "text": "Day to day operation of Nakama is straightforward, requiring minimal intervention. There are just three nakama commands that you ll need.  Running the  nakama  command by itself will start the server with the default configuration. You can  override the configuration  used using command line flags.", 
            "title": "Nakama Commands"
        }, 
        {
            "location": "/install-server-cli/#migrate", 
            "text": "The Nakama binary contains the schema and a way to upgrade an existing database schema. When you first run Nakama, you need to setup the database schema that Nakama interacts with. Similarly, when a new Nakama version is released, you need to migrate the data schema to that of the new version.     Command  description      migrate up  Creates and updates the database schema to the latest version required by nakama. By default, the schema is updated sequentially to the latest available.    migrate down  Downgrades the database schema to the version requested. By default, it downgrades one schema change at a time.    migrate redo  Downgrades one schema change, and re-applies the change.    migrate status  Provides information on the schema's currently applied to the database, and if there any are unapplied schemas.        Flags  description      database.address  Database node to connect to. It should follow the form of  username:password@address:port/dbname  ( postgres://  protocol is appended to the path automatically). Defaults to  root@localhost:26257 .    --limit  Number of migrations to use when running either up, down, or redo.", 
            "title": "migrate"
        }, 
        {
            "location": "/install-server-cli/#doctor", 
            "text": "Nakama ships with a built-in diagnostic tool which is particularly useful when you need support or otherwise are looking to diagnose an issue.  Running  nakama doctor  generates a report that details the server's configuration and environment. By default, the diagnostic tool looks for a Nakama node to connect to on the local machine, but this can be changed:     Flags  description      host  The host running the Nakama instance you want to diagnose. Default value is  127.0.0.1 .    limit  Dashboard port used by nakama. Default value is 7351.", 
            "title": "doctor"
        }, 
        {
            "location": "/install-server-cli/#config-override", 
            "text": "Nakama comes with a default configuration which can be overriden by using a  YML Configuration  file or by passing command line flags like below:  nakama --config path/to/config.yml --purchase.apple.password  shared-secret  --database.address root@localhost:26257 --database.address root@machine-2:26257    Configuration Priority  Command line flags override options set in a config file. Configuration file overrides default config options.   Have a look at  Configuration documentation  for the complete list of configuration flags.", 
            "title": "Config override"
        }, 
        {
            "location": "/install-nakama-upgrade/", 
            "text": "Upgrade Nakama\n\n\nWhen upgrading to a new version of Nakama, you need to do three things before you run the newer version:\n\n\n\n\nCheck the \nRelease Notes\n, in case that version has specific upgrade requirements.\n\n\nMigrate your data to the format supported by the new version of Nakama.\n\n\nEnsure that the client version you\nre running is compatible with the server deployed.\n\n\n\n\nDocker\n\n\nAs new versions of Nakama, or CockroachDB, become available you might want to upgrade. Docker makes upgrading easy, as all you need to do is pull down a new version of the container image.\n\n\n\n\nSchema migration\n\n\nWhen upgrading to a new version of Nakama, the process in the \ndocker-compose.yml\n performs a migration of your data to the new database schema automatically.\n\n\n\n\nYou can pull down the most recent Nakama image and allow Docker Compose to perform the data migration.\n\n\ndocker-compose down \n# top and remove both the Nakama and CockroachDB containers\n\ndocker pull heroiclabs/nakama \n# download the latest Nakama image\n\ndocker-compose up \n# start the containers (both Nakama and CockroachDB) as fresh installss\n\n\n\n\n\n\nAnd, similarly, here\ns how to update the CockroachDB container:\n\n\ndocker pull cockroachdb/cockroach \n# download the latest CockroachDB image\n\n\n\n\n\n\nIf you'd like to explicity run a database schema migration, issue the following command:\n\n\ndocker run heroiclabs/nakama migrate up\n\n\n\n\n\nManual upgrade\n\n\nYou can upgrade one node or your whole cluster to the latest version of Nakama by following the instructions below.\n\n\nFor each node in the cluster:\n\n\n1. Stop Nakama. If you are using \nsystemd\n on a Linux setup, the command is:\n\n\nsudo systemctl stop nakama\n\n\n\n\n\n2. Back-up CockroachDB\n\n\ncockroach dump nakama \n mydatabackup.sql --insecure\n\n\n\n\n\n3. Download the \nlatest release\n and replace the \nnakama\n binary with the newer download.\n4. Upgrade the database schema with the following command:\n\n\nnakama migrate up\n\n\n\n\n\n\n\nDowngrade\n\n\nTo downgrade Nakama you can follow the same procedure, but replace the migration command with the following:\n\n\nnakama migrate down --limit 1\n\n\n\n\n5. Start Nakama and verify that the upgraded version is running.\n\n\nsudo systemctl start nakama", 
            "title": "Upgrades"
        }, 
        {
            "location": "/install-nakama-upgrade/#upgrade-nakama", 
            "text": "When upgrading to a new version of Nakama, you need to do three things before you run the newer version:   Check the  Release Notes , in case that version has specific upgrade requirements.  Migrate your data to the format supported by the new version of Nakama.  Ensure that the client version you re running is compatible with the server deployed.", 
            "title": "Upgrade Nakama"
        }, 
        {
            "location": "/install-nakama-upgrade/#docker", 
            "text": "As new versions of Nakama, or CockroachDB, become available you might want to upgrade. Docker makes upgrading easy, as all you need to do is pull down a new version of the container image.   Schema migration  When upgrading to a new version of Nakama, the process in the  docker-compose.yml  performs a migration of your data to the new database schema automatically.   You can pull down the most recent Nakama image and allow Docker Compose to perform the data migration.  docker-compose down  # top and remove both the Nakama and CockroachDB containers \ndocker pull heroiclabs/nakama  # download the latest Nakama image \ndocker-compose up  # start the containers (both Nakama and CockroachDB) as fresh installss   And, similarly, here s how to update the CockroachDB container:  docker pull cockroachdb/cockroach  # download the latest CockroachDB image   If you'd like to explicity run a database schema migration, issue the following command:  docker run heroiclabs/nakama migrate up", 
            "title": "Docker"
        }, 
        {
            "location": "/install-nakama-upgrade/#manual-upgrade", 
            "text": "You can upgrade one node or your whole cluster to the latest version of Nakama by following the instructions below.  For each node in the cluster:  1. Stop Nakama. If you are using  systemd  on a Linux setup, the command is:  sudo systemctl stop nakama  2. Back-up CockroachDB  cockroach dump nakama   mydatabackup.sql --insecure  3. Download the  latest release  and replace the  nakama  binary with the newer download.\n4. Upgrade the database schema with the following command:  nakama migrate up   Downgrade  To downgrade Nakama you can follow the same procedure, but replace the migration command with the following:  nakama migrate down --limit 1   5. Start Nakama and verify that the upgraded version is running.  sudo systemctl start nakama", 
            "title": "Manual upgrade"
        }, 
        {
            "location": "/unity-client-guide/", 
            "text": "Unity client guide\n\n\nThe official Unity client handles all communication in realtime with the server. It implements all features in the server and is compatible with Unity 5.4+. To work with our Unity client you'll need to install and setup \nUnity engine\n.\n\n\nDownload\n\n\nThe client is available on the \nUnity Asset store\n and also on \nGitHub releases\n. You can download \"Nakama.unitypackage\" which contains all source code and DLL dependencies required in the client code.\n\n\nFor upgrades you can see changes and enhancements in the \nCHANGELOG\n before you update to newer versions.\n\n\n\n\nHelp and contribute\n\n\nThe Unity client is \nopen source on GitHub\n. Please report issues and contribute code to help us improve it.\n\n\n\n\nInstall and setup\n\n\nWhen you've \ndownloaded\n the \"Nakama.unitypackage\" file you should drag or import it into your Unity editor project to install it. In the editor create a new C# script via the Assets menu with \"Assets \n Create \n C# Script\" and create an \nINClient\n.\n\n\nThe client object is used to execute all logic against the server.\n\n\nusing\n \nNakama\n;\n\n\nusing\n \nSystem.Collections\n;\n\n\nusing\n \nUnityEngine\n;\n\n\n\npublic\n \nclass\n \nNakamaSessionManager\n \n:\n \nMonoBehaviour\n \n{\n\n  \nvoid\n \nStart\n()\n \n{\n\n    \nINClient\n \nclient\n \n=\n \nnew\n \nNClient\n.\nBuilder\n(\ndefaultkey\n)\n\n        \n.\nHost\n(\n127.0.0.1\n)\n\n        \n.\nPort\n(\n7350\n)\n\n        \n.\nSSL\n(\nfalse\n)\n\n        \n.\nBuild\n();\n\n  \n}\n\n\n  \nvoid\n \nUpdate\n()\n \n{\n\n  \n}\n\n\n}\n\n\n\n\n\n\nWe use the builder pattern with many classes in the Unity client. Most classes have a \n\".Default()\"\n method to construct an object with default values.\n\n\n\n\nNote\n\n\nBy default the client uses connection settings \"127.0.0.1\" and 7350 to connect to a local Nakama server.\n\n\n\n\n// Quickly setup a client for a local server.\n\n\nINClient\n \nclient\n \n=\n \nNClient\n.\nDefault\n(\ndefaultkey\n);\n\n\n\n\n\n\nUnity uses an entity component system (ECS) which makes it simple to share the client across game objects. Have a read of \nControlling GameObjects Using Components\n for examples on how to share a C# object across your game objects.\n\n\nAuthenticate\n\n\nWith a client object you can authenticate against the server. You can register or login a \nuser\n with one of the \nauthenticate options\n.\n\n\nTo authenticate you should follow our recommended pattern in your client code:\n\n\n 1. Build an instance of the client.\n\n\nvar\n \nclient\n \n=\n \nNClient\n.\nDefault\n(\ndefaultkey\n);\n\n\n\n\n\n\n 2. Write a callback which will be used to connect to the server.\n\n\nvar\n \nsessionHandler\n \n=\n \ndelegate\n(\nINSession\n \nsession\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n  \nclient\n.\nConnect\n(\n_session\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n    \nDebug\n.\nLog\n(\nSession connected.\n);\n\n    \n// Store session for quick reconnects.\n\n    \nPlayerPrefs\n.\nSetString\n(\nnk.session\n,\n \nsession\n.\nToken\n);\n\n  \n});\n\n\n};\n\n\n\n\n\n\n 3. Restore a session for quick reconnects.\n\n\nvar\n \nsessionString\n \n=\n \nPlayerPrefs\n.\nGetString\n(\nnk.session\n);\n\n\nif\n \n(!\nstring\n.\nIsNullOrEmpty\n(\nsessionString\n))\n \n{\n\n  \nINSession\n \nsession\n \n=\n \nNSession\n.\nRestore\n(\nsessionString\n);\n\n  \nif\n \n(!\nsession\n.\nHasExpired\n(\nDateTime\n.\nUtcNow\n))\n \n{\n\n    \nsessionHandler\n(\nsession\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n 4. Login or register a user.\n\n\n\n\nTip\n\n\nIt's good practice to cache a device identifier when it's used to authenticate because they can change with device OS updates.\n\n\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\n// See if we have a cached id in PlayerPrefs.\n\n\nvar\n \nid\n \n=\n \nPlayerPrefs\n.\nGetString\n(\nnk.id\n);\n\n\nif\n \n(\nstring\n.\nIsNullOrEmpty\n(\nid\n))\n \n{\n\n  \n// We\nll use device ID for the user. See other authentication options.\n\n  \nid\n \n=\n \nSystemInfo\n.\ndeviceUniqueIdentifier\n;\n\n  \n// Store the identifier for next game start.\n\n  \nPlayerPrefs\n.\nSetString\n(\nnk.id\n,\n \nid\n);\n\n\n}\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nDevice\n(\nid\n);\n\n\n_client\n.\nLogin\n(\nmessage\n,\n \nSessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nUserNotFound\n)\n \n{\n\n    \n_client\n.\nRegister\n(\nmessage\n,\n \nSessionHandler\n,\n \nErrorHandler\n);\n\n  \n}\n \nelse\n \n{\n\n    \nErrorHandler\n(\nerr\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\nIn the code above we use \nNAuthenticateMessage.Device(id)\n but for other authentication options have a look at the \ncode examples\n.\n\n\nA \nfull example\n class with all code above is \nhere\n.\n\n\nSend messages\n\n\nWhen a user has been authenticated a session is used to connect with the server. You can then send messages for all the different features in the server.\n\n\nThis could be to \nadd friends\n, join \ngroups\n and \nchat\n, or submit scores in \nleaderboards\n, and \nmatchmake\n into a \nmultiplayer match\n. You can also execute remote code on the server via \nRPC\n.\n\n\nThe server also provides a \nstorage engine\n to keep save games and other records owned by users. We'll use storage to introduce how messages are sent.\n\n\nbyte\n[]\n \njson\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{\\\njsonkey\\\n:\\\njsonvalue\\\n}\n);\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNStorageWriteMessage\n.\nBuilder\n()\n\n    \n.\nWrite\n(\nsomeBucket\n,\n \nsomeCollection\n,\n \nmyRecord\n,\n \nstorageValue\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully wrote record.\n);\n\n\n},\n \n(\nINError\n \nerror\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nHave a look at other sections of documentation for more code examples.\n\n\nHandle events\n\n\nThe client uses event handlers which are called on various events received from the server.\n\n\nclient\n.\nOnError\n \n+=\n \n(\nNErrorEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINError\n \nerr\n \n=\n \nargs\n.\nError\n;\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nclient\n.\nOnDisconnect\n \n+=\n \n()\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nDisconnected from server.\n);\n\n\n}\n\n\n\n\n\n\nSome events only need to be implemented for the features you want to use.\n\n\n\n\n\n\n\n\nEvent handler\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOnDisconnect\n\n\nHandles an event for when the client is disconnected from the server.\n\n\n\n\n\n\nOnError\n\n\nReceives events about server errors.\n\n\n\n\n\n\nOnMatchData\n\n\nHandles \nrealtime match\n messages.\n\n\n\n\n\n\nOnMatchmakeMatched\n\n\nReceives events when the \nmatchmaker\n has found match participants.\n\n\n\n\n\n\nOnMatchPresence\n\n\nWhen in a \nrealtime match\n receives events for when users join or leave.\n\n\n\n\n\n\nOnNotification\n\n\nReceives live \nin-app notifications\n sent from the server.\n\n\n\n\n\n\nOnTopicMessage\n\n\nReceives \nrealtime chat\n messages sent by other users.\n\n\n\n\n\n\nOnTopicPresence\n\n\nSimilar to \"OnMatchPresence\" it handles join and leave events but within \nchat\n.\n\n\n\n\n\n\n\n\nMain thread dispatch\n\n\nThe client runs all callbacks on a socket thread separate to the Unity main thread.\n\n\nUnity engine does not let code which executes on another thread call one of it's APIs because of how it manages code execution within the game loop. This can causes errors which look something like \"\nSomeMethod> can only be called from the main thread\".\n\n\nWe recommend a simple pattern which can be used to run any code which calls \nUnityEngine\n APIs.\n\n\n 1. Add a queue to your script which manages a client.\n\n\nQueue\nAction\n \nexecutionQueue\n \n=\n \nnew\n \nQueue\nAction\n(\n1024\n);\n\n\n\n\n\n\n 2. Add code in your \nUpdate\n method so the queued actions are run.\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n,\n \nl\n \n=\n \nexecutionQueue\n.\nCount\n;\n \ni\n \n \nl\n;\n \ni\n++)\n \n{\n\n  \nexecutionQueue\n.\nDequeue\n()();\n\n\n}\n\n\n\n\n\n\n 3. Enqueue any code which uses a \nUnityEngine\n API.\n\n\nclient\n.\nConnect\n(\n_session\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nexecutionQueue\n.\nEnqueue\n(()\n \n=\n \n{\n\n    \nDebug\n.\nLog\n(\nSession connected.\n);\n\n    \n// Store session for quick reconnects.\n\n    \nPlayerPrefs\n.\nSetString\n(\nnk.session\n,\n \nsession\n.\nToken\n);\n \n// a UnityEngine API\n\n  \n});\n\n\n});\n\n\n\n\n\n\nYou can see a more advanced version of this pattern in the \nfull example\n.\n\n\n\n\nTip\n\n\nThis code pattern is not specific to our client. It's useful for any code which executes on a separate thread with Unity engine.\n\n\n\n\nManaged client\n\n\nIf you don't care about explicit control over which callbacks are dispatched on the Unity main thread you can wrap your code in a helper class which will handle it for you. The \n\"NManagedClient\"\n acts as a proxy for all callbacks.\n\n\nYou must call \n.ExecuteActions()\n in \nUpdate\n with the managed client or no callbacks will ever be run.\n\n\nusing\n \nNakama\n;\n\n\nusing\n \nSystem.Collections\n;\n\n\nusing\n \nUnityEngine\n;\n\n\n\npublic\n \nclass\n \nNakamaSessionManager\n \n:\n \nMonoBehaviour\n \n{\n\n  \nprivate\n \nINClient\n \n_client\n;\n\n\n  \npublic\n \nNakamaSessionManager\n()\n \n{\n\n    \nvar\n \nclient\n \n=\n \nNClient\n.\nDefault\n(\ndefaultkey\n);\n\n    \n_client\n \n=\n \nnew\n \nNManagedClient\n(\nclient\n);\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nUpdate\n()\n \n{\n\n\n    \n(\n_client\n \nas\n \nNManagedClient\n).\nExecuteActions\n();\n \n// important!\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThis makes code simpler to reason about but is slightly less performant than if you control exactly which callbacks use UnityEngine APIs and \"move them\" onto the main thread with an action queue.\n\n\nLogs and errors\n\n\nThe \nserver\n and the client can generate logs which are helpful to debug code. To log all messages sent by the client you can enable \"Trace\" when you build an \n\"INClient\"\n.\n\n\n#if UNITY_EDITOR\n\n\nINClient\n \nclient\n \n=\n \nnew\n \nNClient\n.\nBuilder\n(\ndefaultkey\n)\n\n    \n.\nTrace\n(\ntrue\n)\n\n    \n.\nBuild\n();\n\n\n#else\n\n\nINClient\n \nclient\n \n=\n \nNClient\n.\nDefault\n(\ndefaultkey\n);\n\n\n#endif\n\n\n\n\n\n\nThe \n#if\n preprocessor directives is used so trace is only enabled in Unity editor builds. For more complex directives with debug vs release builds have a look at \nPlatform dependent compilation\n.\n\n\nEvery error in the Unity client implements the \n\"INError\"\n interface. It contains details on the source and content of an error:\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerror\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nError code {0}\n,\n \nerror\n.\nCode\n);\n\n  \nDebug\n.\nLogFormat\n(\nError message {0}\n,\n \nerror\n.\nMessage\n);\n\n\n};\n\n\n\n\n\n\n\n\nFull example\n\n\nAn example class used to manage a session with the Unity client.\n\n\nusing\n \nNakama\n;\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nSystem.Collections\n;\n\n\nusing\n \nSystem.Collections.Generic\n;\n\n\nusing\n \nUnityEngine\n;\n\n\n\npublic\n \nclass\n \nNakamaSessionManager\n \n:\n \nMonoBehaviour\n \n{\n\n  \nprivate\n \nINClient\n \n_client\n;\n\n  \nprivate\n \nINSession\n \n_session\n;\n\n\n  \nprivate\n \nQueue\nIEnumerator\n \n_executionQueue\n;\n\n\n  \npublic\n \nNakamaSessionManager\n()\n \n{\n\n    \n_client\n \n=\n \nNClient\n.\nDefault\n(\ndefaultkey\n);\n\n    \n_executionQueue\n \n=\n \nnew\n \nQueue\nIEnumerator\n(\n1024\n);\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nAwake\n()\n \n{\n\n    \nRestoreSessionAndConnect\n();\n\n    \nif\n \n(\n_session\n \n==\n \nnull\n)\n \n{\n\n      \nLoginOrRegister\n();\n\n    \n}\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nRestoreSessionAndConnect\n()\n \n{\n\n    \n// Lets check if we can restore a cached session.\n\n    \nvar\n \nsessionString\n \n=\n \nPlayerPrefs\n.\nGetString\n(\nnk.session\n);\n\n    \nif\n \n(\nstring\n.\nIsNullOrEmpty\n(\nsessionString\n))\n \n{\n\n      \nreturn\n;\n \n// We have no session to restore.\n\n    \n}\n\n\n    \nvar\n \nsession\n \n=\n \nNSession\n.\nRestore\n(\nsessionString\n);\n\n    \nif\n \n(\nsession\n.\nHasExpired\n(\nDateTime\n.\nUtcNow\n))\n \n{\n\n      \nreturn\n;\n \n// We can\nt restore an expired session.\n\n    \n}\n\n\n    \nSessionHandler\n(\nsession\n);\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nLoginOrRegister\n()\n \n{\n\n    \n// See if we have a cached id in PlayerPrefs.\n\n    \nvar\n \nid\n \n=\n \nPlayerPrefs\n.\nGetString\n(\nnk.id\n);\n\n    \nif\n \n(\nstring\n.\nIsNullOrEmpty\n(\nid\n))\n \n{\n\n      \n// We\nll use device ID for the user. See other authentication options.\n\n      \nid\n \n=\n \nSystemInfo\n.\ndeviceUniqueIdentifier\n;\n\n      \n// Store the identifier for next game start.\n\n      \nPlayerPrefs\n.\nSetString\n(\nnk.id\n,\n \nid\n);\n\n    \n}\n\n\n    \n// Use whichever one of the authentication options you want.\n\n    \nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nDevice\n(\nid\n);\n\n    \n_client\n.\nLogin\n(\nmessage\n,\n \nSessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n      \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nUserNotFound\n)\n \n{\n\n        \n_client\n.\nRegister\n(\nmessage\n,\n \nSessionHandler\n,\n \nErrorHandler\n);\n\n      \n}\n \nelse\n \n{\n\n        \nErrorHandler\n(\nerr\n);\n\n      \n}\n\n    \n});\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nSessionHandler\n(\nINSession\n \nsession\n)\n \n{\n\n    \n_session\n \n=\n \nsession\n;\n\n    \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n    \n_client\n.\nConnect\n(\n_session\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n      \n// We enqueue callbacks which contain code which must be dispatched on\n\n      \n// the Unity main thread.\n\n      \nEnqueue\n(()\n \n=\n \n{\n\n        \nDebug\n.\nLog\n(\nSession connected.\n);\n\n        \n// Store session for quick reconnects.\n\n        \nPlayerPrefs\n.\nSetString\n(\nnk.session\n,\n \nsession\n.\nToken\n);\n\n      \n});\n\n    \n});\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nOnApplicationQuit\n()\n \n{\n\n    \nif\n \n(\n_session\n \n!=\n \nnull\n)\n \n{\n\n      \n_client\n.\nDisconnect\n();\n\n    \n}\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nEnqueue\n(\nAction\n \naction\n)\n \n{\n\n    \nlock\n \n(\n_executionQueue\n)\n \n{\n\n      \nif\n \n(\n_executionQueue\n.\nCount\n \n \n1024\n)\n \n{\n\n        \n// Prevent a memory leak if game code can\nt process events fast.\n\n        \n_client\n.\nDisconnect\n();\n\n      \n}\n \nelse\n \n{\n\n        \n_executionQueue\n.\nEnqueue\n(\nActionWrapper\n(\naction\n));\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n  \nprivate\n \nIEnumerator\n \nActionWrapper\n(\nAction\n \naction\n)\n \n{\n\n    \naction\n();\n\n    \nyield\n \nreturn\n \nnull\n;\n\n  \n}\n\n\n  \nprivate\n \nstatic\n \nvoid\n \nErrorHandler\n(\nINError\n \nerr\n)\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n}\n\n\n}", 
            "title": "Unity client guide"
        }, 
        {
            "location": "/unity-client-guide/#unity-client-guide", 
            "text": "The official Unity client handles all communication in realtime with the server. It implements all features in the server and is compatible with Unity 5.4+. To work with our Unity client you'll need to install and setup  Unity engine .", 
            "title": "Unity client guide"
        }, 
        {
            "location": "/unity-client-guide/#download", 
            "text": "The client is available on the  Unity Asset store  and also on  GitHub releases . You can download \"Nakama.unitypackage\" which contains all source code and DLL dependencies required in the client code.  For upgrades you can see changes and enhancements in the  CHANGELOG  before you update to newer versions.   Help and contribute  The Unity client is  open source on GitHub . Please report issues and contribute code to help us improve it.", 
            "title": "Download"
        }, 
        {
            "location": "/unity-client-guide/#install-and-setup", 
            "text": "When you've  downloaded  the \"Nakama.unitypackage\" file you should drag or import it into your Unity editor project to install it. In the editor create a new C# script via the Assets menu with \"Assets   Create   C# Script\" and create an  INClient .  The client object is used to execute all logic against the server.  using   Nakama ;  using   System.Collections ;  using   UnityEngine ;  public   class   NakamaSessionManager   :   MonoBehaviour   { \n   void   Start ()   { \n     INClient   client   =   new   NClient . Builder ( defaultkey ) \n         . Host ( 127.0.0.1 ) \n         . Port ( 7350 ) \n         . SSL ( false ) \n         . Build (); \n   } \n\n   void   Update ()   { \n   }  }   We use the builder pattern with many classes in the Unity client. Most classes have a  \".Default()\"  method to construct an object with default values.   Note  By default the client uses connection settings \"127.0.0.1\" and 7350 to connect to a local Nakama server.   // Quickly setup a client for a local server.  INClient   client   =   NClient . Default ( defaultkey );   Unity uses an entity component system (ECS) which makes it simple to share the client across game objects. Have a read of  Controlling GameObjects Using Components  for examples on how to share a C# object across your game objects.", 
            "title": "Install and setup"
        }, 
        {
            "location": "/unity-client-guide/#authenticate", 
            "text": "With a client object you can authenticate against the server. You can register or login a  user  with one of the  authenticate options .  To authenticate you should follow our recommended pattern in your client code:   1. Build an instance of the client.  var   client   =   NClient . Default ( defaultkey );    2. Write a callback which will be used to connect to the server.  var   sessionHandler   =   delegate ( INSession   session )   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token ); \n   client . Connect ( _session ,   ( bool   done )   =   { \n     Debug . Log ( Session connected. ); \n     // Store session for quick reconnects. \n     PlayerPrefs . SetString ( nk.session ,   session . Token ); \n   });  };    3. Restore a session for quick reconnects.  var   sessionString   =   PlayerPrefs . GetString ( nk.session );  if   (! string . IsNullOrEmpty ( sessionString ))   { \n   INSession   session   =   NSession . Restore ( sessionString ); \n   if   (! session . HasExpired ( DateTime . UtcNow ))   { \n     sessionHandler ( session ); \n   }  }    4. Login or register a user.   Tip  It's good practice to cache a device identifier when it's used to authenticate because they can change with device OS updates.   var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  // See if we have a cached id in PlayerPrefs.  var   id   =   PlayerPrefs . GetString ( nk.id );  if   ( string . IsNullOrEmpty ( id ))   { \n   // We ll use device ID for the user. See other authentication options. \n   id   =   SystemInfo . deviceUniqueIdentifier ; \n   // Store the identifier for next game start. \n   PlayerPrefs . SetString ( nk.id ,   id );  }  var   message   =   NAuthenticateMessage . Device ( id );  _client . Login ( message ,   SessionHandler ,   ( INError   err )   =   { \n   if   ( err . Code   ==   ErrorCode . UserNotFound )   { \n     _client . Register ( message ,   SessionHandler ,   ErrorHandler ); \n   }   else   { \n     ErrorHandler ( err ); \n   }  });   In the code above we use  NAuthenticateMessage.Device(id)  but for other authentication options have a look at the  code examples .  A  full example  class with all code above is  here .", 
            "title": "Authenticate"
        }, 
        {
            "location": "/unity-client-guide/#send-messages", 
            "text": "When a user has been authenticated a session is used to connect with the server. You can then send messages for all the different features in the server.  This could be to  add friends , join  groups  and  chat , or submit scores in  leaderboards , and  matchmake  into a  multiplayer match . You can also execute remote code on the server via  RPC .  The server also provides a  storage engine  to keep save games and other records owned by users. We'll use storage to introduce how messages are sent.  byte []   json   =   Encoding . UTF8 . GetBytes ( {\\ jsonkey\\ :\\ jsonvalue\\ } );  var   message   =   new   NStorageWriteMessage . Builder () \n     . Write ( someBucket ,   someCollection ,   myRecord ,   storageValue ) \n     . Build ();  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully wrote record. );  },   ( INError   error )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   Have a look at other sections of documentation for more code examples.", 
            "title": "Send messages"
        }, 
        {
            "location": "/unity-client-guide/#handle-events", 
            "text": "The client uses event handlers which are called on various events received from the server.  client . OnError   +=   ( NErrorEventArgs   args )   =   { \n   INError   err   =   args . Error ; \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  client . OnDisconnect   +=   ()   =   { \n   Debug . Log ( Disconnected from server. );  }   Some events only need to be implemented for the features you want to use.     Event handler  Description      OnDisconnect  Handles an event for when the client is disconnected from the server.    OnError  Receives events about server errors.    OnMatchData  Handles  realtime match  messages.    OnMatchmakeMatched  Receives events when the  matchmaker  has found match participants.    OnMatchPresence  When in a  realtime match  receives events for when users join or leave.    OnNotification  Receives live  in-app notifications  sent from the server.    OnTopicMessage  Receives  realtime chat  messages sent by other users.    OnTopicPresence  Similar to \"OnMatchPresence\" it handles join and leave events but within  chat .", 
            "title": "Handle events"
        }, 
        {
            "location": "/unity-client-guide/#main-thread-dispatch", 
            "text": "The client runs all callbacks on a socket thread separate to the Unity main thread.  Unity engine does not let code which executes on another thread call one of it's APIs because of how it manages code execution within the game loop. This can causes errors which look something like \" SomeMethod> can only be called from the main thread\".  We recommend a simple pattern which can be used to run any code which calls  UnityEngine  APIs.   1. Add a queue to your script which manages a client.  Queue Action   executionQueue   =   new   Queue Action ( 1024 );    2. Add code in your  Update  method so the queued actions are run.  for   ( int   i   =   0 ,   l   =   executionQueue . Count ;   i     l ;   i ++)   { \n   executionQueue . Dequeue ()();  }    3. Enqueue any code which uses a  UnityEngine  API.  client . Connect ( _session ,   ( bool   done )   =   { \n   executionQueue . Enqueue (()   =   { \n     Debug . Log ( Session connected. ); \n     // Store session for quick reconnects. \n     PlayerPrefs . SetString ( nk.session ,   session . Token );   // a UnityEngine API \n   });  });   You can see a more advanced version of this pattern in the  full example .   Tip  This code pattern is not specific to our client. It's useful for any code which executes on a separate thread with Unity engine.", 
            "title": "Main thread dispatch"
        }, 
        {
            "location": "/unity-client-guide/#managed-client", 
            "text": "If you don't care about explicit control over which callbacks are dispatched on the Unity main thread you can wrap your code in a helper class which will handle it for you. The  \"NManagedClient\"  acts as a proxy for all callbacks.  You must call  .ExecuteActions()  in  Update  with the managed client or no callbacks will ever be run.  using   Nakama ;  using   System.Collections ;  using   UnityEngine ;  public   class   NakamaSessionManager   :   MonoBehaviour   { \n   private   INClient   _client ; \n\n   public   NakamaSessionManager ()   { \n     var   client   =   NClient . Default ( defaultkey ); \n     _client   =   new   NManagedClient ( client ); \n   } \n\n   private   void   Update ()   {       ( _client   as   NManagedClient ). ExecuteActions ();   // important!     }  }   This makes code simpler to reason about but is slightly less performant than if you control exactly which callbacks use UnityEngine APIs and \"move them\" onto the main thread with an action queue.", 
            "title": "Managed client"
        }, 
        {
            "location": "/unity-client-guide/#logs-and-errors", 
            "text": "The  server  and the client can generate logs which are helpful to debug code. To log all messages sent by the client you can enable \"Trace\" when you build an  \"INClient\" .  #if UNITY_EDITOR  INClient   client   =   new   NClient . Builder ( defaultkey ) \n     . Trace ( true ) \n     . Build ();  #else  INClient   client   =   NClient . Default ( defaultkey );  #endif   The  #if  preprocessor directives is used so trace is only enabled in Unity editor builds. For more complex directives with debug vs release builds have a look at  Platform dependent compilation .  Every error in the Unity client implements the  \"INError\"  interface. It contains details on the source and content of an error:  var   errorHandler   =   delegate ( INError   error )   { \n   Debug . LogFormat ( Error code {0} ,   error . Code ); \n   Debug . LogFormat ( Error message {0} ,   error . Message );  };", 
            "title": "Logs and errors"
        }, 
        {
            "location": "/unity-client-guide/#full-example", 
            "text": "An example class used to manage a session with the Unity client.  using   Nakama ;  using   System ;  using   System.Collections ;  using   System.Collections.Generic ;  using   UnityEngine ;  public   class   NakamaSessionManager   :   MonoBehaviour   { \n   private   INClient   _client ; \n   private   INSession   _session ; \n\n   private   Queue IEnumerator   _executionQueue ; \n\n   public   NakamaSessionManager ()   { \n     _client   =   NClient . Default ( defaultkey ); \n     _executionQueue   =   new   Queue IEnumerator ( 1024 ); \n   } \n\n   private   void   Awake ()   { \n     RestoreSessionAndConnect (); \n     if   ( _session   ==   null )   { \n       LoginOrRegister (); \n     } \n   } \n\n   private   void   RestoreSessionAndConnect ()   { \n     // Lets check if we can restore a cached session. \n     var   sessionString   =   PlayerPrefs . GetString ( nk.session ); \n     if   ( string . IsNullOrEmpty ( sessionString ))   { \n       return ;   // We have no session to restore. \n     } \n\n     var   session   =   NSession . Restore ( sessionString ); \n     if   ( session . HasExpired ( DateTime . UtcNow ))   { \n       return ;   // We can t restore an expired session. \n     } \n\n     SessionHandler ( session ); \n   } \n\n   private   void   LoginOrRegister ()   { \n     // See if we have a cached id in PlayerPrefs. \n     var   id   =   PlayerPrefs . GetString ( nk.id ); \n     if   ( string . IsNullOrEmpty ( id ))   { \n       // We ll use device ID for the user. See other authentication options. \n       id   =   SystemInfo . deviceUniqueIdentifier ; \n       // Store the identifier for next game start. \n       PlayerPrefs . SetString ( nk.id ,   id ); \n     } \n\n     // Use whichever one of the authentication options you want. \n     var   message   =   NAuthenticateMessage . Device ( id ); \n     _client . Login ( message ,   SessionHandler ,   ( INError   err )   =   { \n       if   ( err . Code   ==   ErrorCode . UserNotFound )   { \n         _client . Register ( message ,   SessionHandler ,   ErrorHandler ); \n       }   else   { \n         ErrorHandler ( err ); \n       } \n     }); \n   } \n\n   private   void   SessionHandler ( INSession   session )   { \n     _session   =   session ; \n     Debug . LogFormat ( Session:  {0} . ,   session . Token ); \n     _client . Connect ( _session ,   ( bool   done )   =   { \n       // We enqueue callbacks which contain code which must be dispatched on \n       // the Unity main thread. \n       Enqueue (()   =   { \n         Debug . Log ( Session connected. ); \n         // Store session for quick reconnects. \n         PlayerPrefs . SetString ( nk.session ,   session . Token ); \n       }); \n     }); \n   } \n\n   private   void   OnApplicationQuit ()   { \n     if   ( _session   !=   null )   { \n       _client . Disconnect (); \n     } \n   } \n\n   private   void   Enqueue ( Action   action )   { \n     lock   ( _executionQueue )   { \n       if   ( _executionQueue . Count     1024 )   { \n         // Prevent a memory leak if game code can t process events fast. \n         _client . Disconnect (); \n       }   else   { \n         _executionQueue . Enqueue ( ActionWrapper ( action )); \n       } \n     } \n   } \n\n   private   IEnumerator   ActionWrapper ( Action   action )   { \n     action (); \n     yield   return   null ; \n   } \n\n   private   static   void   ErrorHandler ( INError   err )   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   }  }", 
            "title": "Full example"
        }, 
        {
            "location": "/javascript-client-guide/", 
            "text": "JavaScript client guide\n\n\nAn official JavaScript client is in development right now and planned for launch on September 1st.\n\n\nWe'll announce it on \nTwitter\n and on our \nblog\n when it's ready. It will be open-source on \nGitHub\n and available on NPM.\n\n\n\n\nLoading...", 
            "title": "JavaScript client guide"
        }, 
        {
            "location": "/javascript-client-guide/#javascript-client-guide", 
            "text": "An official JavaScript client is in development right now and planned for launch on September 1st.  We'll announce it on  Twitter  and on our  blog  when it's ready. It will be open-source on  GitHub  and available on NPM.   Loading...", 
            "title": "JavaScript client guide"
        }, 
        {
            "location": "/swift-ios-client-guide/", 
            "text": "Swift/iOS client guide\n\n\nAn official Swift client is in development right now and planned for launch on September 1st.\n\n\nWe'll announce it on \nTwitter\n and on our \nblog\n when it's ready. It will be open-source on \nGitHub\n and available as a Swift package.\n\n\n\n\nLoading...", 
            "title": "Swift/iOS client guide"
        }, 
        {
            "location": "/swift-ios-client-guide/#swiftios-client-guide", 
            "text": "An official Swift client is in development right now and planned for launch on September 1st.  We'll announce it on  Twitter  and on our  blog  when it's ready. It will be open-source on  GitHub  and available as a Swift package.   Loading...", 
            "title": "Swift/iOS client guide"
        }, 
        {
            "location": "/authentication/", 
            "text": "Authentication\n\n\nThe server has builtin authentication so clients can only send requests and connect if they have the \nserver key\n. When authentication is successful a client can create a session as a \nuser\n.\n\n\n\n\nImportant\n\n\nThe default server key is \ndefaultkey\n but it is very important to set a \nunique value\n. This value should be embedded within client code.\n\n\n\n\nINClient\n \nclient\n \n=\n \nnew\n \nNClient\n.\nBuilder\n(\ndefaultkey\n)\n\n    \n.\nHost\n(\n127.0.0.1\n)\n\n    \n.\nPort\n(\n7350\n)\n\n    \n.\nSSL\n(\nfalse\n)\n\n    \n.\nBuild\n();\n\n\n// or same as above.\n\n\nINClient\n \nclient\n \n=\n \nNClient\n.\nDefault\n(\ndefaultkey\n);\n\n\n\n\n\n\nEvery user account is created from one of the \noptions used to register\n. We call each of these options a \"link\" because it's a way to access the user's account. You can add more than one link to each account which is useful to enable users to login in multiple ways across different devices.\n\n\nRegister or login\n\n\nBefore you login a user they must first be registered. We recommend you setup your code to login the user and fallback to register the account if one does not exist. This pattern is shown in the \ndevice\n section.\n\n\n\n\nTip\n\n\nThe authentication system is very flexible. You could register a user with an email address, \nlink\n their Facebook account, and use it to login from another device.\n\n\n\n\nFor a \nfull example\n on the best way to handle register and login in each of the clients have a look at their guides.\n\n\nDevice\n\n\nA device identifier can be used as a way to unobtrusively register a user with the server. This offers a frictionless user experience but can be unreliable because device identifiers can sometimes change in device updates.\n\n\nA device identifier must contain alphanumeric characters with dashes and be between 10 and 60 bytes.\n\n\nvar\n \nsessionHandler\n \n=\n \ndelegate\n(\nINSession\n \nsession\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n\n};\n\n\n\nvar\n \nid\n \n=\n \nPlayerPrefs\n.\nGetString\n(\nnk.id\n);\n\n\nif\n \n(\nstring\n.\nIsNullOrEmpty\n(\nid\n))\n \n{\n\n  \nid\n \n=\n \nSystemInfo\n.\ndeviceUniqueIdentifier\n;\n\n  \nPlayerPrefs\n.\nSetString\n(\nnk.id\n,\n \nid\n);\n \n// cache device id.\n\n\n}\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nDevice\n(\nid\n);\n\n\nclient\n.\nLogin\n(\nmessage\n,\n \nsessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nUserNotFound\n)\n \n{\n\n    \nclient\n.\nRegister\n(\nmessage\n,\n \nsessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n      \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n    \n});\n\n  \n}\n \nelse\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\nIn games it is often a better option to use \nGoogle\n or \nGame Center\n to unobtrusively register the user.\n\n\nEmail\n\n\nUsers can be registered with an email and password. The password is hashed before it's stored in the database server and cannot be read or \"recovered\" by administrators. This protects a user's privacy.\n\n\nAn email address must be valid as defined by RFC-5322 and passwords must be at least 8 characters.\n\n\nstring\n \nemail\n \n=\n \nemail@example.com\n\n\nstring\n \npassword\n \n=\n \n3bc8f72e95a9\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nEmail\n(\nemail\n,\n \npassword\n);\n\n\nclient\n.\nRegister\n(\nmessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n// Use client.Login(...) after register.\n\n\n\n\n\n\nSocial providers\n\n\nThe server supports a lot of different social services with register and login. With each provider the user account will be fetched from the social service and used to setup the user. In some cases a user's \nfriends\n will also be fetched and added to their friends list.\n\n\nTo register or login as a user with any of the providers an OAuth or access token must be obtained from that social service.\n\n\nFacebook\n\n\nWith Facebook you'll need to add the Facebook SDK to your project which can be \ndownloaded online\n. Follow their guides on how to integrate the code. With a mobile project you'll also need to complete instructions on how to configure iOS and Android.\n\n\nvar\n \nsessionHandler\n \n=\n \ndelegate\n(\nINSession\n \nsession\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n  \nclient\n.\nConnect\n(\nsession\n);\n\n\n};\n\n\n\nvar\n \ninitCallback\n \n=\n \ndelegate\n()\n \n{\n\n  \nif\n \n(\nFB\n.\nIsInitialized\n)\n \n{\n\n    \nFB\n.\nActivateApp\n();\n\n    \n// use a Facebook access token to create a user account.\n\n    \nvar\n \noauthToken\n \n=\n \nFacebook\n.\nUnity\n.\nAccessToken\n.\nCurrentAccessToken\n.\nTokenString\n;\n\n\n    \nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nFacebook\n(\noauthToken\n);\n\n    \nclient\n.\nLogin\n(\nmessage\n,\n \nsessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n      \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nUserNotFound\n)\n \n{\n\n        \nclient\n.\nRegister\n(\nmessage\n,\n \nsessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n          \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n        \n});\n\n      \n}\n \nelse\n \n{\n\n        \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n      \n}\n\n    \n});\n\n  \n}\n\n\n};\n\n\n\n// you must call FB.Init as early as possible at startup.\n\n\nif\n \n(!\nFB\n.\nIsInitialized\n)\n \n{\n\n  \nFB\n.\nInit\n(\ninitCallback\n);\n\n\n}\n\n\n\n\n\n\nYou can add a button to your UI to login with Facebook.\n\n\nvar\n \nsessionHandler\n \n=\n \ndelegate\n(\nINSession\n \nsession\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n  \nclient\n.\nConnect\n(\nsession\n);\n\n\n};\n\n\n\nFB\n.\nLogin\n(\nemail\n,\n \n(\nILoginResult\n \nresult\n)\n \n=\n \n{\n\n  \nif\n \n(\nFB\n.\nIsLoggedIn\n)\n \n{\n\n    \nvar\n \noauthToken\n \n=\n \nFacebook\n.\nUnity\n.\nAccessToken\n.\nCurrentAccessToken\n.\nTokenString\n;\n\n\n    \nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nFacebook\n(\noauthToken\n);\n\n    \nclient\n.\nLogin\n(\nmessage\n,\n \nsessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n      \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nUserNotFound\n)\n \n{\n\n        \nclient\n.\nRegister\n(\nmessage\n,\n \nsessionHandler\n,\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n          \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n        \n});\n\n      \n}\n \nelse\n \n{\n\n        \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n      \n}\n\n    \n});\n\n  \n}\n \nelse\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nFacebook login failed got \n{0}\n.\n,\n \nresult\n.\nError\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\nGoogle\n\n\nSimilar to Facebook for register and login you should use one of Google's client SDKs.\n\n\nstring\n \noauthToken\n \n=\n \n...\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nGoogle\n(\noauthToken\n);\n\n\nclient\n.\nRegister\n(\nmessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n// Use client.Login(...) after register.\n\n\n\n\n\n\nGame Center\n\n\nApple devices have builtin authentication which can be done without user interaction through Game Center. The register or login process is a little complicated because of how Apple's services work.\n\n\n// You\nll need to use native code (Obj-C) with Unity.\n\n\n// The \nUnityEngine.SocialPlatforms.GameCenter\n doesn\nt give enough information\n\n\n// to enable authentication.\n\n\n\n// We recommend you use a library which handles native Game Center auth like\n\n\n// https://github.com/desertkun/GameCenterAuth\n\n\n\nstring\n \nplayerId\n \n=\n \n...\n;\n\n\nstring\n \nbundleId\n \n=\n \n...\n;\n\n\nstring\n \nbase64salt\n \n=\n \n...\n;\n\n\nstring\n \nbase64signature\n \n=\n \n...\n;\n\n\nstring\n \npublicKeyUrl\n \n=\n \n...\n;\n\n\nlong\n \ntimestamp\n \n=\n \n0L\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nGameCenter\n(\n\n    \nplayerId\n,\n \nbundleId\n,\n \ntimestamp\n,\n \nbase64salt\n,\n \nbase64signature\n,\n \npublicKeyUrl\n);\n\n\nclient\n.\nRegister\n(\nmessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n// Use client.Login(...) after register.\n\n\n\n\n\n\nSteam\n\n\nSteam requires you to configure the server before you can register a user.\n\n\n\n\nServer configuration\n\n\nHave a look at the \nconfiguration\n section for what settings you need for the server.\n\n\n\n\nstring\n \nsessionToken\n \n=\n \n...\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nSteam\n(\nsessionToken\n);\n\n\nclient\n.\nRegister\n(\nmessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n// Use client.Login(...) after register.\n\n\n\n\n\n\nCustom\n\n\nA custom identifier can be used in a similar way to a device identifier to login or register a user. This option should be used if you have an external or custom user identity service which you want to use. For example EA's Origin service handles accounts which have their own user IDs.\n\n\nA custom identifier must contain alphanumeric characters with dashes and be between 10 and 60 bytes.\n\n\n// Some id from another service.\n\n\nstring\n \ncustomId\n \n=\n \na1fca336-7191-11e7-bdab-df34f6f90285\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nCustom\n(\ncustomId\n);\n\n\nclient\n.\nRegister\n(\nmessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nSession: \n{0}\n.\n,\n \nsession\n.\nToken\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n// Use client.Login(...) after register.\n\n\n\n\n\n\nSessions\n\n\nThe register and login messages return a session on success. The session contains the current user's ID and handle as well as information on when it was created and when it expires.\n\n\n\n\nTip\n\n\nYou can change how long a session token is valid before it expires in the \nconfiguration\n in the server. By default a session is only valid for 60 seconds.\n\n\n\n\nstring\n \nid\n \n=\n \n3e70fd52-7192-11e7-9766-cb3ce5609916\n;\n\n\nvar\n \nmessage\n \n=\n \nNAuthenticateMessage\n.\nDevice\n(\nid\n);\n\n\nclient\n.\nLogin\n(\nmessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nvar\n \nsessionId\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nsession\n.\nId\n);\n\n  \nDebug\n.\nLogFormat\n(\nSession id \n{0}\n handle \n{1}\n.\n,\n \nsessionId\n,\n \nsession\n.\nHandle\n);\n\n  \nDebug\n.\nLogFormat\n(\nSession expired: {0}\n,\n \nsession\n.\nHasExpired\n(\nDateTime\n.\nUtcNow\n));\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nConnect\n\n\nWith a session you can connect with the server and send messages. Most of our clients do not auto-reconnect for you so you should handle it with your own code.\n\n\nYou can only send messages to the server once you've connected a client.\n\n\nINSession\n \nsession\n \n=\n \nsession\n;\n \n// obtained from Register or Login.\n\n\nclient\n.\nConnect\n(\nsession\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully connected.\n);\n\n\n});\n\n\n\n\n\n\nLink or unlink\n\n\nYou can link one or more other login option to the current user. This makes it easy to support multiple logins with each user and easily identify a user across devices.\n\n\nYou can only link device Ids, custom Ids, and social provider IDs which are not already in-use with another user account.\n\n\nstring\n \nid\n \n=\n \n062b0916-7196-11e7-8371-9fcee9f0b20c\n;\n\n\n\nvar\n \nmessage\n \n=\n \nSelfLinkMessage\n.\nDevice\n(\nid\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully linked device ID to current user.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can unlink any linked login options for the current user.\n\n\nstring\n \nid\n \n=\n \n062b0916-7196-11e7-8371-9fcee9f0b20c\n;\n\n\n\nvar\n \nmessage\n \n=\n \nSelfUnlinkMessage\n.\nDevice\n(\nid\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully unlinked device ID from current user.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nLike with register and login you can link or unlink many different account options.\n\n\n\n\n\n\n\n\nLink\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCustom\n\n\nA custom identifier from another identity service.\n\n\n\n\n\n\nDevice\n\n\nA unique identifier for a device which belongs to the user.\n\n\n\n\n\n\nEmail\n\n\nAn email and password set by the user.\n\n\n\n\n\n\nFacebook\n\n\nA Facebook social account.\n\n\n\n\n\n\nGame Center\n\n\nAn account from Apple's Game Center service.\n\n\n\n\n\n\nGoogle\n\n\nA Google Play social account.\n\n\n\n\n\n\nSteam\n\n\nAn account from the Steam network.", 
            "title": "Authentication"
        }, 
        {
            "location": "/authentication/#authentication", 
            "text": "The server has builtin authentication so clients can only send requests and connect if they have the  server key . When authentication is successful a client can create a session as a  user .   Important  The default server key is  defaultkey  but it is very important to set a  unique value . This value should be embedded within client code.   INClient   client   =   new   NClient . Builder ( defaultkey ) \n     . Host ( 127.0.0.1 ) \n     . Port ( 7350 ) \n     . SSL ( false ) \n     . Build ();  // or same as above.  INClient   client   =   NClient . Default ( defaultkey );   Every user account is created from one of the  options used to register . We call each of these options a \"link\" because it's a way to access the user's account. You can add more than one link to each account which is useful to enable users to login in multiple ways across different devices.", 
            "title": "Authentication"
        }, 
        {
            "location": "/authentication/#register-or-login", 
            "text": "Before you login a user they must first be registered. We recommend you setup your code to login the user and fallback to register the account if one does not exist. This pattern is shown in the  device  section.   Tip  The authentication system is very flexible. You could register a user with an email address,  link  their Facebook account, and use it to login from another device.   For a  full example  on the best way to handle register and login in each of the clients have a look at their guides.", 
            "title": "Register or login"
        }, 
        {
            "location": "/authentication/#device", 
            "text": "A device identifier can be used as a way to unobtrusively register a user with the server. This offers a frictionless user experience but can be unreliable because device identifiers can sometimes change in device updates.  A device identifier must contain alphanumeric characters with dashes and be between 10 and 60 bytes.  var   sessionHandler   =   delegate ( INSession   session )   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token );  };  var   id   =   PlayerPrefs . GetString ( nk.id );  if   ( string . IsNullOrEmpty ( id ))   { \n   id   =   SystemInfo . deviceUniqueIdentifier ; \n   PlayerPrefs . SetString ( nk.id ,   id );   // cache device id.  }  var   message   =   NAuthenticateMessage . Device ( id );  client . Login ( message ,   sessionHandler ,   ( INError   err )   =   { \n   if   ( err . Code   ==   ErrorCode . UserNotFound )   { \n     client . Register ( message ,   sessionHandler ,   ( INError   err )   =   { \n       Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n     }); \n   }   else   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   }  });   In games it is often a better option to use  Google  or  Game Center  to unobtrusively register the user.", 
            "title": "Device"
        }, 
        {
            "location": "/authentication/#email", 
            "text": "Users can be registered with an email and password. The password is hashed before it's stored in the database server and cannot be read or \"recovered\" by administrators. This protects a user's privacy.  An email address must be valid as defined by RFC-5322 and passwords must be at least 8 characters.  string   email   =   email@example.com  string   password   =   3bc8f72e95a9  var   message   =   NAuthenticateMessage . Email ( email ,   password );  client . Register ( message ,   ( INSession   session )   =   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });  // Use client.Login(...) after register.", 
            "title": "Email"
        }, 
        {
            "location": "/authentication/#social-providers", 
            "text": "The server supports a lot of different social services with register and login. With each provider the user account will be fetched from the social service and used to setup the user. In some cases a user's  friends  will also be fetched and added to their friends list.  To register or login as a user with any of the providers an OAuth or access token must be obtained from that social service.", 
            "title": "Social providers"
        }, 
        {
            "location": "/authentication/#facebook", 
            "text": "With Facebook you'll need to add the Facebook SDK to your project which can be  downloaded online . Follow their guides on how to integrate the code. With a mobile project you'll also need to complete instructions on how to configure iOS and Android.  var   sessionHandler   =   delegate ( INSession   session )   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token ); \n   client . Connect ( session );  };  var   initCallback   =   delegate ()   { \n   if   ( FB . IsInitialized )   { \n     FB . ActivateApp (); \n     // use a Facebook access token to create a user account. \n     var   oauthToken   =   Facebook . Unity . AccessToken . CurrentAccessToken . TokenString ; \n\n     var   message   =   NAuthenticateMessage . Facebook ( oauthToken ); \n     client . Login ( message ,   sessionHandler ,   ( INError   err )   =   { \n       if   ( err . Code   ==   ErrorCode . UserNotFound )   { \n         client . Register ( message ,   sessionHandler ,   ( INError   err )   =   { \n           Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n         }); \n       }   else   { \n         Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n       } \n     }); \n   }  };  // you must call FB.Init as early as possible at startup.  if   (! FB . IsInitialized )   { \n   FB . Init ( initCallback );  }   You can add a button to your UI to login with Facebook.  var   sessionHandler   =   delegate ( INSession   session )   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token ); \n   client . Connect ( session );  };  FB . Login ( email ,   ( ILoginResult   result )   =   { \n   if   ( FB . IsLoggedIn )   { \n     var   oauthToken   =   Facebook . Unity . AccessToken . CurrentAccessToken . TokenString ; \n\n     var   message   =   NAuthenticateMessage . Facebook ( oauthToken ); \n     client . Login ( message ,   sessionHandler ,   ( INError   err )   =   { \n       if   ( err . Code   ==   ErrorCode . UserNotFound )   { \n         client . Register ( message ,   sessionHandler ,   ( INError   err )   =   { \n           Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n         }); \n       }   else   { \n         Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n       } \n     }); \n   }   else   { \n     Debug . LogErrorFormat ( Facebook login failed got  {0} . ,   result . Error ); \n   }  });", 
            "title": "Facebook"
        }, 
        {
            "location": "/authentication/#google", 
            "text": "Similar to Facebook for register and login you should use one of Google's client SDKs.  string   oauthToken   =   ... ;  var   message   =   NAuthenticateMessage . Google ( oauthToken );  client . Register ( message ,   ( INSession   session )   =   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });  // Use client.Login(...) after register.", 
            "title": "Google"
        }, 
        {
            "location": "/authentication/#game-center", 
            "text": "Apple devices have builtin authentication which can be done without user interaction through Game Center. The register or login process is a little complicated because of how Apple's services work.  // You ll need to use native code (Obj-C) with Unity.  // The  UnityEngine.SocialPlatforms.GameCenter  doesn t give enough information  // to enable authentication.  // We recommend you use a library which handles native Game Center auth like  // https://github.com/desertkun/GameCenterAuth  string   playerId   =   ... ;  string   bundleId   =   ... ;  string   base64salt   =   ... ;  string   base64signature   =   ... ;  string   publicKeyUrl   =   ... ;  long   timestamp   =   0L ;  var   message   =   NAuthenticateMessage . GameCenter ( \n     playerId ,   bundleId ,   timestamp ,   base64salt ,   base64signature ,   publicKeyUrl );  client . Register ( message ,   ( INSession   session )   =   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });  // Use client.Login(...) after register.", 
            "title": "Game Center"
        }, 
        {
            "location": "/authentication/#steam", 
            "text": "Steam requires you to configure the server before you can register a user.   Server configuration  Have a look at the  configuration  section for what settings you need for the server.   string   sessionToken   =   ... ;  var   message   =   NAuthenticateMessage . Steam ( sessionToken );  client . Register ( message ,   ( INSession   session )   =   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });  // Use client.Login(...) after register.", 
            "title": "Steam"
        }, 
        {
            "location": "/authentication/#custom", 
            "text": "A custom identifier can be used in a similar way to a device identifier to login or register a user. This option should be used if you have an external or custom user identity service which you want to use. For example EA's Origin service handles accounts which have their own user IDs.  A custom identifier must contain alphanumeric characters with dashes and be between 10 and 60 bytes.  // Some id from another service.  string   customId   =   a1fca336-7191-11e7-bdab-df34f6f90285 ;  var   message   =   NAuthenticateMessage . Custom ( customId );  client . Register ( message ,   ( INSession   session )   =   { \n   Debug . LogFormat ( Session:  {0} . ,   session . Token );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });  // Use client.Login(...) after register.", 
            "title": "Custom"
        }, 
        {
            "location": "/authentication/#sessions", 
            "text": "The register and login messages return a session on success. The session contains the current user's ID and handle as well as information on when it was created and when it expires.   Tip  You can change how long a session token is valid before it expires in the  configuration  in the server. By default a session is only valid for 60 seconds.   string   id   =   3e70fd52-7192-11e7-9766-cb3ce5609916 ;  var   message   =   NAuthenticateMessage . Device ( id );  client . Login ( message ,   ( INSession   session )   =   { \n   var   sessionId   =   Encoding . UTF8 . GetString ( session . Id ); \n   Debug . LogFormat ( Session id  {0}  handle  {1} . ,   sessionId ,   session . Handle ); \n   Debug . LogFormat ( Session expired: {0} ,   session . HasExpired ( DateTime . UtcNow ));  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Sessions"
        }, 
        {
            "location": "/authentication/#connect", 
            "text": "With a session you can connect with the server and send messages. Most of our clients do not auto-reconnect for you so you should handle it with your own code.  You can only send messages to the server once you've connected a client.  INSession   session   =   session ;   // obtained from Register or Login.  client . Connect ( session ,   ( bool   done )   =   { \n   Debug . Log ( Successfully connected. );  });", 
            "title": "Connect"
        }, 
        {
            "location": "/authentication/#link-or-unlink", 
            "text": "You can link one or more other login option to the current user. This makes it easy to support multiple logins with each user and easily identify a user across devices.  You can only link device Ids, custom Ids, and social provider IDs which are not already in-use with another user account.  string   id   =   062b0916-7196-11e7-8371-9fcee9f0b20c ;  var   message   =   SelfLinkMessage . Device ( id );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully linked device ID to current user. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can unlink any linked login options for the current user.  string   id   =   062b0916-7196-11e7-8371-9fcee9f0b20c ;  var   message   =   SelfUnlinkMessage . Device ( id );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully unlinked device ID from current user. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   Like with register and login you can link or unlink many different account options.     Link  Description      Custom  A custom identifier from another identity service.    Device  A unique identifier for a device which belongs to the user.    Email  An email and password set by the user.    Facebook  A Facebook social account.    Game Center  An account from Apple's Game Center service.    Google  A Google Play social account.    Steam  An account from the Steam network.", 
            "title": "Link or unlink"
        }, 
        {
            "location": "/user-accounts/", 
            "text": "User accounts\n\n\nA user represents an identity within the server. Every user is registered and has a profile for other users to find and become \nfriends\n with or join \ngroups\n and \nchat\n.\n\n\nA user can own \nrecords\n, share public information with other users, and login via a bunch of different social providers.\n\n\nFetch self\n\n\nWhen a user has a session you can retrieve their profile. The profile is returned for yourself and so we refer to it as \"self\" in client code. The profile contains lots of information which includes various \"linked\" social providers.\n\n\nvar\n \nmessage\n \n=\n \nNSelfFetchMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINSelf\n \nself\n)\n \n=\n \n{\n\n  \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nself\n.\nId\n);\n\n  \nDebug\n.\nLogFormat\n(\nUser has id \n{0}\n and handle \n{1}\n.\n,\n \nid\n,\n \nself\n.\nHandle\n);\n\n  \nvar\n \nmetadata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nself\n.\nMetadata\n);\n\n  \nDebug\n.\nLogFormat\n(\nUser has JSON metadata \n{0}\n.\n,\n \nmetadata\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nSome information like social IDs are private but part of the profile is visible to other users.\n\n\n\n\n\n\n\n\nPublic field\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAvatarUrl\n\n\nA URL with a profile picture for the user (empty by default).\n\n\n\n\n\n\nCreatedAt\n\n\nA timestamp in milliseconds for when the user was created.\n\n\n\n\n\n\nFullname\n\n\nThe full name for the user (empty by default).\n\n\n\n\n\n\nHandle\n\n\nA unique nickname for the user.\n\n\n\n\n\n\nId\n\n\nThe unique identifier for the user.\n\n\n\n\n\n\nLang\n\n\nThe preferred language settings for the user (default is \"en\").\n\n\n\n\n\n\nLastOnlineAt\n\n\nA timestamp in milliseconds when the user was last online.\n\n\n\n\n\n\nLocation\n\n\nThe location of the user (empty by default).\n\n\n\n\n\n\nMetadata\n\n\nA slot for custom information to be added for the user (must be JSON encoded).\n\n\n\n\n\n\nTimezone\n\n\nThe timezone of the user (empty by default).\n\n\n\n\n\n\nUpdatedAt\n\n\nA timestamp in milliseconds for when the user was last updated.\n\n\n\n\n\n\n\n\nYou can store additional fields for a user in \n\"Metadata\"\n which is useful to share data you want to be public to other users. Metadata is limited to 16KB per user.\n\n\n\n\nTip\n\n\nWe recommend you choose user metadata to store very common fields which other users will need to see. For all other information you can store records with \npublic read permissions\n which other users can find.\n\n\n\n\nFetch users\n\n\nYou can fetch one or more users by their IDs or handles. This is useful for displaying public profiles with other users.\n\n\nbyte\n[]\n \nid\n \n=\n \nuser\n.\nId\n;\n \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNUsersFetchMessage\n.\nDefault\n(\nid\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINUser\n \nlist\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nFetched \n{0}\n users.\n,\n \nlist\n.\nResults\n.\nCount\n);\n\n  \nforeach\n \n(\nvar\n \nuser\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nuser\n.\nId\n);\n\n    \nDebug\n.\nLogFormat\n(\nUser has id \n{0}\n and handle \n{1}\n.\n,\n \nid\n,\n \nuser\n.\nHandle\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can also fetch one or more users in server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n\n  \n3ea5608a-43c3-11e7-90f9-7b9397165f34\n,\n\n  \n447524be-43c3-11e7-af09-3f7172f05936\n\n\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nuser_fetch_id\n(\nuser_ids\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nhandle: %q, fullname: %q\n):\nformat\n(\nu\n.\nHandle\n,\n \nu\n.\nFullname\n)\n\n  \nnk\n.\nlogger_info\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\nUpdate self\n\n\nWhen a user is registered most of their profile is setup with default values. A user can update their own profile to change fields but cannot change any other user's profile.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNSelfUpdateMessage\n.\nBuilder\n()\n\n    \n.\nAvatarUrl\n(\nhttp://graph.facebook.com/avatar_url\n)\n\n    \n.\nFullname\n(\nMy New Name\n)\n\n    \n.\nLocation\n(\nSan Francisco\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully updated yourself.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nWith server-side code it's possible to update one or more user's profiles.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_update\n \n=\n \n{\n\n  \nUserId\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n,\n \n-- some user\ns id.\n\n  \nAvatarUrl\n \n=\n \nhttp://graph.facebook.com/avatar_url\n,\n\n  \nFullname\n \n=\n \nMy new Name\n,\n\n  \nLocation\n \n=\n \nSan Francisco\n,\n\n  \nMetadata\n \n=\n \n{}\n\n\n}\n\n\nlocal\n \nstatus\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_update\n,\n \n{\n \nuser_update\n \n})\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nnk\n.\nlogger_info\n((\nUser update error: %q\n):\nformat\n(\nerr\n))\n\n\nend", 
            "title": "User accounts"
        }, 
        {
            "location": "/user-accounts/#user-accounts", 
            "text": "A user represents an identity within the server. Every user is registered and has a profile for other users to find and become  friends  with or join  groups  and  chat .  A user can own  records , share public information with other users, and login via a bunch of different social providers.", 
            "title": "User accounts"
        }, 
        {
            "location": "/user-accounts/#fetch-self", 
            "text": "When a user has a session you can retrieve their profile. The profile is returned for yourself and so we refer to it as \"self\" in client code. The profile contains lots of information which includes various \"linked\" social providers.  var   message   =   NSelfFetchMessage . Default ();  client . Send ( message ,   ( INSelf   self )   =   { \n   var   id   =   Encoding . UTF8 . GetString ( self . Id ); \n   Debug . LogFormat ( User has id  {0}  and handle  {1} . ,   id ,   self . Handle ); \n   var   metadata   =   Encoding . UTF8 . GetString ( self . Metadata ); \n   Debug . LogFormat ( User has JSON metadata  {0} . ,   metadata );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   Some information like social IDs are private but part of the profile is visible to other users.     Public field  Description      AvatarUrl  A URL with a profile picture for the user (empty by default).    CreatedAt  A timestamp in milliseconds for when the user was created.    Fullname  The full name for the user (empty by default).    Handle  A unique nickname for the user.    Id  The unique identifier for the user.    Lang  The preferred language settings for the user (default is \"en\").    LastOnlineAt  A timestamp in milliseconds when the user was last online.    Location  The location of the user (empty by default).    Metadata  A slot for custom information to be added for the user (must be JSON encoded).    Timezone  The timezone of the user (empty by default).    UpdatedAt  A timestamp in milliseconds for when the user was last updated.     You can store additional fields for a user in  \"Metadata\"  which is useful to share data you want to be public to other users. Metadata is limited to 16KB per user.   Tip  We recommend you choose user metadata to store very common fields which other users will need to see. For all other information you can store records with  public read permissions  which other users can find.", 
            "title": "Fetch self"
        }, 
        {
            "location": "/user-accounts/#fetch-users", 
            "text": "You can fetch one or more users by their IDs or handles. This is useful for displaying public profiles with other users.  byte []   id   =   user . Id ;   // an INUser ID.  var   message   =   NUsersFetchMessage . Default ( id );  client . Send ( message ,   ( INResultSet INUser   list )   =   { \n   Debug . LogFormat ( Fetched  {0}  users. ,   list . Results . Count ); \n   foreach   ( var   user   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( user . Id ); \n     Debug . LogFormat ( User has id  {0}  and handle  {1} . ,   id ,   user . Handle ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can also fetch one or more users in server-side code.  local   nk   =   require ( nakama )  local   user_ids   =   { \n   3ea5608a-43c3-11e7-90f9-7b9397165f34 , \n   447524be-43c3-11e7-af09-3f7172f05936  }  local   users   =   nk . user_fetch_id ( user_ids )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( handle: %q, fullname: %q ): format ( u . Handle ,   u . Fullname ) \n   nk . logger_info ( message )  end", 
            "title": "Fetch users"
        }, 
        {
            "location": "/user-accounts/#update-self", 
            "text": "When a user is registered most of their profile is setup with default values. A user can update their own profile to change fields but cannot change any other user's profile.  var   message   =   new   NSelfUpdateMessage . Builder () \n     . AvatarUrl ( http://graph.facebook.com/avatar_url ) \n     . Fullname ( My New Name ) \n     . Location ( San Francisco ) \n     . Build ();  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully updated yourself. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   With server-side code it's possible to update one or more user's profiles.  local   nk   =   require ( nakama )  local   user_update   =   { \n   UserId   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521 ,   -- some user s id. \n   AvatarUrl   =   http://graph.facebook.com/avatar_url , \n   Fullname   =   My new Name , \n   Location   =   San Francisco , \n   Metadata   =   {}  }  local   status ,   err   =   pcall ( nk . users_update ,   {   user_update   })  if   ( not   status )   then \n   nk . logger_info (( User update error: %q ): format ( err ))  end", 
            "title": "Update self"
        }, 
        {
            "location": "/storage-collections/", 
            "text": "Collections\n\n\nEvery app or game has data which is specific to the project. This information must be stored for users, updated, retrieved, and displayed within various parts of a UI. For this purpose the server incorporates a storage engine with a design optimized for record ownership, access permissions, and batch operations.\n\n\nData should be stored in collections as one or more records which are retrieved by a unique key with JSON content. A collection is created without any configuration required and are grouped into buckets. This creates a simple nested namespace which represents the location of a record.\n\n\nBucket\n+---------------------------------------------------------------------------+\n|  Collection                                                               |\n|  +---------------------------------------------------------------------+  |\n|  |  Record                                                             |  |\n|  |  +----------+------------+-------------+-----+-------------------+  |  |\n|  |  | ?UserId? | Identifier | Permissions | ... |       Value       |  |  |\n|  |  +---------------------------------------------------------------+  |  |\n|  +---------------------------------------------------------------------+  |\n+---------------------------------------------------------------------------+\n\n\n\n\n\nThis design gives great flexibility for developers to group sets of information which belong together within a game or app.\n\n\nWrite records\n\n\nA user can write one or more records which will be stored in the database server. These records will be written in a single transaction which guarantees the writes succeed together.\n\n\n\n\nTip\n\n\nIn most cases you won't need to group data under multiple buckets so it can be easiest to just name it after your project. For example \"Super Mario Run\" could use a bucket name \"smr\" or similar.\n\n\n\n\nbyte\n[]\n \nsaveGame\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{\nprogress\n: 50}\n);\n\n\nbyte\n[]\n \nmyStats\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{\nskill\n: 24}\n);\n\n\n\n// Write multiple different records across collections.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNStorageWriteMessage\n.\nBuilder\n()\n\n    \n.\nWrite\n(\nmyapp\n,\n \nsaves\n,\n \nsavegame\n,\n \nsaveGame\n)\n\n    \n.\nWrite\n(\nmyapp\n,\n \nstats\n,\n \nmystats\n,\n \nmyStats\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINStorageKey\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nrecord\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nversion\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nrecord\n.\nVersion\n);\n\n    \nDebug\n.\nLogFormat\n(\nSuccessfully stored record has version \n{0}\n,\n \nversion\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nConditional writes\n\n\nWhen records are successfully stored a version is returned which can be used with further updates to perform concurrent modification checks as the next write occurs. This is often known as a conditional write.\n\n\n\n\n\n\n\n\nFetch records\n\n\nUpdate records\n\n\nRemove records\n\n\nInside the database a flattened hierarchy is used for each record with a composite key used to uniquely identify it.", 
            "title": "Collections"
        }, 
        {
            "location": "/storage-collections/#collections", 
            "text": "Every app or game has data which is specific to the project. This information must be stored for users, updated, retrieved, and displayed within various parts of a UI. For this purpose the server incorporates a storage engine with a design optimized for record ownership, access permissions, and batch operations.  Data should be stored in collections as one or more records which are retrieved by a unique key with JSON content. A collection is created without any configuration required and are grouped into buckets. This creates a simple nested namespace which represents the location of a record.  Bucket\n+---------------------------------------------------------------------------+\n|  Collection                                                               |\n|  +---------------------------------------------------------------------+  |\n|  |  Record                                                             |  |\n|  |  +----------+------------+-------------+-----+-------------------+  |  |\n|  |  | ?UserId? | Identifier | Permissions | ... |       Value       |  |  |\n|  |  +---------------------------------------------------------------+  |  |\n|  +---------------------------------------------------------------------+  |\n+---------------------------------------------------------------------------+  This design gives great flexibility for developers to group sets of information which belong together within a game or app.", 
            "title": "Collections"
        }, 
        {
            "location": "/storage-collections/#write-records", 
            "text": "A user can write one or more records which will be stored in the database server. These records will be written in a single transaction which guarantees the writes succeed together.   Tip  In most cases you won't need to group data under multiple buckets so it can be easiest to just name it after your project. For example \"Super Mario Run\" could use a bucket name \"smr\" or similar.   byte []   saveGame   =   Encoding . UTF8 . GetBytes ( { progress : 50} );  byte []   myStats   =   Encoding . UTF8 . GetBytes ( { skill : 24} );  // Write multiple different records across collections.  var   message   =   new   NStorageWriteMessage . Builder () \n     . Write ( myapp ,   saves ,   savegame ,   saveGame ) \n     . Write ( myapp ,   stats ,   mystats ,   myStats ) \n     . Build ();  client . Send ( message ,   ( INResultSet INStorageKey   list )   =   { \n   foreach   ( var   record   in   list . Results )   { \n     var   version   =   Encoding . UTF8 . GetString ( record . Version ); \n     Debug . LogFormat ( Successfully stored record has version  {0} ,   version ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Write records"
        }, 
        {
            "location": "/storage-collections/#conditional-writes", 
            "text": "When records are successfully stored a version is returned which can be used with further updates to perform concurrent modification checks as the next write occurs. This is often known as a conditional write.", 
            "title": "Conditional writes"
        }, 
        {
            "location": "/storage-collections/#fetch-records", 
            "text": "", 
            "title": "Fetch records"
        }, 
        {
            "location": "/storage-collections/#update-records", 
            "text": "", 
            "title": "Update records"
        }, 
        {
            "location": "/storage-collections/#remove-records", 
            "text": "Inside the database a flattened hierarchy is used for each record with a composite key used to uniquely identify it.", 
            "title": "Remove records"
        }, 
        {
            "location": "/social-friends/", 
            "text": "Friends\n\n\nFriends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.\n\n\n\n\nFun fact\n\n\nNakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!\n\n\n\n\nEach user builds up a list of friends by who they know already from their social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.\n\n\nAny social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.\n\n\nAdd friends\n\n\nA user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.\n\n\n\n\nHint\n\n\nA user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.\n\n\n\n\nWhen a friend request is sent or the user is added an in-app notification will be sent. See the \nin-app notification\n section for more info.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendAddMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nFriend added or request sent.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nWhen both users have added eachother as friends it's easy to initiate realtime chat in a 1-on-1 channel. See the \nrealtime chat\n section for more info.\n\n\nList friends\n\n\nYou can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.\n\n\nvar\n \nmessage\n \n=\n \nNFriendsListMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINFriend\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nf\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nf\n.\nId\n);\n \n// convert byte[].\n\n    \n// f.State is one of: Friend, Invite, Invited, Blocked.\n\n    \nDebug\n.\nLogFormat\n(\nUser {0} has state {1}.\n,\n \nid\n,\n \nf\n.\nState\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nRemove friends\n\n\nA user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.\n\n\n\n\nNote\n\n\nIf a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.\n\n\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendRemoveMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nuserId\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been removed.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBlock a friend\n\n\nYou can stop a user from using 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a \nFriend Remove\n message.\n\n\nA user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.\n\n\nbyte\n[]\n \nuserId\n \n=\n \n...;\n \n// some user ID\n\n\nvar\n \nmessage\n \n=\n \nNFriendBlockMessage\n.\nDefault\n(\nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nvar\n \nidString\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nid\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLog\n(\nUser {0} has been blocked.\n,\n \nidString\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBan a user\n\n\nA user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.\n\n\nThis is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team.\n\n\nSee the \nruntime code basics\n on how to write server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n-- you can use both IDs and handles to ban.\n\n\nlocal\n \nbad_users\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n,\n \nuserhandle\n}\n\n\nlocal\n \nsuccess\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nbad_users\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nBan failed: %q\n):\nformat\n(\nerr\n))\n\n\nend", 
            "title": "Friends"
        }, 
        {
            "location": "/social-friends/#friends", 
            "text": "Friends are a great way to build a social community. Users can add other users to their list of friends, see who is online or when they were last online, chat together in realtime, and interact together in gameplay or collaboration.   Fun fact  Nakama is a common Japanese word that directly translates to friend or comrade. Some believe the word means \"people who are considered closer than family\", though that is not a part of the official definition. We feel it expresses the kind of social communities we want developers to build into their games and apps!   Each user builds up a list of friends by who they know already from their social networks, friend requests they send, requests they receive, and who the server recommends they should know. This information is stored in a social graph within the system as a powerful way to interact with other users. Much like how Twitter or Facebook work.  Any social community must be maintained carefully to prevent spam or abuse. To help with this problem it's also possible for a user to block users they no longer want to communicate with and for the server to ban a user via server-side code to completely disable an account.", 
            "title": "Friends"
        }, 
        {
            "location": "/social-friends/#add-friends", 
            "text": "A user can add one or more friends by that user's ID or handle. The user added will not be marked as a friend in the list until they've confirmed the friend request. The user who receives the request can confirm it by adding the user back.   Hint  A user who registers or links their account with Facebook or another social network will have friends from that network be added automatically into their friend list.   When a friend request is sent or the user is added an in-app notification will be sent. See the  in-app notification  section for more info.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendAddMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Friend added or request sent. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   When both users have added eachother as friends it's easy to initiate realtime chat in a 1-on-1 channel. See the  realtime chat  section for more info.", 
            "title": "Add friends"
        }, 
        {
            "location": "/social-friends/#list-friends", 
            "text": "You can list all of a user's friends, blocked users, friend requests received (invited), and invites they've sent. These statuses are returned together as part of the friend list which makes it easy to display in a UI.  var   message   =   NFriendsListMessage . Default ();  client . Send ( message ,   ( INResultSet INFriend   list )   =   { \n   foreach   ( var   f   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( f . Id );   // convert byte[]. \n     // f.State is one of: Friend, Invite, Invited, Blocked. \n     Debug . LogFormat ( User {0} has state {1}. ,   id ,   f . State ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List friends"
        }, 
        {
            "location": "/social-friends/#remove-friends", 
            "text": "A user can remove a friend, reject a received invite, cancel a friend request sent, or unblock a user. Similar to how Friend Add works we reuse Friend Remove to cancel or undo whatever friend state is current with another user.   Note  If a user is unblocked they are removed from the friend list entirely. To re-add them each user must add the other again.   byte []   userId   =   ...;   // some user ID  var   message   =   NFriendRemoveMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( userId );   // convert byte[]. \n   Debug . Log ( User {0} has been removed. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Remove friends"
        }, 
        {
            "location": "/social-friends/#block-a-friend", 
            "text": "You can stop a user from using 1-on-1 chat or other social features with a user if you block them. The user who wants to block should send the message. They can be unblocked later with a  Friend Remove  message.  A user who has been blocked will not know which users have blocked them. That user can continue to add friends and interact with other users.  byte []   userId   =   ...;   // some user ID  var   message   =   NFriendBlockMessage . Default ( userId );  client . Send ( message ,   ( bool   done )   =   { \n   var   idString   =   Encoding . UTF8 . GetString ( id );   // convert byte[]. \n   Debug . Log ( User {0} has been blocked. ,   idString );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Block a friend"
        }, 
        {
            "location": "/social-friends/#ban-a-user", 
            "text": "A user can be banned with server-side code. This will prevent the user from being able to connect to the server and interact at all.  This is best used by a moderator system within your community. You could assign particular users the capabilities to send an RPC to permanently ban a user or you may decide to ban users via your liveops support team.  See the  runtime code basics  on how to write server-side code.  local   nk   =   require ( nakama )  -- you can use both IDs and handles to ban.  local   bad_users   =   { someuserid ,   anotheruserid ,   userhandle }  local   success ,   err   =   pcall ( nk . users_ban ,   bad_users )  if   ( not   success )   then \n   nk . logger_error (( Ban failed: %q ): format ( err ))  end", 
            "title": "Ban a user"
        }, 
        {
            "location": "/social-groups-clans/", 
            "text": "Groups and Clans\n\n\nA group brings together a bunch of users into a small community or team.\n\n\nA group is made up of an owner, admins, and members. It can be public or private which determines whether it appears in results when a user searches. Private groups are similar to how Whatsapp groups work. A user can only be added when they're invited to join by one of the group's admins.\n\n\nSearch for groups\n\n\nA user can find public groups to join by a filter on language, recently created, how many members in a group, and more. These filters make it easy to assemble new users into smaller groups for team-based play or collaboration.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNGroupsListMessage\n.\nBuilder\n()\n\n    \n.\nOrderByAsc\n(\ntrue\n)\n\n    \n.\nFilterByLang\n(\nen\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroup\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \ngroup\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nGroup: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe message response for a list of groups contains a cursor. The cursor can be used to quickly retrieve the next set of results.\n\n\n\n\nTip\n\n\nCursors are used across different server features to page through batches of results quickly and efficiently. It's used with storage, friends, chat history, etc.\n\n\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nvar\n \nmessageBuilder\n \n=\n \nnew\n \nNGroupsListMessage\n.\nBuilder\n()\n\n    \n.\nOrderByAsc\n(\ntrue\n)\n\n    \n.\nFilterByLang\n(\nen\n);\n\n    \n.\nPageLimit\n(\n100\n);\n\n\n\nclient\n.\nSend\n(\nmessageBuilder\n.\nBuild\n(),\n \n(\nINResultSet\nINGroup\n \nlist\n)\n \n=\n \n{\n\n  \n// Lets get the next page of results.\n\n  \nINCursor\n \ncursor\n \n=\n \nlist\n.\nCursor\n;\n\n  \nif\n \n(\ncursor\n \n!=\n \nnull\n \n \nlist\n.\nResults\n.\nCount\n \n \n0\n)\n \n{\n\n    \nvar\n \nmessage\n \n=\n \nmessageBuilder\n.\nCursor\n(\ncursor\n).\nBuild\n();\n\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroup\n \nnextList\n)\n \n=\n \n{\n\n      \nforeach\n \n(\nvar\n \ngroup\n \nin\n \nnextList\n.\nResults\n)\n \n{\n\n        \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n        \nDebug\n.\nLogFormat\n(\nGroup: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n      \n}\n\n    \n},\n \nerrorHandler\n);\n\n  \n}\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nJoin groups\n\n\nWhen a user has found a group to join they can request to become a member. A public group can be joined without any need for permission while a private group requires an \nadmin to accept\n the user.\n\n\nA user who's part of a group can join \ngroup chat\n and access it's \nmessage history\n.\n\n\n\n\nTip\n\n\nWhen a user joins or leaves a group event messages are added to chat history. This makes it easy for members to see what's changed in the group.\n\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupJoinMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nRequested to join group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe user will receive an \nin-app notification\n when they've been added to the group. In a private group an admin will receive a notification when a user has requested to join.\n\n\nList a user's groups\n\n\nEach user can list groups they've joined as a member or an admin. The list also contains groups which they've requested to join but not been accepted into yet.\n\n\nvar\n \nmessage\n \n=\n \nNGroupsSelfListMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroup\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \ngroup\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nGroup: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nList group members\n\n\nA user can list all members who're part of their group. These include other users who've requested to join the private group but not been accepted into yet.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupUsersListMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINGroupUser\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nmember\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmember\n.\nId\n);\n  \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nMember id \n{0}\n with name \n{1}\n.\n,\n \nid\n,\n \nmember\n.\nFullname\n);\n\n    \n// member.Type is one of: Admin, Member, Join.\n\n    \nUserType\n \nstatus\n \n=\n \nmember\n.\nType\n;\n\n    \nDebug\n.\nLogFormat\n(\nHas handle \n{0}\n with status \n{1}\n.\n,\n \nmember\n.\nHandle\n,\n \nstatus\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nCreate a group\n\n\nA group can be created with a name and other optional fields. These optional fields are used when a user \nsearches for groups\n. The user who creates the group becomes the owner and an admin for it.\n\n\nvar\n \nmetadata\n \n=\n \n{\nmy_custom_field\n: \nsome value\n}\n;\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNGroupCreateMessage\n.\nBuilder\n(\nSome unique group name\n)\n\n    \n.\nDescription\n(\nMy awesome group.\n)\n\n    \n.\nLang\n(\nen\n)\n\n    \n.\nPrivate\n(\ntrue\n)\n\n    \n.\nAvatarUrl\n(\nurl://somelink\n)\n\n    \n.\nMetadata\n(\nmetadata\n)\n\n    \n.\nBuild\n();\n\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINGroup\n \ngroup\n)\n \n=\n \n{\n\n  \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\ngroup\n.\nId\n);\n  \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nNew group: name \n{0}\n id \n{1}\n.\n,\n \ngroup\n.\nName\n,\n \nid\n);\n\n  \nDebug\n.\nLog\n \n(\nSuccessfully created a private group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can also create a group with server-side code. This can be useful when the group must be created together with some other record or feature.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nmetadata\n \n=\n \n{\n \n-- Add whatever custom fields you want.\n\n  \nmy_custom_field\n \n=\n \nsome value\n\n\n}\n\n\nlocal\n \ngroup\n \n=\n \n{\n\n  \nName\n \n=\n \nSome unique group name\n,\n\n  \nDescription\n \n=\n \nMy awesome group.\n,\n\n  \nLang\n \n=\n \nen\n,\n\n  \nPrivate\n \n=\n \ntrue\n,\n\n  \nCreatorId\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n,\n\n  \nAvatarUrl\n \n=\n \nurl://somelink\n,\n\n  \nMetadata\n \n=\n \nmetadata\n\n\n}\n\n\nlocal\n \nnew_groups\n \n=\n \n{\n \ngroup\n \n}\n\n\n\nlocal\n \nsuccess\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\ngroups_create\n,\n \nnew_groups\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nError with groups create: %q\n):\nformat\n(\nerr\n))\n\n\nend\n\n\n\n\n\n\nUpdate a group\n\n\nWhen a group has been created it's admins can update optional fields.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNGroupUpdateMessage\n.\nBuilder\n(\ngroupId\n)\n\n    \n.\nDescription\n(\nA new group description.\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully updated group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nLeave a group\n\n\nA user can leave a group and will no longer be able to join \ngroup chat\n or read \nmessage history\n. If the user is an admin they will only be able to leave when at least one other admin exists in the group.\n\n\n\n\nNote\n\n\nAny user who leaves the group will generate an event message in group chat which other members can read.\n\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupLeaveMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nSuccessfully left the group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nif\n \n(\nerr\n.\nCode\n \n==\n \nErrorCode\n.\nGroupLastAdmin\n)\n \n{\n\n    \n// Must promote another admin before user can leave group.\n\n    \nDebug\n.\nLog\n(\nUnable to leave as last admin.\n);\n\n  \n}\n \nelse\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\nManage groups\n\n\nEach group is managed by one or more admins. These users are members with permission to make changes to optional fields, accept or reject new members, remove members or other admins, and promote other members as admins.\n\n\n\n\nWarning\n\n\nA group must have at least one admin so the last admin will have to promote another member before they can \nleave\n.\n\n\n\n\nAccept new members\n\n\nWhen a user joins a private group it will create a join request until an admin accepts or rejects the user. The admin can accept the user into the group.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupAddUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully added user to group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe user will receive an \nin-app notification\n when they've been added to the group. In a private group an admin will receive a notification about the join request.\n\n\nTo reject the user from joining the group you should \nkick them\n.\n\n\nPromote a member\n\n\nAn admin can promote another member of the group as an admin. This grants the member the same privileges to \nmanage the group\n. A group can have one or more admins.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupPromoteUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully promoted user as an admin.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nTo demote an admin as a member you can kick and re-add them.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nkickMessage\n \n=\n \nNGroupKickUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nkickMessage\n,\n \n(\nbool\n \ncompleted\n)\n \n=\n \n{\n\n  \nvar\n \naddMessage\n \n=\n \nNGroupAddUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n  \nclient\n.\nSend\n(\naddMessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n    \nDebug\n.\nLog\n(\nAdmin user demoted to member in group.\n);\n\n  \n},\n \nerrorHandler\n);\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nKick a member\n\n\nAn admin can kick a member from the group. The user is removed but can rejoin again later unless the group is private in which case an admin must accept the join request.\n\n\nIf a user is removed from a group it does not prevent them from joining other groups.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupKickUserMessage\n.\nDefault\n(\ngroupId\n,\n \nuserId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nSuccessfully kicked user from group.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\nHint\n\n\nSometimes a bad user needs to be kicked from the group and \npermanently banned\n. This will prevent the user from being able to connect to the server and interact at all.\n\n\n\n\nRemove a group\n\n\nA group can only be removed by one of the admins which will disband all members. When a group is removed it's name can be re-used to \ncreate a new group\n.\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNGroupRemoveMessage\n.\nDefault\n(\ngroupId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nThe group has been removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});", 
            "title": "Groups and Clans"
        }, 
        {
            "location": "/social-groups-clans/#groups-and-clans", 
            "text": "A group brings together a bunch of users into a small community or team.  A group is made up of an owner, admins, and members. It can be public or private which determines whether it appears in results when a user searches. Private groups are similar to how Whatsapp groups work. A user can only be added when they're invited to join by one of the group's admins.", 
            "title": "Groups and Clans"
        }, 
        {
            "location": "/social-groups-clans/#search-for-groups", 
            "text": "A user can find public groups to join by a filter on language, recently created, how many members in a group, and more. These filters make it easy to assemble new users into smaller groups for team-based play or collaboration.  var   message   =   new   NGroupsListMessage . Builder () \n     . OrderByAsc ( true ) \n     . FilterByLang ( en ) \n     . Build ();  client . Send ( message ,   ( INResultSet INGroup   list )   =   { \n   foreach   ( var   group   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n     Debug . LogFormat ( Group: name  {0}  id  {1} . ,   group . Name ,   id ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The message response for a list of groups contains a cursor. The cursor can be used to quickly retrieve the next set of results.   Tip  Cursors are used across different server features to page through batches of results quickly and efficiently. It's used with storage, friends, chat history, etc.   var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  var   messageBuilder   =   new   NGroupsListMessage . Builder () \n     . OrderByAsc ( true ) \n     . FilterByLang ( en ); \n     . PageLimit ( 100 );  client . Send ( messageBuilder . Build (),   ( INResultSet INGroup   list )   =   { \n   // Lets get the next page of results. \n   INCursor   cursor   =   list . Cursor ; \n   if   ( cursor   !=   null     list . Results . Count     0 )   { \n     var   message   =   messageBuilder . Cursor ( cursor ). Build (); \n\n     client . Send ( message ,   ( INResultSet INGroup   nextList )   =   { \n       foreach   ( var   group   in   nextList . Results )   { \n         var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n         Debug . LogFormat ( Group: name  {0}  id  {1} . ,   group . Name ,   id ); \n       } \n     },   errorHandler ); \n   }  },   errorHandler );", 
            "title": "Search for groups"
        }, 
        {
            "location": "/social-groups-clans/#join-groups", 
            "text": "When a user has found a group to join they can request to become a member. A public group can be joined without any need for permission while a private group requires an  admin to accept  the user.  A user who's part of a group can join  group chat  and access it's  message history .   Tip  When a user joins or leaves a group event messages are added to chat history. This makes it easy for members to see what's changed in the group.   byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupJoinMessage . Default ( groupId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Requested to join group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The user will receive an  in-app notification  when they've been added to the group. In a private group an admin will receive a notification when a user has requested to join.", 
            "title": "Join groups"
        }, 
        {
            "location": "/social-groups-clans/#list-a-users-groups", 
            "text": "Each user can list groups they've joined as a member or an admin. The list also contains groups which they've requested to join but not been accepted into yet.  var   message   =   NGroupsSelfListMessage . Default ();  client . Send ( message ,   ( INResultSet INGroup   list )   =   { \n   foreach   ( var   group   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n     Debug . LogFormat ( Group: name  {0}  id  {1} . ,   group . Name ,   id ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List a user's groups"
        }, 
        {
            "location": "/social-groups-clans/#list-group-members", 
            "text": "A user can list all members who're part of their group. These include other users who've requested to join the private group but not been accepted into yet.  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupUsersListMessage . Default ( groupId );  client . Send ( message ,   ( INResultSet INGroupUser   list )   =   { \n   foreach   ( var   member   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( member . Id );    // convert byte[]. \n     Debug . LogFormat ( Member id  {0}  with name  {1} . ,   id ,   member . Fullname ); \n     // member.Type is one of: Admin, Member, Join. \n     UserType   status   =   member . Type ; \n     Debug . LogFormat ( Has handle  {0}  with status  {1} . ,   member . Handle ,   status ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List group members"
        }, 
        {
            "location": "/social-groups-clans/#create-a-group", 
            "text": "A group can be created with a name and other optional fields. These optional fields are used when a user  searches for groups . The user who creates the group becomes the owner and an admin for it.  var   metadata   =   { my_custom_field :  some value } ;  var   message   =   new   NGroupCreateMessage . Builder ( Some unique group name ) \n     . Description ( My awesome group. ) \n     . Lang ( en ) \n     . Private ( true ) \n     . AvatarUrl ( url://somelink ) \n     . Metadata ( metadata ) \n     . Build ();  client . Send ( message ,   ( INGroup   group )   =   { \n   var   id   =   Encoding . UTF8 . GetString ( group . Id );    // convert byte[]. \n   Debug . LogFormat ( New group: name  {0}  id  {1} . ,   group . Name ,   id ); \n   Debug . Log   ( Successfully created a private group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can also create a group with server-side code. This can be useful when the group must be created together with some other record or feature.  local   nk   =   require ( nakama )  local   metadata   =   {   -- Add whatever custom fields you want. \n   my_custom_field   =   some value  }  local   group   =   { \n   Name   =   Some unique group name , \n   Description   =   My awesome group. , \n   Lang   =   en , \n   Private   =   true , \n   CreatorId   =   4c2ae592-b2a7-445e-98ec-697694478b1c , \n   AvatarUrl   =   url://somelink , \n   Metadata   =   metadata  }  local   new_groups   =   {   group   }  local   success ,   err   =   pcall ( nk . groups_create ,   new_groups )  if   ( not   success )   then \n   nk . logger_error (( Error with groups create: %q ): format ( err ))  end", 
            "title": "Create a group"
        }, 
        {
            "location": "/social-groups-clans/#update-a-group", 
            "text": "When a group has been created it's admins can update optional fields.  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   new   NGroupUpdateMessage . Builder ( groupId ) \n     . Description ( A new group description. ) \n     . Build ();  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully updated group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Update a group"
        }, 
        {
            "location": "/social-groups-clans/#leave-a-group", 
            "text": "A user can leave a group and will no longer be able to join  group chat  or read  message history . If the user is an admin they will only be able to leave when at least one other admin exists in the group.   Note  Any user who leaves the group will generate an event message in group chat which other members can read.   byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupLeaveMessage . Default ( groupId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log   ( Successfully left the group. );  },   ( INError   err )   =   { \n   if   ( err . Code   ==   ErrorCode . GroupLastAdmin )   { \n     // Must promote another admin before user can leave group. \n     Debug . Log ( Unable to leave as last admin. ); \n   }   else   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   }  });", 
            "title": "Leave a group"
        }, 
        {
            "location": "/social-groups-clans/#manage-groups", 
            "text": "Each group is managed by one or more admins. These users are members with permission to make changes to optional fields, accept or reject new members, remove members or other admins, and promote other members as admins.   Warning  A group must have at least one admin so the last admin will have to promote another member before they can  leave .", 
            "title": "Manage groups"
        }, 
        {
            "location": "/social-groups-clans/#accept-new-members", 
            "text": "When a user joins a private group it will create a join request until an admin accepts or rejects the user. The admin can accept the user into the group.  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   message   =   NGroupAddUserMessage . Default ( groupId ,   userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully added user to group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The user will receive an  in-app notification  when they've been added to the group. In a private group an admin will receive a notification about the join request.  To reject the user from joining the group you should  kick them .", 
            "title": "Accept new members"
        }, 
        {
            "location": "/social-groups-clans/#promote-a-member", 
            "text": "An admin can promote another member of the group as an admin. This grants the member the same privileges to  manage the group . A group can have one or more admins.  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   message   =   NGroupPromoteUserMessage . Default ( groupId ,   userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully promoted user as an admin. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   To demote an admin as a member you can kick and re-add them.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   kickMessage   =   NGroupKickUserMessage . Default ( groupId ,   userId );  client . Send ( kickMessage ,   ( bool   completed )   =   { \n   var   addMessage   =   NGroupAddUserMessage . Default ( groupId ,   userId ); \n   client . Send ( addMessage ,   ( bool   done )   =   { \n     Debug . Log ( Admin user demoted to member in group. ); \n   },   errorHandler );  },   errorHandler );", 
            "title": "Promote a member"
        }, 
        {
            "location": "/social-groups-clans/#kick-a-member", 
            "text": "An admin can kick a member from the group. The user is removed but can rejoin again later unless the group is private in which case an admin must accept the join request.  If a user is removed from a group it does not prevent them from joining other groups.  byte []   groupId   =   group . Id ;   // an INGroup ID.  byte []   userId   =   user . Id ;     // an INUser ID.  var   message   =   NGroupKickUserMessage . Default ( groupId ,   userId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log   ( Successfully kicked user from group. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });    Hint  Sometimes a bad user needs to be kicked from the group and  permanently banned . This will prevent the user from being able to connect to the server and interact at all.", 
            "title": "Kick a member"
        }, 
        {
            "location": "/social-groups-clans/#remove-a-group", 
            "text": "A group can only be removed by one of the admins which will disband all members. When a group is removed it's name can be re-used to  create a new group .  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   NGroupRemoveMessage . Default ( groupId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( The group has been removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Remove a group"
        }, 
        {
            "location": "/social-in-app-notifications/", 
            "text": "In-app Notifications\n\n\nIn-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.\n\n\nA notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.\n\n\nThese notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.\n\n\nSend notifications\n\n\nYou can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.\n\n\n\n\nNote\n\n\nThe code you choose for your notifications must start at \"101\" and upwards. See \nbelow\n for reserved message codes.\n\n\n\n\nA notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.\n\n\nNotifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nuser_ids\n \n=\n \n{\nsomeuserid\n,\n \nanotheruserid\n}\n\n\nlocal\n \nsender_id\n \n=\n \nnil\n   \n-- \nnil\n for server sent.\n\n\nlocal\n \ncontent\n \n=\n \n{\n\n  \nitem_id\n \n=\n \n192308394345345\n,\n\n  \nitem_icon\n \n=\n \nstorm_bringer_sword.png\n\n\n}\n\n\n\nlocal\n \nnotifications\n \n=\n \n{}\n\n\nfor\n \n_\n,\n \nuser_id\n \nin\n \nipairs\n(\nuser_ids\n)\n\n\ndo\n\n  \nlocal\n \nnotification\n \n=\n \n{\n\n    \nUserId\n \n=\n \nuser_id\n,\n\n    \nSenderId\n \n=\n \nsender_id\n,\n\n    \nSubject\n \n=\n \nYou earned a secret item!\n,\n\n    \nContent\n \n=\n \ncontent\n,\n\n    \nCode\n \n=\n \n101\n,\n\n    \nExpiresAt\n \n=\n \n1000\n \n*\n \n60\n \n*\n \n60\n \n*\n \n24\n \n*\n \n7\n,\n  \n-- expires in 7 days.\n\n    \nPersistent\n \n=\n \ntrue\n\n  \n}\n\n  \ntable.insert\n(\nnotifications\n,\n \nnotification\n)\n\n\nend\n\n\n\nnk\n.\nnotification_send_id\n(\nnotifications\n)\n\n\n\n\n\n\nReceive notifications\n\n\nAn event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.\n\n\nclient\n.\nOnNotification\n \n+=\n \n(\nobject\n \nsender\n,\n \nNNotificationEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINNotification\n \nn\n \n=\n \nargs\n.\nNotification\n;\n\n  \nDebug\n.\nLogFormat\n(\nReceived code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nn\n.\nContent\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nReceived id \n{0}\n and content \n{1}\n.\n,\n \nn\n.\nId\n,\n \ncontent\n);\n\n\n};\n\n\n\n\n\n\nList notifications\n\n\nYou can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nn\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nNotice code \n{0}\n and subject \n{1}\n.\n,\n \nn\n.\nCode\n,\n \nn\n.\nSubject\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.\n\n\n\n\nHint\n\n\nYou usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.\n\n\n\n\nIList\nINNotification\n \nallNotifications\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\n\nAction\n \naccumulateNotifications\n \n=\n \ndelegate\n(\nINCursor\n \nresumeCursor\n)\n \n{\n\n  \nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n      \n.\nCursor\n(\nresumeCursor\n)\n\n      \n.\nBuild\n();\n\n  \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n    \nif\n \n(\nlist\n.\nResults\n.\nLength\n \n \n1\n)\n \n{\n\n      \nreturn\n;\n\n    \n}\n \nelse\n \n{\n\n      \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n      \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n \n// recursive async call.\n\n    \n}\n\n  \n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n});\n\n\n};\n\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsListMessage\n.\nDefault\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \nallNotifications\n.\nAddRange\n(\nlist\n.\nResults\n);\n\n  \naccumulateNotifications\n(\nlist\n.\nCursor\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nIt can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.\n\n\nThe resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.\n\n\nINCursor\n \nresumeCursor\n \n=\n \n...;\n \n// stored from last list retrieval.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNNotificationsListMessage\n.\nBuilder\n(\n100\n)\n\n    \n.\nCursor\n(\nresumeCursor\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINNotification\n \nlist\n)\n \n=\n \n{\n\n  \n// use notification list.\n\n  \nresumeCursor\n \n=\n \nlist\n.\nCursor\n;\n \n// cache resume cursor.\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nDelete notifications\n\n\nYou can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.\n\n\nIList\nINNotification\n \nlist\n \n=\n \nnew\n \nList\nINNotification\n();\n\n\nlist\n.\nAdd\n(...);\n \n// Add notification from your internal list\n\n\nvar\n \nmessage\n \n=\n \nNNotificationsRemoveMessage\n.\nDefault\n(\nlist\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nNotifications were removed.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nNotification codes\n\n\nThe server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.\n\n\n\n\n\n\n\n\nCode\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n001\n\n\nUser X wants to chat.\n\n\n\n\n\n\n002\n\n\nUser X wants to add you as a friend.\n\n\n\n\n\n\n003\n\n\nUser X accepted your friend invite.\n\n\n\n\n\n\n004\n\n\nYou've been accepted to X group.\n\n\n\n\n\n\n005\n\n\nUser X wants to join your group.\n\n\n\n\n\n\n006\n\n\nYour friend X has just joined the game.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/social-in-app-notifications/#in-app-notifications", 
            "text": "In-app notifications make it easy to broadcast a message to one or more users. They are great for sending announcements, alerts, or notices of in-game rewards and gifts.  A notification can be stored until read when the app is next opened or it can be pushed so only an active connected user will see it. You can also use notifications to trigger custom actions within your game and change client behavior.  These notifications are viewed within the app which makes them a great companion to push notifications viewed outside the app.", 
            "title": "In-app Notifications"
        }, 
        {
            "location": "/social-in-app-notifications/#send-notifications", 
            "text": "You can send a notification to one or more users with server-side Lua code. It can be sent to any user in the game, no need to be a friend to be able to exchange messages. A number of notifications are also sent by the server implicitly on certain events. Each notification has a code which is used to categorize it.   Note  The code you choose for your notifications must start at \"101\" and upwards. See  below  for reserved message codes.   A notification has content which will be encoded as JSON and must be given an \"expires_at\" value in milliseconds which indicates how long the notification will be available before it's removed. A message cannot be sent which expires in less than 60 seconds.  Notifications can be sent as persistent or not. A non-persistent message will only be received by a client which is currently connected to the server (i.e. a user who is online). If you want to make sure a notification is never lost before it's read it should be marked as persistent when sent.  local   nk   =   require ( nakama )  local   user_ids   =   { someuserid ,   anotheruserid }  local   sender_id   =   nil     --  nil  for server sent.  local   content   =   { \n   item_id   =   192308394345345 , \n   item_icon   =   storm_bringer_sword.png  }  local   notifications   =   {}  for   _ ,   user_id   in   ipairs ( user_ids )  do \n   local   notification   =   { \n     UserId   =   user_id , \n     SenderId   =   sender_id , \n     Subject   =   You earned a secret item! , \n     Content   =   content , \n     Code   =   101 , \n     ExpiresAt   =   1000   *   60   *   60   *   24   *   7 ,    -- expires in 7 days. \n     Persistent   =   true \n   } \n   table.insert ( notifications ,   notification )  end  nk . notification_send_id ( notifications )", 
            "title": "Send notifications"
        }, 
        {
            "location": "/social-in-app-notifications/#receive-notifications", 
            "text": "An event handler can be registered for notifications received when a client is connected. The handler will be called whenever a message is received. When multiple messages are returned (batched for performance) the handler will be called for each notification.  client . OnNotification   +=   ( object   sender ,   NNotificationEventArgs   args )   =   { \n   INNotification   n   =   args . Notification ; \n   Debug . LogFormat ( Received code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   var   content   =   Encoding . UTF8 . GetString ( n . Content );   // convert byte[]. \n   Debug . LogFormat ( Received id  {0}  and content  {1} . ,   n . Id ,   content );  };", 
            "title": "Receive notifications"
        }, 
        {
            "location": "/social-in-app-notifications/#list-notifications", 
            "text": "You can list notifications which were received when the user was offline. These notifications are ones which were marked \"persistent\" when sent. It depends on your game or app but we suggest you retrieve notifications after a client reconnects. You can then display a UI within your game or app with the list.  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   foreach   ( var   n   in   list . Results )   { \n     Debug . LogFormat ( Notice code  {0}  and subject  {1} . ,   n . Code ,   n . Subject ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A list of notifications can be retrieved in batches of up to 100 at a time. To retrieve all messages you should accumulate them with the resume cursor.   Hint  You usually only want to list 100 notifications at a time otherwise you might cause user fatigue. A better option could be to have the UI fetch the next 100 notifications when the user scrolls to the bottom of your UI panel.   IList INNotification   allNotifications   =   new   List INNotification ();  Action   accumulateNotifications   =   delegate ( INCursor   resumeCursor )   { \n   var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n       . Cursor ( resumeCursor ) \n       . Build (); \n   client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n     if   ( list . Results . Length     1 )   { \n       return ; \n     }   else   { \n       allNotifications . AddRange ( list . Results ); \n       accumulateNotifications ( list . Cursor );   // recursive async call. \n     } \n   },   ( INError   err )   =   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   });  };  var   message   =   NNotificationsListMessage . Default ( 100 );  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   allNotifications . AddRange ( list . Results ); \n   accumulateNotifications ( list . Cursor );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   It can be useful to retrieve only notifications which have been added since the list was last retrieved by a client. This can be done with the resume cursor returned with each list message.  The resume cursor marks the position of the most recent notification retrieved. We recommend you store the resume cursor in device storage and use it when the client makes it's next request for recent notifications.  INCursor   resumeCursor   =   ...;   // stored from last list retrieval.  var   message   =   new   NNotificationsListMessage . Builder ( 100 ) \n     . Cursor ( resumeCursor ) \n     . Build ();  client . Send ( message ,   ( INResultSet INNotification   list )   =   { \n   // use notification list. \n   resumeCursor   =   list . Cursor ;   // cache resume cursor.  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List notifications"
        }, 
        {
            "location": "/social-in-app-notifications/#delete-notifications", 
            "text": "You can delete one or more notifications from the client. This is useful to purge notifications which have been read or consumed by the user and prevent a build up of old messages. When a notification is deleted (or it expires), all record of the message is removed from the system and it cannot be restored.  IList INNotification   list   =   new   List INNotification ();  list . Add (...);   // Add notification from your internal list  var   message   =   NNotificationsRemoveMessage . Default ( list );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Notifications were removed. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Delete notifications"
        }, 
        {
            "location": "/social-in-app-notifications/#notification-codes", 
            "text": "The server reserves codes 0 up to 100 for messages sent implicitly on certain events. The code is useful to decide how to display the notification in your UI.     Code  Purpose      001  User X wants to chat.    002  User X wants to add you as a friend.    003  User X accepted your friend invite.    004  You've been accepted to X group.    005  User X wants to join your group.    006  Your friend X has just joined the game.", 
            "title": "Notification codes"
        }, 
        {
            "location": "/social-realtime-chat/", 
            "text": "Realtime Chat\n\n\nRealtime chat makes it easy to power a live community.\n\n\nUsers can chat with each other 1-on-1, as part of a group, and in chat rooms. Messages can contain images, links, and other content. These messages are delivered immediately to clients if the recipients are online and stored in message history so offline users can catch up when they connect.\n\n\nEvery message which flows through the realtime chat engine belongs to a topic which is used internally to identify which users should receive the messages. Users explicitly join and leave topics when they connect. This makes it easy to selectively listen for messages which they care about or decide to \"mute\" certain topics when they're busy. Users can also join multiple topics at once to chat simultaneously in multiple groups or chat rooms.\n\n\nThere are 3 types of topic:\n\n\n\n\n\n\nA chat room is great for public chat. Any user can join and participate without need for permission. These rooms can scale to millions of users all in simultaneous communication. This is perfect for live participation apps or games with live events or tournaments.\n\n\n\n\n\n\nA group chat is private to only users part of a \ngroup\n. Each user must be a member of the group and no other users can participate. You can use group chat with team-based gameplay or collaboration.\n\n\n\n\n\n\nDirect chat is private between two users. Each user will receive a \nnotification\n when they've been invited to chat. Both users must join for messages to be exchanged which prevents spam from bad users.\n\n\n\n\n\n\nReceive messages\n\n\nA user joins a chat topic to start receiving messages in realtime. Each new message is received by an event handler and can be added to your UI. Messages are delivered in the order they are handled by the server.\n\n\nclient\n.\nOnTopicMessage\n \n+=\n \n(\nobject\n \nsource\n,\n \nNTopicMessageEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINTopicMessage\n \nmessage\n \n=\n \nargs\n.\nTopicMessage\n;\n\n  \n// TopicType will be one of DirectMessage, Room, or Group.\n\n  \nDebug\n.\nLogFormat\n(\nReceived a \n{0}\n message.\n,\n \nmessage\n.\nTopic\n.\nTopicType\n);\n\n  \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmessage\n.\nTopic\n.\nId\n);\n     \n// convert byte[].\n\n  \nvar\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmessage\n.\nTopic\n.\nData\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nMessage has id \n{0}\n and content \n{1}\n.\n,\n \nid\n,\n \ndata\n);\n\n\n};\n\n\n\n\n\n\nIn group chat a user will receive other messages from the server. These messages contain events on users who join or leave the group, when someone is promoted as an admin, etc. You may want users to see these messages in the chat stream or ignore them in the UI.\n\n\nYou can identify event messages from chat messages by the message \"Type\".\n\n\nTopicMessageType\n \nmessageType\n \n=\n \nmessage\n.\nType\n;\n \n// enum\n\n\nif\n \n(\nmessageType\n \n!=\n \nTopicMessageType\n.\nChat\n)\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nReceived message with event type \n{0}\n.\n,\n \nmessageType\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nPurpose\n\n\nSource\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\nchat message\n\n\nuser\n\n\nAll messages sent by users.\n\n\n\n\n\n\n1\n\n\njoined group\n\n\nserver\n\n\nAn event message for when a user joined the group.\n\n\n\n\n\n\n2\n\n\nadded to group\n\n\nserver\n\n\nAn event message for when a user was added to the group.\n\n\n\n\n\n\n3\n\n\nleft group\n\n\nserver\n\n\nAn event message for when a user left a group.\n\n\n\n\n\n\n4\n\n\nkicked from group\n\n\nserver\n\n\nAn event message for when an admin kicked a user from the group.\n\n\n\n\n\n\n5\n\n\npromoted in group\n\n\nserver\n\n\nAn event message for when a user is promoted as a group admin.\n\n\n\n\n\n\n\n\nJoin chat\n\n\nTo send messages to other users a user must join the chat topic they want to communicate on. This will also enable messages to be \nreceived in realtime\n.\n\n\n\n\nTip\n\n\nEach user can join many rooms, groups, and direct chat with their session. The same user can also be connected to the same chats from other devices because each device is identified as a separate session.\n\n\n\n\nrooms\n\n\nA room is created dynamically for users to chat. A room has a name and will be setup on the server when any user joins. The list of room names available to join can be stored within client code or via remote configuration with a \nstorage record\n.\n\n\nINTopicId\n \nroomId\n \n=\n \nnull\n;\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \nroomId\n \n=\n \ntopic\n.\nTopic\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined the room.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe \nroomId\n variable contains an ID used to \nsend messages\n.\n\n\ngroups\n\n\nA group chat can only be joined by a user who is a member of the \ngroup\n. Messages are pushed in realtime to group members and they can read \nhistoric messages\n.\n\n\n\n\nNote\n\n\nIf a user is kicked or leaves a group they can no longer receive messages or read history.\n\n\n\n\nA group ID is needed when a user joins group chat and can be \nlisted by the user\n.\n\n\nINTopicId\n \ngroupTopicId\n \n=\n \nnull\n;\n\n\n\nbyte\n[]\n \ngroupId\n \n=\n \ngroup\n.\nId\n;\n \n// an INGroup ID.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicGroup\n(\ngroupId\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \ngroupTopicId\n \n=\n \ntopic\n.\nTopic\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined the group chat.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe \ngroupTopicId\n variable contains an ID used to \nsend messages\n.\n\n\ndirect\n\n\nA user can direct message another user by ID. Each user will not receive messages in realtime until both users have joined the chat. This is important because it prevents spam messages from bad users.\n\n\n\n\nTip\n\n\nFriends, groups, leaderboards, matchmaker, room chat, and searches in storage are all ways to find users for chat.\n\n\n\n\nA user will receive an \nin-app notification\n when a request to chat has been received.\n\n\nINTopicId\n \ndirectTopicId\n \n=\n \nnull\n;\n\n\n\nbyte\n[]\n \nuserId\n \n=\n \nuser\n.\nId\n;\n \n// an INUser ID.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicDirectMessage\n(\nuserId\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \ndirectTopicId\n \n=\n \ntopic\n.\nTopic\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined the direct chat.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe \ndirectTopicId\n variable contains an ID used to \nsend messages\n.\n\n\n\n\nNote\n\n\nA user can \nblock other users\n to stop unwanted direct messages.\n\n\n\n\nList online users\n\n\nEach user who joins a chat becomes a \"presence\" in the chat topic. These presences keep information about which users are online.\n\n\nA presence is made up of a unique session combined with a user ID. This makes it easy to distinguish between the same user connected from multiple devices in the chat topic.\n\n\nThe user who \njoins a chat topic\n receives an initial presence list of all other connected users in the chat topic. An event handler can be used to receive presence changes from the server about users who joined and left. This makes it easy to maintain a list of online users and update it when changes occur.\n\n\n\n\nSummary\n\n\nA list of all online users is received when a user joins a chat topic you can combine it with an event handler which notifies when users join or leave. Together it becomes easy to maintain a list of online users.\n\n\n\n\nIList\nINUserPresence\n \nonlineUsers\n \n=\n \nnew\n \nList\nINUserPresence\n();\n\n\n\nclient\n.\nOnTopicPresence\n \n+=\n \n(\nobject\n \nsource\n,\n \nNTopicPresenceEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINTopicPresence\n \npresenceUpdate\n \n=\n \nargs\n.\nTopicPresence\n;\n\n  \n// Remove all users who left.\n\n  \nforeach\n \n(\nvar\n \nuser\n \nin\n \npresenceUpdate\n.\nLeave\n)\n \n{\n\n    \nonlineUsers\n.\nRemove\n(\nuser\n);\n\n  \n}\n\n  \n// Add all users who joined.\n\n  \nonlineUsers\n.\nAddRange\n(\npresenceUpdate\n.\nJoin\n);\n\n\n};\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicJoinMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopic\n \ntopic\n)\n \n=\n \n{\n\n  \n// Setup initial online user list.\n\n  \nonlineUsers\n.\nAddRange\n(\ntopic\n.\nPresences\n);\n\n  \n// Remove your own user from list.\n\n  \nonlineUsers\n.\nRemove\n(\ntopic\n.\nSelf\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\nTip\n\n\nThe server is optimized to only push presence updates when other users join or leave the chat.\n\n\n\n\nSend messages\n\n\nWhen a user has \njoined a chat topic\n it's ID can be used to send messages with JSON encoded strings.\n\n\nEvery message sent returns an acknowledgement when it's received by the server. The acknowledgement returned contains a message ID, timestamp, and details back about the user who sent it.\n\n\nINTopicId\n \nchatTopicId\n \n=\n \ntopic\n.\nTopic\n;\n \n// A chat topic ID.\n\n\n\nvar\n \njson\n \n=\n \n{\\\nsome\\\n:\\\ndata\\\n}\n;\n\n\nbyte\n[]\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njson\n);\n\n\nvar\n \nmessage\n \n=\n \nNTopicMessageSendMessage\n.\nDefault\n(\nchatTopicId\n,\n \ndata\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINTopicMessageAck\n \nack\n)\n \n=\n \n{\n\n  \nvar\n \nmessageId\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nack\n.\nMessageId\n);\n \n// convert byte[].\n\n  \nDebug\n.\nLogFormat\n(\nNew message sent has id \n{0}\n.\n,\n \nmessageId\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nLeave chat\n\n\nA user can leave a chat topic to no longer be sent messages in realtime. This can be useful to \"mute\" a chat while in some other part of the UI.\n\n\nINTopicId\n \nchatTopicId\n \n=\n \ntopic\n.\nTopic\n;\n \n// A chat topic ID.\n\n\n\nvar\n \nmessage\n \n=\n \nNTopicLeaveMessage\n.\nDefault\n(\nchatTopicId\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully left chat.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nMessage history\n\n\nEvery chat conversation stores a history of messages. The history also contains \nevent messages\n sent by the server with group chat. Each user can retrieve old messages for chat when they next connect online.\n\n\nMessages can be listed in order of most recent to oldest and also in reverse (oldest to newest). Messages are returned in batches of up to 100 each with a cursor for when there are more messages.\n\n\n\n\nTip\n\n\nA user does not have to join a chat topic to see chat history. This is useful to \"peek\" at old messages without the user appearing online in the chat.\n\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\n// Fetch 10 messages on the chat room with oldest first.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNTopicMessagesListMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nForward\n(\nfalse\n)\n\n    \n.\nLimit\n(\n10\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINTopicMessage\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nmsg\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nId\n);\n     \n// convert byte[].\n\n    \nvar\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nData\n);\n \n// convert byte[].\n\n    \nDebug\n.\nLogFormat\n(\nMessage has id \n{0}\n and content \n{1}\n.\n,\n \nid\n,\n \ndata\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA cursor can be used to page after a batch of messages for the next set of results.\n\n\nWe recommend you only list the most recent 100 messages in your UI. A good user experience could be to fetch the next 100 older messages when the user scrolls to the bottom of your UI panel.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nbyte\n[]\n \nroomName\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\nRoom-Name\n);\n \n// convert string.\n\n\nvar\n \nmessageBuilder\n \n=\n \nnew\n \nNTopicMessagesListMessage\n.\nBuilder\n()\n\n    \n.\nTopicRoom\n(\nroomName\n)\n\n    \n.\nLimit\n(\n100\n);\n\n\nclient\n.\nSend\n(\nmessageBuilder\n.\nBuild\n(),\n \n(\nINResultSet\nINTopicMessage\n \nlist\n)\n \n=\n \n{\n\n  \n// Lets get the next page of results.\n\n  \nINCursor\n \ncursor\n \n=\n \nlist\n.\nCursor\n;\n\n  \nif\n \n(\ncursor\n \n!=\n \nnull\n \n \nlist\n.\nResults\n.\nCount\n \n \n0\n)\n \n{\n\n    \nvar\n \nmessage\n \n=\n \nmessageBuilder\n.\nCursor\n(\ncursor\n).\nBuild\n();\n\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINTopicMessage\n \nnextList\n)\n \n=\n \n{\n\n      \nforeach\n \n(\nvar\n \nmsg\n \nin\n \nnextList\n.\nResults\n)\n \n{\n\n        \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nId\n);\n     \n// convert byte[].\n\n        \nvar\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nmsg\n.\nTopic\n.\nData\n);\n \n// convert byte[].\n\n        \nDebug\n.\nLogFormat\n(\nMessage has id \n{0}\n and content \n{1}\n.\n,\n \nid\n,\n \ndata\n);\n\n      \n}\n\n    \n},\n \nerrorHandler\n);\n\n  \n}\n\n\n},\n \nerrorHandler\n);", 
            "title": "Realtime Chat"
        }, 
        {
            "location": "/social-realtime-chat/#realtime-chat", 
            "text": "Realtime chat makes it easy to power a live community.  Users can chat with each other 1-on-1, as part of a group, and in chat rooms. Messages can contain images, links, and other content. These messages are delivered immediately to clients if the recipients are online and stored in message history so offline users can catch up when they connect.  Every message which flows through the realtime chat engine belongs to a topic which is used internally to identify which users should receive the messages. Users explicitly join and leave topics when they connect. This makes it easy to selectively listen for messages which they care about or decide to \"mute\" certain topics when they're busy. Users can also join multiple topics at once to chat simultaneously in multiple groups or chat rooms.  There are 3 types of topic:    A chat room is great for public chat. Any user can join and participate without need for permission. These rooms can scale to millions of users all in simultaneous communication. This is perfect for live participation apps or games with live events or tournaments.    A group chat is private to only users part of a  group . Each user must be a member of the group and no other users can participate. You can use group chat with team-based gameplay or collaboration.    Direct chat is private between two users. Each user will receive a  notification  when they've been invited to chat. Both users must join for messages to be exchanged which prevents spam from bad users.", 
            "title": "Realtime Chat"
        }, 
        {
            "location": "/social-realtime-chat/#receive-messages", 
            "text": "A user joins a chat topic to start receiving messages in realtime. Each new message is received by an event handler and can be added to your UI. Messages are delivered in the order they are handled by the server.  client . OnTopicMessage   +=   ( object   source ,   NTopicMessageEventArgs   args )   =   { \n   INTopicMessage   message   =   args . TopicMessage ; \n   // TopicType will be one of DirectMessage, Room, or Group. \n   Debug . LogFormat ( Received a  {0}  message. ,   message . Topic . TopicType ); \n   var   id   =   Encoding . UTF8 . GetString ( message . Topic . Id );       // convert byte[]. \n   var   data   =   Encoding . UTF8 . GetString ( message . Topic . Data );   // convert byte[]. \n   Debug . LogFormat ( Message has id  {0}  and content  {1} . ,   id ,   data );  };   In group chat a user will receive other messages from the server. These messages contain events on users who join or leave the group, when someone is promoted as an admin, etc. You may want users to see these messages in the chat stream or ignore them in the UI.  You can identify event messages from chat messages by the message \"Type\".  TopicMessageType   messageType   =   message . Type ;   // enum  if   ( messageType   !=   TopicMessageType . Chat )   { \n   Debug . LogFormat ( Received message with event type  {0} . ,   messageType );  }      Type  Purpose  Source  Description      0  chat message  user  All messages sent by users.    1  joined group  server  An event message for when a user joined the group.    2  added to group  server  An event message for when a user was added to the group.    3  left group  server  An event message for when a user left a group.    4  kicked from group  server  An event message for when an admin kicked a user from the group.    5  promoted in group  server  An event message for when a user is promoted as a group admin.", 
            "title": "Receive messages"
        }, 
        {
            "location": "/social-realtime-chat/#join-chat", 
            "text": "To send messages to other users a user must join the chat topic they want to communicate on. This will also enable messages to be  received in realtime .   Tip  Each user can join many rooms, groups, and direct chat with their session. The same user can also be connected to the same chats from other devices because each device is identified as a separate session.", 
            "title": "Join chat"
        }, 
        {
            "location": "/social-realtime-chat/#rooms", 
            "text": "A room is created dynamically for users to chat. A room has a name and will be setup on the server when any user joins. The list of room names available to join can be stored within client code or via remote configuration with a  storage record .  INTopicId   roomId   =   null ;  byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   roomId   =   topic . Topic ; \n   Debug . Log ( Successfully joined the room. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The  roomId  variable contains an ID used to  send messages .", 
            "title": "rooms"
        }, 
        {
            "location": "/social-realtime-chat/#groups", 
            "text": "A group chat can only be joined by a user who is a member of the  group . Messages are pushed in realtime to group members and they can read  historic messages .   Note  If a user is kicked or leaves a group they can no longer receive messages or read history.   A group ID is needed when a user joins group chat and can be  listed by the user .  INTopicId   groupTopicId   =   null ;  byte []   groupId   =   group . Id ;   // an INGroup ID.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicGroup ( groupId ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   groupTopicId   =   topic . Topic ; \n   Debug . Log ( Successfully joined the group chat. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The  groupTopicId  variable contains an ID used to  send messages .", 
            "title": "groups"
        }, 
        {
            "location": "/social-realtime-chat/#direct", 
            "text": "A user can direct message another user by ID. Each user will not receive messages in realtime until both users have joined the chat. This is important because it prevents spam messages from bad users.   Tip  Friends, groups, leaderboards, matchmaker, room chat, and searches in storage are all ways to find users for chat.   A user will receive an  in-app notification  when a request to chat has been received.  INTopicId   directTopicId   =   null ;  byte []   userId   =   user . Id ;   // an INUser ID.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicDirectMessage ( userId ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   directTopicId   =   topic . Topic ; \n   Debug . Log ( Successfully joined the direct chat. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The  directTopicId  variable contains an ID used to  send messages .   Note  A user can  block other users  to stop unwanted direct messages.", 
            "title": "direct"
        }, 
        {
            "location": "/social-realtime-chat/#list-online-users", 
            "text": "Each user who joins a chat becomes a \"presence\" in the chat topic. These presences keep information about which users are online.  A presence is made up of a unique session combined with a user ID. This makes it easy to distinguish between the same user connected from multiple devices in the chat topic.  The user who  joins a chat topic  receives an initial presence list of all other connected users in the chat topic. An event handler can be used to receive presence changes from the server about users who joined and left. This makes it easy to maintain a list of online users and update it when changes occur.   Summary  A list of all online users is received when a user joins a chat topic you can combine it with an event handler which notifies when users join or leave. Together it becomes easy to maintain a list of online users.   IList INUserPresence   onlineUsers   =   new   List INUserPresence ();  client . OnTopicPresence   +=   ( object   source ,   NTopicPresenceEventArgs   args )   =   { \n   INTopicPresence   presenceUpdate   =   args . TopicPresence ; \n   // Remove all users who left. \n   foreach   ( var   user   in   presenceUpdate . Leave )   { \n     onlineUsers . Remove ( user ); \n   } \n   // Add all users who joined. \n   onlineUsers . AddRange ( presenceUpdate . Join );  };  byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  var   message   =   new   NTopicJoinMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Build ();  client . Send ( message ,   ( INTopic   topic )   =   { \n   // Setup initial online user list. \n   onlineUsers . AddRange ( topic . Presences ); \n   // Remove your own user from list. \n   onlineUsers . Remove ( topic . Self );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });    Tip  The server is optimized to only push presence updates when other users join or leave the chat.", 
            "title": "List online users"
        }, 
        {
            "location": "/social-realtime-chat/#send-messages", 
            "text": "When a user has  joined a chat topic  it's ID can be used to send messages with JSON encoded strings.  Every message sent returns an acknowledgement when it's received by the server. The acknowledgement returned contains a message ID, timestamp, and details back about the user who sent it.  INTopicId   chatTopicId   =   topic . Topic ;   // A chat topic ID.  var   json   =   {\\ some\\ :\\ data\\ } ;  byte []   data   =   Encoding . UTF8 . GetBytes ( json );  var   message   =   NTopicMessageSendMessage . Default ( chatTopicId ,   data );  client . Send ( message ,   ( INTopicMessageAck   ack )   =   { \n   var   messageId   =   Encoding . UTF8 . GetString ( ack . MessageId );   // convert byte[]. \n   Debug . LogFormat ( New message sent has id  {0} . ,   messageId );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Send messages"
        }, 
        {
            "location": "/social-realtime-chat/#leave-chat", 
            "text": "A user can leave a chat topic to no longer be sent messages in realtime. This can be useful to \"mute\" a chat while in some other part of the UI.  INTopicId   chatTopicId   =   topic . Topic ;   // A chat topic ID.  var   message   =   NTopicLeaveMessage . Default ( chatTopicId );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully left chat. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Leave chat"
        }, 
        {
            "location": "/social-realtime-chat/#message-history", 
            "text": "Every chat conversation stores a history of messages. The history also contains  event messages  sent by the server with group chat. Each user can retrieve old messages for chat when they next connect online.  Messages can be listed in order of most recent to oldest and also in reverse (oldest to newest). Messages are returned in batches of up to 100 each with a cursor for when there are more messages.   Tip  A user does not have to join a chat topic to see chat history. This is useful to \"peek\" at old messages without the user appearing online in the chat.   byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  // Fetch 10 messages on the chat room with oldest first.  var   message   =   new   NTopicMessagesListMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Forward ( false ) \n     . Limit ( 10 ) \n     . Build ();  client . Send ( message ,   ( INResultSet INTopicMessage   list )   =   { \n   foreach   ( var   msg   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( msg . Topic . Id );       // convert byte[]. \n     var   data   =   Encoding . UTF8 . GetString ( msg . Topic . Data );   // convert byte[]. \n     Debug . LogFormat ( Message has id  {0}  and content  {1} . ,   id ,   data ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A cursor can be used to page after a batch of messages for the next set of results.  We recommend you only list the most recent 100 messages in your UI. A good user experience could be to fetch the next 100 older messages when the user scrolls to the bottom of your UI panel.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  byte []   roomName   =   Encoding . UTF8 . GetBytes ( Room-Name );   // convert string.  var   messageBuilder   =   new   NTopicMessagesListMessage . Builder () \n     . TopicRoom ( roomName ) \n     . Limit ( 100 );  client . Send ( messageBuilder . Build (),   ( INResultSet INTopicMessage   list )   =   { \n   // Lets get the next page of results. \n   INCursor   cursor   =   list . Cursor ; \n   if   ( cursor   !=   null     list . Results . Count     0 )   { \n     var   message   =   messageBuilder . Cursor ( cursor ). Build (); \n\n     client . Send ( message ,   ( INResultSet INTopicMessage   nextList )   =   { \n       foreach   ( var   msg   in   nextList . Results )   { \n         var   id   =   Encoding . UTF8 . GetString ( msg . Topic . Id );       // convert byte[]. \n         var   data   =   Encoding . UTF8 . GetString ( msg . Topic . Data );   // convert byte[]. \n         Debug . LogFormat ( Message has id  {0}  and content  {1} . ,   id ,   data ); \n       } \n     },   errorHandler ); \n   }  },   errorHandler );", 
            "title": "Message history"
        }, 
        {
            "location": "/gameplay-leaderboards/", 
            "text": "Leaderboards\n\n\nLeaderboards are a great way to add a social and competitive element to any game. They're a fun way to drive competition among your players. The server supports an \nunlimited\n number of individual leaderboards with each one as a scoreboard which tracks separate records.\n\n\nThe server has no special requirement on what the score value should represent from your game. A leaderboard is created with a sort order on values. If you're using lap time or currency in records you'll want to order the results in ASC or DESC mode as preferred.\n\n\n\n\nTip\n\n\nYou can use a leaderboard to track any score you like. Some good examples are: highest points, longest survival time, fastest lap time, quickest level completion, and anything else which can be competed over!\n\n\n\n\nLeaderboards are dynamic in the server because they don't need to be preconfigured like would be needed if you've used Google Play Games or Apple Game Center in the past. A leaderboard can be created via server-side code.\n\n\nLeaderboard object\n\n\nEach leaderboard is a collection of records where each record is a ranked score with metadata. A leaderboard is uniquely identified by an ID.\n\n\nLeaderboard records are sorted based on their configured sort order: DESC (default) or ASC. The sort order is decided when a leaderboard is created and cannot be changed later. All leaderboard configuration is immutable once created. You should delete the leaderboard and create a new one if you need to change the sort order.\n\n\nReset schedules\n\n\nYou can assign each leaderboard an optional reset schedule. Records contained in the leaderboard will expire based on this schedule and users will be able to submit new scores for each reset cycle.\n\n\nReset schedules are defined in \nCRON format\n when the leaderboard is created. If a leaderboards has no reset schedule set it will never expire.\n\n\nLeaderboard records\n\n\nEach leaderboard contains a list of records ordered by their scores.\n\n\nRecords belong to an owner usually a user but other objects like a group ID or some other custom ID can be used. Each owner will only have one record per leaderboard. If a leaderboard expires each owner will be able to submit a new score which rolls over.\n\n\nThe score in each record can be updated as the owner progresses. Scores can be updated as often as wanted and can increase or decrease. A record has some builtin fields like lang, location, and timezone. These values are used to filter leaderboard results.\n\n\nCustom fields\n\n\nEach record can optionally include additional data about the score or the owner when submitted. The extra fields must be JSON encoded and submitted as the metadata. A good use case for metadata is info about race conditions in a driving game, such as weather, which can give extra UI hints when users list scores.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\nvar\n \nscore\n \n=\n \n1200\n;\n\n\n\n// add custom fields with each record.\n\n\nvar\n \njsonString\n \n=\n \n{\\\nrace_conditions\\\n: [\\\nsunny\\\n, \\\nclear\\\n]}\n;\n\n\nbyte\n[]\n \nmetadata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njsonString\n);\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordWriteMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nSet\n(\nscore\n)\n\n    \n.\nMetadata\n(\nmetadata\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINLeaderboardRecord\n \nresult\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nresult\n.\nHandle\n,\n \nresult\n.\nScore\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nCreate a leaderboard\n\n\nA leaderboard can be created via server-side code at startup or within a \nregistered function\n. The ID given to the leaderboard is used to submit scores to it.\n\n\nlocal\n \nmetadata\n \n=\n \n{\n\n  \nweather_conditions\n \n=\n \nrain\n\n\n}\n\n\nlocal\n \nid\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n\n\nnk\n.\nleaderboard_create\n(\nid\n,\n \ndesc\n,\n \n0 0 * * 1\n,\n \nmetadata\n,\n \nfalse\n)\n\n\n\n\n\n\nList leaderboards\n\n\nAll leaderboards can be listed by a user.\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardsListMessage\n.\nBuilder\n().\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboard\n \nlist\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nFound \n{0}\n leaderboards.\n,\n \nlist\n.\nResults\n.\nCount\n);\n\n\n  \nforeach\n \n(\nvar\n \nleaderboard\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nleaderboard\n.\nId\n);\n\n    \nDebug\n.\nLogFormat\n(\nLeaderboard id \n{0}\n and sort \n{1}\n,\n \nid\n,\n \nleaderboard\n.\nSort\n);\n\n    \nvar\n \nmetadata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nleaderboard\n.\nMetadata\n);\n\n    \nDebug\n.\nLogFormat\n(\nLeaderboard metadata \n{0}\n,\n \nmetadata\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nWhen you have more than 100 leaderboards you can fetch the next set of results with a cursor.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nvar\n \nmessageBuilder\n \n=\n \nnew\n \nNLeaderboardsListMessage\n.\nBuilder\n();\n\n\nclient\n.\nSend\n(\nmessageBuilder\n.\nBuild\n(),\n \n(\nINResultSet\nINLeaderboard\n \nlist\n)\n \n=\n \n{\n\n  \n// Lets get the next page of results.\n\n  \nINCursor\n \ncursor\n \n=\n \nlist\n.\nCursor\n;\n\n  \nif\n \n(\ncursor\n \n!=\n \nnull\n \n \nlist\n.\nResults\n.\nCount\n \n \n0\n)\n \n{\n\n    \nvar\n \nmessage\n \n=\n \nmessageBuilder\n.\nCursor\n(\ncursor\n).\nBuild\n();\n\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboard\n \nnextList\n)\n \n=\n \n{\n\n      \nforeach\n \n(\nvar\n \nl\n \nin\n \nnextList\n.\nResults\n)\n \n{\n\n        \nvar\n \nid\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nl\n.\nId\n);\n\n        \nDebug\n.\nLogFormat\n(\nLeaderboard id \n{0}\n and sort \n{1}\n,\n \nid\n,\n \nl\n.\nSort\n);\n\n        \nvar\n \nmetadata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nl\n.\nMetadata\n);\n\n        \nDebug\n.\nLogFormat\n(\nLeaderboard metadata \n{0}\n,\n \nmetadata\n);\n\n      \n}\n\n    \n},\n \nerrorHandler\n);\n\n  \n}\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nSubmit a score\n\n\nA user can submit a score to a leaderboard and update it at any time. When a score is submitted it's sent with an operator which indicates how the new value should change the current score stored. The operators are: \"set\", \"best\", \"inc\", \"decr\".\n\n\nSet operator\n\n\nThe set operator will submit the score and replace any current value for the owner.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\nvar\n \nscore\n \n=\n \n1200\n;\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordWriteMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nSet\n(\nscore\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINLeaderboardRecord\n \nresult\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nresult\n.\nHandle\n,\n \nresult\n.\nScore\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nBest operator\n\n\nThe best operator will check the new score is better than the current score and keep which ever value is best based on the sort order of the leaderboard. If no score exists this operator works like \"set\".\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\nvar\n \nscore\n \n=\n \n1200\n;\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordWriteMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nBest\n(\nscore\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINLeaderboardRecord\n \nresult\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nresult\n.\nHandle\n,\n \nresult\n.\nScore\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nIncrement operator\n\n\nThe increment operator will add the score value to the current score. If no score exists the new score will be added to 0.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\nvar\n \nscore\n \n=\n \n1200\n;\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordWriteMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nIncrement\n(\nscore\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINLeaderboardRecord\n \nresult\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nresult\n.\nHandle\n,\n \nresult\n.\nScore\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nDecrement operator\n\n\nThe decrement operator will subtract the score value from the current score. If no score exists the new score will be subtracted from 0.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\nvar\n \nscore\n \n=\n \n1200\n;\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordWriteMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nDecrement\n(\nscore\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINLeaderboardRecord\n \nresult\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nresult\n.\nHandle\n,\n \nresult\n.\nScore\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nList records\n\n\nA user can list records from a leaderboard. This makes it easy to compare scores to other users and see their positions.\n\n\nList by score\n\n\nThe standard way to list records is ordered by score based on the sort order in the leaderboard.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordsListMessage\n.\nBuilder\n(\nid\n).\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboardRecord\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nr\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nr\n.\nHandle\n,\n \nr\n.\nScore\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can fetch the next set of results with a cursor.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\n\nvar\n \nmessageBuilder\n \n=\n \nnew\n \nNLeaderboardRecordsListMessage\n.\nBuilder\n(\nid\n);\n\n\nclient\n.\nSend\n(\nmessage\n.\nBuild\n(),\n \n(\nINResultSet\nINLeaderboardRecord\n \nlist\n)\n \n=\n \n{\n\n  \n// Lets get the next page of results.\n\n  \nINCursor\n \ncursor\n \n=\n \nlist\n.\nCursor\n;\n\n  \nif\n \n(\ncursor\n \n!=\n \nnull\n \n \nlist\n.\nResults\n.\nCount\n \n \n0\n)\n \n{\n\n    \nvar\n \nmessage\n \n=\n \nmessageBuilder\n.\nCursor\n(\ncursor\n).\nBuild\n();\n\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboardRecord\n \nnextList\n)\n \n=\n \n{\n\n      \nforeach\n \n(\nvar\n \nr\n \nin\n \nnextList\n.\nResults\n)\n \n{\n\n        \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nr\n.\nHandle\n,\n \nr\n.\nScore\n);\n\n      \n}\n\n    \n},\n \nerrorHandler\n);\n\n  \n}\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nList by filter\n\n\nYou can add a filter on one of \"lang\", \"location\", or \"timezone\".\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordsListMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nFilterByLocation\n(\nSan Francisco\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboardRecord\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nr\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nr\n.\nHandle\n,\n \nr\n.\nScore\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nList by friends\n\n\nYou can use a bunch of owner IDs to filter the records to only ones owned by those users. This can be used to retrieve only scores belonging to the user's friends.\n\n\nIList\nbyte\n[]\n \nownerIds\n \n=\n \nnew\n \nList\nbyte\n[]\n();\n\n\nownerIds\n.\nAdd\n(\nuser\n.\nId\n);\n \n// an INUser Id.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordsListMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nFilterByOwnerIds\n(\nownerIds\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboardRecord\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nr\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nr\n.\nHandle\n,\n \nr\n.\nScore\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nFind current user\n\n\nA leaderboard can be \"scrolled\" to the page which contains a record owner. This can be used to give users a view of their own position within a leaderboard.\n\n\nbyte\n[]\n \nid\n \n=\n \nleaderboard\n.\nId\n;\n \n// an INLeaderboard Id.\n\n\nbyte\n[]\n \nownerId\n \n=\n \nuser\n.\nId\n;\n   \n// an INUser Id.\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNLeaderboardRecordsListMessage\n.\nBuilder\n(\nid\n)\n\n    \n.\nFilterByPagingToOwnerId\n(\nownerId\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINLeaderboardRecord\n \nlist\n)\n \n=\n \n{\n\n  \nforeach\n \n(\nvar\n \nr\n \nin\n \nlist\n.\nResults\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nRecord handle \n{0}\n score \n{1}\n.\n,\n \nr\n.\nHandle\n,\n \nr\n.\nScore\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});", 
            "title": "Leaderboards"
        }, 
        {
            "location": "/gameplay-leaderboards/#leaderboards", 
            "text": "Leaderboards are a great way to add a social and competitive element to any game. They're a fun way to drive competition among your players. The server supports an  unlimited  number of individual leaderboards with each one as a scoreboard which tracks separate records.  The server has no special requirement on what the score value should represent from your game. A leaderboard is created with a sort order on values. If you're using lap time or currency in records you'll want to order the results in ASC or DESC mode as preferred.   Tip  You can use a leaderboard to track any score you like. Some good examples are: highest points, longest survival time, fastest lap time, quickest level completion, and anything else which can be competed over!   Leaderboards are dynamic in the server because they don't need to be preconfigured like would be needed if you've used Google Play Games or Apple Game Center in the past. A leaderboard can be created via server-side code.", 
            "title": "Leaderboards"
        }, 
        {
            "location": "/gameplay-leaderboards/#leaderboard-object", 
            "text": "Each leaderboard is a collection of records where each record is a ranked score with metadata. A leaderboard is uniquely identified by an ID.  Leaderboard records are sorted based on their configured sort order: DESC (default) or ASC. The sort order is decided when a leaderboard is created and cannot be changed later. All leaderboard configuration is immutable once created. You should delete the leaderboard and create a new one if you need to change the sort order.", 
            "title": "Leaderboard object"
        }, 
        {
            "location": "/gameplay-leaderboards/#reset-schedules", 
            "text": "You can assign each leaderboard an optional reset schedule. Records contained in the leaderboard will expire based on this schedule and users will be able to submit new scores for each reset cycle.  Reset schedules are defined in  CRON format  when the leaderboard is created. If a leaderboards has no reset schedule set it will never expire.", 
            "title": "Reset schedules"
        }, 
        {
            "location": "/gameplay-leaderboards/#leaderboard-records", 
            "text": "Each leaderboard contains a list of records ordered by their scores.  Records belong to an owner usually a user but other objects like a group ID or some other custom ID can be used. Each owner will only have one record per leaderboard. If a leaderboard expires each owner will be able to submit a new score which rolls over.  The score in each record can be updated as the owner progresses. Scores can be updated as often as wanted and can increase or decrease. A record has some builtin fields like lang, location, and timezone. These values are used to filter leaderboard results.", 
            "title": "Leaderboard records"
        }, 
        {
            "location": "/gameplay-leaderboards/#custom-fields", 
            "text": "Each record can optionally include additional data about the score or the owner when submitted. The extra fields must be JSON encoded and submitted as the metadata. A good use case for metadata is info about race conditions in a driving game, such as weather, which can give extra UI hints when users list scores.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   score   =   1200 ;  // add custom fields with each record.  var   jsonString   =   {\\ race_conditions\\ : [\\ sunny\\ , \\ clear\\ ]} ;  byte []   metadata   =   Encoding . UTF8 . GetBytes ( jsonString );  var   message   =   new   NLeaderboardRecordWriteMessage . Builder ( id ) \n     . Set ( score ) \n     . Metadata ( metadata ) \n     . Build ();  client . Send ( message ,   ( INLeaderboardRecord   result )   =   { \n   Debug . LogFormat ( Record handle  {0}  score  {1} . ,   result . Handle ,   result . Score );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Custom fields"
        }, 
        {
            "location": "/gameplay-leaderboards/#create-a-leaderboard", 
            "text": "A leaderboard can be created via server-side code at startup or within a  registered function . The ID given to the leaderboard is used to submit scores to it.  local   metadata   =   { \n   weather_conditions   =   rain  }  local   id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521  nk . leaderboard_create ( id ,   desc ,   0 0 * * 1 ,   metadata ,   false )", 
            "title": "Create a leaderboard"
        }, 
        {
            "location": "/gameplay-leaderboards/#list-leaderboards", 
            "text": "All leaderboards can be listed by a user.  var   message   =   new   NLeaderboardsListMessage . Builder (). Build ();  client . Send ( message ,   ( INResultSet INLeaderboard   list )   =   { \n   Debug . LogFormat ( Found  {0}  leaderboards. ,   list . Results . Count ); \n\n   foreach   ( var   leaderboard   in   list . Results )   { \n     var   id   =   Encoding . UTF8 . GetString ( leaderboard . Id ); \n     Debug . LogFormat ( Leaderboard id  {0}  and sort  {1} ,   id ,   leaderboard . Sort ); \n     var   metadata   =   Encoding . UTF8 . GetString ( leaderboard . Metadata ); \n     Debug . LogFormat ( Leaderboard metadata  {0} ,   metadata ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   When you have more than 100 leaderboards you can fetch the next set of results with a cursor.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  var   messageBuilder   =   new   NLeaderboardsListMessage . Builder ();  client . Send ( messageBuilder . Build (),   ( INResultSet INLeaderboard   list )   =   { \n   // Lets get the next page of results. \n   INCursor   cursor   =   list . Cursor ; \n   if   ( cursor   !=   null     list . Results . Count     0 )   { \n     var   message   =   messageBuilder . Cursor ( cursor ). Build (); \n\n     client . Send ( message ,   ( INResultSet INLeaderboard   nextList )   =   { \n       foreach   ( var   l   in   nextList . Results )   { \n         var   id   =   Encoding . UTF8 . GetString ( l . Id ); \n         Debug . LogFormat ( Leaderboard id  {0}  and sort  {1} ,   id ,   l . Sort ); \n         var   metadata   =   Encoding . UTF8 . GetString ( l . Metadata ); \n         Debug . LogFormat ( Leaderboard metadata  {0} ,   metadata ); \n       } \n     },   errorHandler ); \n   }  },   errorHandler );", 
            "title": "List leaderboards"
        }, 
        {
            "location": "/gameplay-leaderboards/#submit-a-score", 
            "text": "A user can submit a score to a leaderboard and update it at any time. When a score is submitted it's sent with an operator which indicates how the new value should change the current score stored. The operators are: \"set\", \"best\", \"inc\", \"decr\".", 
            "title": "Submit a score"
        }, 
        {
            "location": "/gameplay-leaderboards/#set-operator", 
            "text": "The set operator will submit the score and replace any current value for the owner.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   score   =   1200 ;  var   message   =   new   NLeaderboardRecordWriteMessage . Builder ( id ) \n     . Set ( score ) \n     . Build ();  client . Send ( message ,   ( INLeaderboardRecord   result )   =   { \n   Debug . LogFormat ( Record handle  {0}  score  {1} . ,   result . Handle ,   result . Score );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Set operator"
        }, 
        {
            "location": "/gameplay-leaderboards/#best-operator", 
            "text": "The best operator will check the new score is better than the current score and keep which ever value is best based on the sort order of the leaderboard. If no score exists this operator works like \"set\".  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   score   =   1200 ;  var   message   =   new   NLeaderboardRecordWriteMessage . Builder ( id ) \n     . Best ( score ) \n     . Build ();  client . Send ( message ,   ( INLeaderboardRecord   result )   =   { \n   Debug . LogFormat ( Record handle  {0}  score  {1} . ,   result . Handle ,   result . Score );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Best operator"
        }, 
        {
            "location": "/gameplay-leaderboards/#increment-operator", 
            "text": "The increment operator will add the score value to the current score. If no score exists the new score will be added to 0.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   score   =   1200 ;  var   message   =   new   NLeaderboardRecordWriteMessage . Builder ( id ) \n     . Increment ( score ) \n     . Build ();  client . Send ( message ,   ( INLeaderboardRecord   result )   =   { \n   Debug . LogFormat ( Record handle  {0}  score  {1} . ,   result . Handle ,   result . Score );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Increment operator"
        }, 
        {
            "location": "/gameplay-leaderboards/#decrement-operator", 
            "text": "The decrement operator will subtract the score value from the current score. If no score exists the new score will be subtracted from 0.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   score   =   1200 ;  var   message   =   new   NLeaderboardRecordWriteMessage . Builder ( id ) \n     . Decrement ( score ) \n     . Build ();  client . Send ( message ,   ( INLeaderboardRecord   result )   =   { \n   Debug . LogFormat ( Record handle  {0}  score  {1} . ,   result . Handle ,   result . Score );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Decrement operator"
        }, 
        {
            "location": "/gameplay-leaderboards/#list-records", 
            "text": "A user can list records from a leaderboard. This makes it easy to compare scores to other users and see their positions.", 
            "title": "List records"
        }, 
        {
            "location": "/gameplay-leaderboards/#list-by-score", 
            "text": "The standard way to list records is ordered by score based on the sort order in the leaderboard.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   message   =   new   NLeaderboardRecordsListMessage . Builder ( id ). Build ();  client . Send ( message ,   ( INResultSet INLeaderboardRecord   list )   =   { \n   foreach   ( var   r   in   list . Results )   { \n     Debug . LogFormat ( Record handle  {0}  score  {1} . ,   r . Handle ,   r . Score ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can fetch the next set of results with a cursor.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   messageBuilder   =   new   NLeaderboardRecordsListMessage . Builder ( id );  client . Send ( message . Build (),   ( INResultSet INLeaderboardRecord   list )   =   { \n   // Lets get the next page of results. \n   INCursor   cursor   =   list . Cursor ; \n   if   ( cursor   !=   null     list . Results . Count     0 )   { \n     var   message   =   messageBuilder . Cursor ( cursor ). Build (); \n\n     client . Send ( message ,   ( INResultSet INLeaderboardRecord   nextList )   =   { \n       foreach   ( var   r   in   nextList . Results )   { \n         Debug . LogFormat ( Record handle  {0}  score  {1} . ,   r . Handle ,   r . Score ); \n       } \n     },   errorHandler ); \n   }  },   errorHandler );", 
            "title": "List by score"
        }, 
        {
            "location": "/gameplay-leaderboards/#list-by-filter", 
            "text": "You can add a filter on one of \"lang\", \"location\", or \"timezone\".  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   message   =   new   NLeaderboardRecordsListMessage . Builder ( id ) \n     . FilterByLocation ( San Francisco ) \n     . Build ();  client . Send ( message ,   ( INResultSet INLeaderboardRecord   list )   =   { \n   foreach   ( var   r   in   list . Results )   { \n     Debug . LogFormat ( Record handle  {0}  score  {1} . ,   r . Handle ,   r . Score ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List by filter"
        }, 
        {
            "location": "/gameplay-leaderboards/#list-by-friends", 
            "text": "You can use a bunch of owner IDs to filter the records to only ones owned by those users. This can be used to retrieve only scores belonging to the user's friends.  IList byte []   ownerIds   =   new   List byte [] ();  ownerIds . Add ( user . Id );   // an INUser Id.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  var   message   =   new   NLeaderboardRecordsListMessage . Builder ( id ) \n     . FilterByOwnerIds ( ownerIds ) \n     . Build ();  client . Send ( message ,   ( INResultSet INLeaderboardRecord   list )   =   { \n   foreach   ( var   r   in   list . Results )   { \n     Debug . LogFormat ( Record handle  {0}  score  {1} . ,   r . Handle ,   r . Score ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "List by friends"
        }, 
        {
            "location": "/gameplay-leaderboards/#find-current-user", 
            "text": "A leaderboard can be \"scrolled\" to the page which contains a record owner. This can be used to give users a view of their own position within a leaderboard.  byte []   id   =   leaderboard . Id ;   // an INLeaderboard Id.  byte []   ownerId   =   user . Id ;     // an INUser Id.  var   message   =   new   NLeaderboardRecordsListMessage . Builder ( id ) \n     . FilterByPagingToOwnerId ( ownerId ) \n     . Build ();  client . Send ( message ,   ( INResultSet INLeaderboardRecord   list )   =   { \n   foreach   ( var   r   in   list . Results )   { \n     Debug . LogFormat ( Record handle  {0}  score  {1} . ,   r . Handle ,   r . Score ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Find current user"
        }, 
        {
            "location": "/gameplay-matchmaker/", 
            "text": "Matchmaker\n\n\nIn realtime and turn-based games it's important to be able to find active opponents to play against. A matchmaker system is designed to provide this kind of behavior.\n\n\nIn the server we've taken the design further and decoupled how you're matched from the realtime multiplayer engine. This makes it easy to use the matchmaker system to find opponents even if the gameplay isn't realtime. It could be a casual social game where you want to find random new users to become friends with or an asynchronous PvP game where gameplay happens in a simulated battle.\n\n\nThere's many kinds of gameplay experiences where you'd like to find other users outside of a realtime match.\n\n\nRequest opponents\n\n\nThe distributed server maintains a pool of users who've requested to be matched together with a specific number of opponents. Each user can add themselves to the matchmaker pool and register an event handler to be notified when enough users meet their criteria to be matched.\n\n\nYou can send a message to add the user to the matchmaker pool.\n\n\nINMatchmakeTicket\n \nmatchmake\n \n=\n \nnull\n;\n\n\n\n// Look for a match for two participants. Yourself and one more.\n\n\nvar\n \nmessage\n \n=\n \nNMatchmakeAddMessage\n.\nDefault\n(\n2\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINMatchmakeTicket\n \nresult\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nAdded user to matchmaker pool.\n);\n\n\n  \nvar\n \ncancelTicket\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nresult\n.\nTicket\n);\n\n  \nDebug\n.\nLogFormat\n(\nThe cancellation code {0}\n,\n \ncancelTicket\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe message returns a ticket which can be used to cancel the matchmake attempt. A user can remove themselves from the pool if wanted.\n\n\nThis is useful for some games where a user can cancel their action to matchmake at some later point and remove themselves being matched with other users.\n\n\nReceive matchmake results\n\n\nYou can register an event handler which is called when the server has found opponents for the user.\n\n\nclient\n.\nOnMatchmakeMatched\n \n+=\n \n(\nobject\n \nsource\n,\n \nNMatchmakeMatchedEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINMatchmakeMatched\n \nmatched\n \n=\n \nargs\n.\nMatched\n;\n\n  \n// a match token is used to join the match.\n\n  \nDebug\n.\nLogFormat\n(\nMatch token: \n{0}\n,\n \nmatched\n.\nToken\n);\n\n\n  \n// a list of users who\nve been matched as opponents.\n\n  \nforeach\n \n(\nvar\n \npresence\n \nin\n \nmatched\n.\nPresence\n)\n \n{\n\n    \nDebug\n.\nLogFormat\n(\nUser id: \n{0}\n.\n,\n \npresence\n.\nUserId\n);\n\n    \nDebug\n.\nLogFormat\n(\nUser handle: \n{0}\n.\n,\n \npresence\n.\nHandle\n);\n\n  \n}\n\n\n};\n\n\n\n\n\n\nCancel a request\n\n\nAfter a user has sent a message to add themselves to the matchmaker pool you'll receive a ticket which can be used to cancel the action at some later point.\n\n\nUsers may cancel matchmake actions at any point after they've added themselves to the pool but before they've been matched. Once matching completes for the ticket it can no longer be used to cancel.\n\n\nINMatchmakeTicket\n \ncancelTicket\n \n=\n \nresult\n;\n \n// See above.\n\n\n\nvar\n \nmessage\n \n=\n \nNMatchmakeRemoveMessage\n.\nDefault\n(\ncancelTicket\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nUser removed from matchmaker pool.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe user is now removed from the matchmaker pool.\n\n\n\n\nRemoved on disconnect\n\n\nA user will automatically be removed from the matchmaker pool by the server when they disconnect.\n\n\n\n\nJoin a match\n\n\nTo join a match after the event handler has notified the user their criteria is met and they've been given opponents you can use the match token.\n\n\nclient\n.\nOnMatchmakeMatched\n \n+=\n \n(\nobject\n \nsource\n,\n \nNMatchmakeMatchedEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINMatchmakeMatched\n \nmatched\n \n=\n \nargs\n.\nMatched\n;\n\n\n  \n// The match token is used to join a multiplayer match.\n\n  \nvar\n \nmessage\n \n=\n \nNMatchJoinMessage\n.\nDefault\n(\nmatched\n.\nToken\n);\n\n  \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINMatch\n \nmatch\n)\n \n=\n \n{\n\n    \nDebug\n.\nLog\n(\nSuccessfully joined match.\n);\n\n  \n},\n \n(\nINError\n \nerror\n)\n \n=\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n  \n});\n\n\n};\n\n\n\n\n\n\nThe token makes it easy to join a match. The token enables the server to know that these users wanted to join a match and is able to create a match dynamically for them.\n\n\nTokens are short-lived and must be used to join a match as soon as possible. When a token expires it can no longer be used or refreshed.\n\n\nThe match token is also used to prevent unwanted users from attempting to join a match they were not matched into. The rest of the multiplayer match code in the same as in the \nrealtime multiplayer section\n.", 
            "title": "Matchmaker"
        }, 
        {
            "location": "/gameplay-matchmaker/#matchmaker", 
            "text": "In realtime and turn-based games it's important to be able to find active opponents to play against. A matchmaker system is designed to provide this kind of behavior.  In the server we've taken the design further and decoupled how you're matched from the realtime multiplayer engine. This makes it easy to use the matchmaker system to find opponents even if the gameplay isn't realtime. It could be a casual social game where you want to find random new users to become friends with or an asynchronous PvP game where gameplay happens in a simulated battle.  There's many kinds of gameplay experiences where you'd like to find other users outside of a realtime match.", 
            "title": "Matchmaker"
        }, 
        {
            "location": "/gameplay-matchmaker/#request-opponents", 
            "text": "The distributed server maintains a pool of users who've requested to be matched together with a specific number of opponents. Each user can add themselves to the matchmaker pool and register an event handler to be notified when enough users meet their criteria to be matched.  You can send a message to add the user to the matchmaker pool.  INMatchmakeTicket   matchmake   =   null ;  // Look for a match for two participants. Yourself and one more.  var   message   =   NMatchmakeAddMessage . Default ( 2 );  client . Send ( message ,   ( INMatchmakeTicket   result )   =   { \n   Debug . Log ( Added user to matchmaker pool. ); \n\n   var   cancelTicket   =   Encoding . UTF8 . GetString ( result . Ticket ); \n   Debug . LogFormat ( The cancellation code {0} ,   cancelTicket );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The message returns a ticket which can be used to cancel the matchmake attempt. A user can remove themselves from the pool if wanted.  This is useful for some games where a user can cancel their action to matchmake at some later point and remove themselves being matched with other users.", 
            "title": "Request opponents"
        }, 
        {
            "location": "/gameplay-matchmaker/#receive-matchmake-results", 
            "text": "You can register an event handler which is called when the server has found opponents for the user.  client . OnMatchmakeMatched   +=   ( object   source ,   NMatchmakeMatchedEventArgs   args )   =   { \n   INMatchmakeMatched   matched   =   args . Matched ; \n   // a match token is used to join the match. \n   Debug . LogFormat ( Match token:  {0} ,   matched . Token ); \n\n   // a list of users who ve been matched as opponents. \n   foreach   ( var   presence   in   matched . Presence )   { \n     Debug . LogFormat ( User id:  {0} . ,   presence . UserId ); \n     Debug . LogFormat ( User handle:  {0} . ,   presence . Handle ); \n   }  };", 
            "title": "Receive matchmake results"
        }, 
        {
            "location": "/gameplay-matchmaker/#cancel-a-request", 
            "text": "After a user has sent a message to add themselves to the matchmaker pool you'll receive a ticket which can be used to cancel the action at some later point.  Users may cancel matchmake actions at any point after they've added themselves to the pool but before they've been matched. Once matching completes for the ticket it can no longer be used to cancel.  INMatchmakeTicket   cancelTicket   =   result ;   // See above.  var   message   =   NMatchmakeRemoveMessage . Default ( cancelTicket );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( User removed from matchmaker pool. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The user is now removed from the matchmaker pool.   Removed on disconnect  A user will automatically be removed from the matchmaker pool by the server when they disconnect.", 
            "title": "Cancel a request"
        }, 
        {
            "location": "/gameplay-matchmaker/#join-a-match", 
            "text": "To join a match after the event handler has notified the user their criteria is met and they've been given opponents you can use the match token.  client . OnMatchmakeMatched   +=   ( object   source ,   NMatchmakeMatchedEventArgs   args )   =   { \n   INMatchmakeMatched   matched   =   args . Matched ; \n\n   // The match token is used to join a multiplayer match. \n   var   message   =   NMatchJoinMessage . Default ( matched . Token ); \n   client . Send ( message ,   ( INMatch   match )   =   { \n     Debug . Log ( Successfully joined match. ); \n   },   ( INError   error )   =   { \n     Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message ); \n   });  };   The token makes it easy to join a match. The token enables the server to know that these users wanted to join a match and is able to create a match dynamically for them.  Tokens are short-lived and must be used to join a match as soon as possible. When a token expires it can no longer be used or refreshed.  The match token is also used to prevent unwanted users from attempting to join a match they were not matched into. The rest of the multiplayer match code in the same as in the  realtime multiplayer section .", 
            "title": "Join a match"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/", 
            "text": "Realtime Multiplayer\n\n\nThe realtime multiplayer engine makes it easy for users to set up and join matches where they can rapidly exchange data with opponents.\n\n\nAny user can participate in matches with other users. Users can create, join, and leave matches with messages sent from clients. A match exists on the server until its last participant has left.\n\n\nAny data sent through a match is immediately routed to all other match opponents. Matches are kept in-memory but can be persisted as needed.\n\n\nCreate a match\n\n\nA match can be created by a user. The server will assign a unique ID which can be shared with other users for them to \njoin the match\n. All users within a match are equal and it is up to the clients to decide on a host.\n\n\nvar\n \nmessage\n \n=\n \nNMatchCreateMessage\n.\nDefault\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINMatch\n \nmatch\n)\n \n=\n \n{\n\n  \nbyte\n[]\n \nid\n \n=\n \nmatch\n.\nId\n;\n\n  \nDebug\n.\nLog\n(\nSuccessfully created match.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nA user can \nleave a match\n at any point which will notify all other users.\n\n\nJoin a match\n\n\nA user can join a specific match by ID. Matches can be joined at any point until the last participant leaves.\n\n\n\n\nHint\n\n\nTo find a match instead of specify one by ID use the \nmatchmaker\n.\n\n\n\n\nbyte\n[]\n \nid\n \n=\n \nmatch\n.\nId\n;\n \n// an INMatch Id.\n\n\n\nvar\n \nmessage\n \n=\n \nNMatchJoinMessage\n.\nDefault\n(\nid\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINMatch\n \nmatch\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully joined match.\n);\n\n\n  \nIList\nINUserPresence\n \nconnectedOpponents\n \n=\n \nnew\n \nList\nINUserPresence\n();\n\n  \n// Add list of connected opponents.\n\n  \nconnectedOpponents\n.\nAddRange\n(\nmatch\n.\nPresence\n);\n\n  \n// Remove your own user from list.\n\n  \nconnectedOpponents\n.\nRemove\n(\nmatch\n.\nSelf\n);\n\n\n  \nforeach\n \n(\nvar\n \npresence\n \nin\n \nconnectedOpponents\n)\n \n{\n\n    \nvar\n \nuserId\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\npresence\n.\nUserId\n);\n\n    \nvar\n \nhandle\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\npresence\n.\nHandle\n);\n\n    \nDebug\n.\nLogFormat\n(\nUser id \n{0}\n handle \n{1}\n.\n,\n \nuserId\n,\n \nhandle\n);\n\n  \n}\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nThe list of match opponents returned in the success callback might not include all users. It contains users who are connected to the match so far.\n\n\nList opponents\n\n\nWhen a user joins a match they receive an initial list of connected opponents. As other users join or leave the server will push events to clients which can be used to update the list of connected opponents.\n\n\nIList\nINUserPresence\n \nconnectedOpponents\n \n=\n \nnew\n \nList\nINUserPresence\n();\n\n\n\nclient\n.\nOnMatchPresence\n \n+=\n \n(\nobject\n \nsource\n,\n \nNMatchPresenceEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINMatchPresence\n \npresenceUpdate\n \n=\n \nargs\n.\nMatchPresence\n;\n\n\n  \n// Remove all users who left.\n\n  \nforeach\n \n(\nvar\n \nuser\n \nin\n \npresenceUpdate\n.\nLeave\n)\n \n{\n\n    \nconnectedOpponents\n.\nRemove\n(\nuser\n);\n\n  \n}\n\n\n  \n// Add all users who joined.\n\n  \nconnectedOpponents\n.\nAddRange\n(\npresenceUpdate\n.\nJoin\n);\n\n\n};\n\n\n\n\n\n\nNo server updates are sent if there are no changes to the presence list.\n\n\nSend data messages\n\n\nA user in a match can send data messages which will be received by all other opponents. These messages are streamed in realtime to other users and can contain any binary content. To identify each message as a specific \"command\" it contains an Op code as well as the payload.\n\n\nAn Op code is a numeric identifier for the type of message sent. These can be used to define commands within the gameplay which belong to certain user actions.\n\n\nThe binary content in each data message should be as \nsmall as possible\n. It is common to use JSON or preferable to use a compact binary format like \nProtocol Buffers\n or \nFlatBuffers\n.\n\n\nbyte\n[]\n \nid\n \n=\n \nmatch\n.\nId\n;\n \n// an INMatch Id.\n\n\n\nlong\n \nopCode\n \n=\n \n001L\n;\n\n\nbyte\n[]\n \ndata\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{\\\nmove\\\n: {\\\ndir\\\n: \\\nleft\\\n, \\\nsteps\\\n: 4}}\n);\n\n\n\nvar\n \nmessage\n \n=\n \nNMatchDataSendMessage\n.\nDefault\n(\nmatchId\n,\n \nopCode\n,\n \ndata\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully sent data message.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nReceive data messages\n\n\nA client can add a callback for incoming match data messages. This should be done before they create (or join) and leave a match.\n\n\n\n\nMessage sequences\n\n\nThe server delivers data in the order it processes data messages from clients.\n\n\n\n\nclient\n.\nOnMatchData\n \n+=\n \n(\nobject\n \nsource\n,\n \nNMatchDataEventArgs\n \nargs\n)\n \n=\n \n{\n\n  \nINMatchData\n \nm\n \n=\n \nargs\n.\nData\n;\n\n  \nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nm\n.\nData\n);\n\n  \nswitch\n \n(\ndata\n.\nOpCode\n)\n \n{\n\n  \ncase\n \n101L\n:\n\n    \nDebug\n.\nLog\n(\nA custom opcode.\n);\n\n    \nbreak\n;\n\n  \ndefault\n:\n\n    \nDebug\n.\nLogFormat\n(\nUser handle \n{0}\n sent \n{1}\n,\n \nm\n.\nPresence\n.\nHandle\n,\n \ncontent\n);\n\n  \n};\n\n\n};\n\n\n\n\n\n\nLeave a match\n\n\nUsers can leave a match at any point. A match ends when all users have left.\n\n\nbyte\n[]\n \nid\n \n=\n \nmatch\n.\nId\n;\n \n// an INMatch Id.\n\n\n\nvar\n \nmessage\n \n=\n \nNMatchLeaveMessage\n.\nDefault\n(\nid\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nbool\n \ncomplete\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nSuccessfully left match.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\nNote\n\n\nWhen all opponents leave a match it's ID becomes invalid and cannot be re-used to join again.", 
            "title": "Realtime Multiplayer"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#realtime-multiplayer", 
            "text": "The realtime multiplayer engine makes it easy for users to set up and join matches where they can rapidly exchange data with opponents.  Any user can participate in matches with other users. Users can create, join, and leave matches with messages sent from clients. A match exists on the server until its last participant has left.  Any data sent through a match is immediately routed to all other match opponents. Matches are kept in-memory but can be persisted as needed.", 
            "title": "Realtime Multiplayer"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#create-a-match", 
            "text": "A match can be created by a user. The server will assign a unique ID which can be shared with other users for them to  join the match . All users within a match are equal and it is up to the clients to decide on a host.  var   message   =   NMatchCreateMessage . Default ();  client . Send ( message ,   ( INMatch   match )   =   { \n   byte []   id   =   match . Id ; \n   Debug . Log ( Successfully created match. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   A user can  leave a match  at any point which will notify all other users.", 
            "title": "Create a match"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#join-a-match", 
            "text": "A user can join a specific match by ID. Matches can be joined at any point until the last participant leaves.   Hint  To find a match instead of specify one by ID use the  matchmaker .   byte []   id   =   match . Id ;   // an INMatch Id.  var   message   =   NMatchJoinMessage . Default ( id );  client . Send ( message ,   ( INMatch   match )   =   { \n   Debug . Log ( Successfully joined match. ); \n\n   IList INUserPresence   connectedOpponents   =   new   List INUserPresence (); \n   // Add list of connected opponents. \n   connectedOpponents . AddRange ( match . Presence ); \n   // Remove your own user from list. \n   connectedOpponents . Remove ( match . Self ); \n\n   foreach   ( var   presence   in   connectedOpponents )   { \n     var   userId   =   Encoding . UTF8 . GetString ( presence . UserId ); \n     var   handle   =   Encoding . UTF8 . GetString ( presence . Handle ); \n     Debug . LogFormat ( User id  {0}  handle  {1} . ,   userId ,   handle ); \n   }  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   The list of match opponents returned in the success callback might not include all users. It contains users who are connected to the match so far.", 
            "title": "Join a match"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#list-opponents", 
            "text": "When a user joins a match they receive an initial list of connected opponents. As other users join or leave the server will push events to clients which can be used to update the list of connected opponents.  IList INUserPresence   connectedOpponents   =   new   List INUserPresence ();  client . OnMatchPresence   +=   ( object   source ,   NMatchPresenceEventArgs   args )   =   { \n   INMatchPresence   presenceUpdate   =   args . MatchPresence ; \n\n   // Remove all users who left. \n   foreach   ( var   user   in   presenceUpdate . Leave )   { \n     connectedOpponents . Remove ( user ); \n   } \n\n   // Add all users who joined. \n   connectedOpponents . AddRange ( presenceUpdate . Join );  };   No server updates are sent if there are no changes to the presence list.", 
            "title": "List opponents"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#send-data-messages", 
            "text": "A user in a match can send data messages which will be received by all other opponents. These messages are streamed in realtime to other users and can contain any binary content. To identify each message as a specific \"command\" it contains an Op code as well as the payload.  An Op code is a numeric identifier for the type of message sent. These can be used to define commands within the gameplay which belong to certain user actions.  The binary content in each data message should be as  small as possible . It is common to use JSON or preferable to use a compact binary format like  Protocol Buffers  or  FlatBuffers .  byte []   id   =   match . Id ;   // an INMatch Id.  long   opCode   =   001L ;  byte []   data   =   Encoding . UTF8 . GetBytes ( {\\ move\\ : {\\ dir\\ : \\ left\\ , \\ steps\\ : 4}} );  var   message   =   NMatchDataSendMessage . Default ( matchId ,   opCode ,   data );  client . Send ( message ,   ( bool   done )   =   { \n   Debug . Log ( Successfully sent data message. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "Send data messages"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#receive-data-messages", 
            "text": "A client can add a callback for incoming match data messages. This should be done before they create (or join) and leave a match.   Message sequences  The server delivers data in the order it processes data messages from clients.   client . OnMatchData   +=   ( object   source ,   NMatchDataEventArgs   args )   =   { \n   INMatchData   m   =   args . Data ; \n   var   content   =   Encoding . UTF8 . GetString ( m . Data ); \n   switch   ( data . OpCode )   { \n   case   101L : \n     Debug . Log ( A custom opcode. ); \n     break ; \n   default : \n     Debug . LogFormat ( User handle  {0}  sent  {1} ,   m . Presence . Handle ,   content ); \n   };  };", 
            "title": "Receive data messages"
        }, 
        {
            "location": "/gameplay-multiplayer-realtime/#leave-a-match", 
            "text": "Users can leave a match at any point. A match ends when all users have left.  byte []   id   =   match . Id ;   // an INMatch Id.  var   message   =   NMatchLeaveMessage . Default ( id );  client . Send ( message ,   ( bool   complete )   =   { \n   Debug . Log ( Successfully left match. );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });    Note  When all opponents leave a match it's ID becomes invalid and cannot be re-used to join again.", 
            "title": "Leave a match"
        }, 
        {
            "location": "/in-app-purchase-validation/", 
            "text": "In-app Purchase Validation\n\n\nThe spectrum of monetisation models and tools is extremely varied. From ad-supported, microtransactions, freemium, one-off purchases, and everything in between. A key tool in many of these solutions is the In-App Purchase, which enables single purchases for unlocks, in-game consumables, subscriptions for premium access, and more.\n\n\nThere are a number of readily available attacks against the most common in-app purchase implementations.\n\n\nThese are usually focused around:\n\n\n\n\nFeeding the client fake purchase responses which indicate success.\n\n\nReplaying a valid purchase response multiple times.\n\n\nSharing a purchase response with another client, so multiple players can receive the reward from a single purchase.\n\n\n...and more, with new vulnerabilities emerging occasionally.\n\n\n\n\nFor in-app purchases, a trusted source of truth is required. Nakama checks and tracks purchases and purchase history, solving a significant set of possible vulnerabilities and pain points.\n\n\nIn-App Purchase Validation is available for Apple and Google purchases, regardless of platform. Both single product and subscription purchases are supported.\n\n\nFake Purchases\n\n\nNakama directly connects to Apple and Google services to check the validity of all incoming payments. This verification is completely outside the client's code, and cannot be intercepted and tampered with.\n\n\nEvery transaction is verified, every time, and invalid ones are rejected.\n\n\nReplay Attacks\n\n\nAll transactions are logged, preventing multiple submissions of the same purchase token or receipt.\n\n\nReceipt Sharing\n\n\nSuccessful transactions are bound to the account that submits them. Different users cannot submit the same transaction, even a valid one, in an attempt to receive the associated reward.\n\n\nProduct Mismatches\n\n\nThe transaction is checked to ensure the correct reward is tied to each purchase. This prevents attacks that attempt to use a valid (cheap) purchase to unlock a different (expensive) reward.\n\n\nSubscription Expiry\n\n\nNakama checks subscriptions to see if they've expired, and rejects the transaction as needed.\n\n\nPurchase Cancellation\n\n\nValid receipts that link to cancelled purchases are flagged and rejected.\n\n\nSingle Source of Truth\n\n\nWhile Nakama maintains an internal record of all transactions, the remote payment provider is always given priority. Valid purchases that have been checked, logged, then subsequently cancelled, will be rejected appropriately.\n\n\nApple\n\n\nNakama supports validating purchases made for products and subscription in iOS.\n\n\nApple purchase receipts are sent to Apple for validation. As suggested by Apple, both Production and Sandbox servers are used to validate receipts depending on the priority setup in the Nakama configuration.\n\n\nSetup\n\n\nTo validate receipts against the App Store, Nakama requires your app's shared secret. You can setup a shared secret in \niTunes Connect\n.\n\n\n\n\nMake a record of your shared secret:\n\n\n\n\nYou'll need to set the value of \npurchase.apple.password\n to the value of the Shared Secret above. For more info, take a look at the \nconfiguration\n page.\n\n\nIf your app is in production, you'll need to set the value of \npurchase.apple.production\n to true to give priority Apple's Production servers.\n\n\nValidate Purchase\n\n\nNakama only supports validating iOS 7+ receipts. In addition, Nakama only validates the first item in the receipt as Apple receipts can contain more than one in-app purchase item.\n\n\nvar\n \nproductId\n \n=\n \ncom.yourcompany.product\n;\n\n\nvar\n \nreceiptData\n \n=\n \n...some-base64-encoded-data...\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNPurchaseValidateMessage\n.\nApple\n(\nproductId\n,\n \nreceiptData\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINPurchaseRecord\n \nrecord\n)\n \n=\n\n\n{\n\n  \nif\n \n(!\nrecord\n.\nSuccess\n)\n \n{\n\n    \nDebug\n.\nLog\n(\nPurchase was not validation. Reason: {0}.\n,\n \nrecord\n.\nMessage\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nrecord\n.\nSeenBefore\n)\n \n{\n\n      \n// This is useful for recovering previous purchases\n\n      \nDebug\n.\nLog\n(\nThis is a valid purchase but the purchase item was redeemed once before.\n);\n\n    \n}\n \nelse\n \n{\n\n      \nDebug\n.\nLog\n(\nNew purchase was validated\n);\n\n    \n}\n\n  \n}\n\n\n},\n \n(\nINError\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreceipt_data\n\n\nstring\n\n\nBase-64 encoded receipt data returned by the purchase operation itself.\n\n\n\n\n\n\nproduct_id\n\n\nstring\n\n\nThe product, item, or subscription package ID the purchase relates to.\n\n\n\n\n\n\n\n\nGoogle\n\n\nNakama supports validating purchases made for products and subscription on Android.\n\n\nSetup\n\n\nTo validate receipts against the Play Store, Nakama requires your app's package name, as well as a service file. You can setup a service account and download the service file on \nGoogle Play Developer Console\n.\n\n\nFirstly, you'll need to setup a Service Account in the \nGoogle API Console\n.\n\n\n\n\nOnce a service account is created, you'll need to create a key:\n\n\n\n\nDownload the key as a JSON file. You'll need to put this file somewhere that Nakama server can access.\n\n\n\n\nOnce the key is created, navigate back to \nGoogle Play Developer Console\n and navigate to \nSettings\n \n \nAPI Access\n.\n\n\nThe service account you created in the previous steps should be listed above. You'll need to grant access to the service account to access the API:\n\n\n\n\nMake sure that you give the service account access to \nVisibility\n, \nView Financial Data\n, and \nManage Orders\n. These permissions are required for Nakama to validate receipts against Google Play.\n\n\n\n\nNavigate to \nUsers \n Permissions\n to check that the service account is setup correctly.\n\n\n\n\nLastly, you'll need to update Nakama's configuration with the following information:\n\n\n\n\n\n\npurchase.google.package_name\n: Package name for your Android app, as you've listed in Google Play.\n\n\n\n\n\n\npurchase.google.service_key_file\n: Path of the JSON file you download in previous steps. This file contains authentication information that allows Nakama to communicate with Google Play on your behalf. Make sure that the file is kept safe and is only accessible by Nakama and other authorized parties.\n\n\n\n\n\n\nValidate Purchase\n\n\nvar\n \nproductId\n \n=\n \ncom.yourcompany.product\n;\n\n\nvar\n \npurchaseType\n \n=\n \nproduct\n;\n\n\nvar\n \npurchaseToken\n \n=\n \nsome-token-from-google\n;\n\n\n\nvar\n \nmessage\n \n=\n \nNPurchaseValidateMessage\n.\nGoogle\n(\nproductId\n,\n \npurchaseType\n,\n \npurchaseToken\n);\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINPurchaseRecord\n \nrecord\n)\n \n=\n\n\n{\n\n  \nif\n \n(!\nrecord\n.\nSuccess\n)\n \n{\n\n    \nDebug\n.\nLog\n(\nPurchase was not validation. Reason: {0}.\n,\n \nrecord\n.\nMessage\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nrecord\n.\nSeenBefore\n)\n \n{\n\n      \n// This is useful for recovering previous purchases\n\n      \nDebug\n.\nLog\n(\nThis is a valid purchase but the purchase item was redeemed once before.\n);\n\n    \n}\n \nelse\n \n{\n\n      \nDebug\n.\nLog\n(\nNew purchase was validated\n);\n\n    \n}\n\n  \n}\n\n\n},\n \n(\nINError\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nproduct_type\n\n\nstring\n\n\nWhether the purchase is for a \nproduct\n or a \nsubscription\n\n\n\n\n\n\npurchase_token\n\n\nstring\n\n\nThe token returned in the purchase operation response, acts as a transaction identifier.\n\n\n\n\n\n\nproduct_id\n\n\nstring\n\n\nThe identifier of the product or subscription being purchased.\n\n\n\n\n\n\n\n\nInterpreting Responses\n\n\nResponses contain the following information:\n\n\n\n\nsuccess\n - Whether or not the transaction is valid and all the information matches.\n\n\nseen_before\n - If this is a new transaction or if Nakama has a log of it.\n\n\npurchase_provider_reachable\n - Indicates whether or not Nakama was able to reach the remote purchase service.\n\n\nmessage\n - A string indicating why the purchase verification failed, if appropriate.\n\n\ndata\n - The complete response Nakama received from the remote service.\n\n\n\n\n\n\nNote\n\n\nIf \npurchase_provider_reachable\n is \nfalse\n it indicates that Nakama was unable to query the remote purchase service. In this situation the client should use its discretion to decide if the purchase should be accepted, and must queue up the verification request for a later retry.\n\n\n\n\nEach response contains all the information needed to take the appropriate action. Below is a quick reference for interpreting the key fields:\n\n\n\n\n\n\n\n\n\n\nseen_before\n = \ntrue\n\n\nseen_before\n = \nfalse\n\n\n\n\n\n\n\n\n\n\n\n\nsuccess\n = \ntrue\n\n\nValid, but Nakama has an existing record of it.\n\n\nValid and new.\n\n\n\n\n\n\n\n\nsuccess\n = \nfalse\n\n\n Rejected, check \nmessage\n field for reason.\n\n\nRejected, check \nmessage\n field for reason.\n\n\n\n\n\n\n\n\n\n\nRecovering Purchases\n\n\nWhen users change devices, it's common to offer an option (or fully automated process) to re-apply the benefits of any previous purchases to their new client installation.\n\n\nClients should always refer to the platform purchase provider for a list of purchases, then verify each one with Nakama. In this case clients should accommodate responses where the \nseen_before\n indicator is true and act accordingly.", 
            "title": "In-app Purchase Validation"
        }, 
        {
            "location": "/in-app-purchase-validation/#in-app-purchase-validation", 
            "text": "The spectrum of monetisation models and tools is extremely varied. From ad-supported, microtransactions, freemium, one-off purchases, and everything in between. A key tool in many of these solutions is the In-App Purchase, which enables single purchases for unlocks, in-game consumables, subscriptions for premium access, and more.  There are a number of readily available attacks against the most common in-app purchase implementations.  These are usually focused around:   Feeding the client fake purchase responses which indicate success.  Replaying a valid purchase response multiple times.  Sharing a purchase response with another client, so multiple players can receive the reward from a single purchase.  ...and more, with new vulnerabilities emerging occasionally.   For in-app purchases, a trusted source of truth is required. Nakama checks and tracks purchases and purchase history, solving a significant set of possible vulnerabilities and pain points.  In-App Purchase Validation is available for Apple and Google purchases, regardless of platform. Both single product and subscription purchases are supported.  Fake Purchases  Nakama directly connects to Apple and Google services to check the validity of all incoming payments. This verification is completely outside the client's code, and cannot be intercepted and tampered with.  Every transaction is verified, every time, and invalid ones are rejected.  Replay Attacks  All transactions are logged, preventing multiple submissions of the same purchase token or receipt.  Receipt Sharing  Successful transactions are bound to the account that submits them. Different users cannot submit the same transaction, even a valid one, in an attempt to receive the associated reward.  Product Mismatches  The transaction is checked to ensure the correct reward is tied to each purchase. This prevents attacks that attempt to use a valid (cheap) purchase to unlock a different (expensive) reward.  Subscription Expiry  Nakama checks subscriptions to see if they've expired, and rejects the transaction as needed.  Purchase Cancellation  Valid receipts that link to cancelled purchases are flagged and rejected.  Single Source of Truth  While Nakama maintains an internal record of all transactions, the remote payment provider is always given priority. Valid purchases that have been checked, logged, then subsequently cancelled, will be rejected appropriately.", 
            "title": "In-app Purchase Validation"
        }, 
        {
            "location": "/in-app-purchase-validation/#apple", 
            "text": "Nakama supports validating purchases made for products and subscription in iOS.  Apple purchase receipts are sent to Apple for validation. As suggested by Apple, both Production and Sandbox servers are used to validate receipts depending on the priority setup in the Nakama configuration.", 
            "title": "Apple"
        }, 
        {
            "location": "/in-app-purchase-validation/#setup", 
            "text": "To validate receipts against the App Store, Nakama requires your app's shared secret. You can setup a shared secret in  iTunes Connect .   Make a record of your shared secret:   You'll need to set the value of  purchase.apple.password  to the value of the Shared Secret above. For more info, take a look at the  configuration  page.  If your app is in production, you'll need to set the value of  purchase.apple.production  to true to give priority Apple's Production servers.", 
            "title": "Setup"
        }, 
        {
            "location": "/in-app-purchase-validation/#validate-purchase", 
            "text": "Nakama only supports validating iOS 7+ receipts. In addition, Nakama only validates the first item in the receipt as Apple receipts can contain more than one in-app purchase item.  var   productId   =   com.yourcompany.product ;  var   receiptData   =   ...some-base64-encoded-data... ;  var   message   =   NPurchaseValidateMessage . Apple ( productId ,   receiptData );  client . Send ( message ,   ( INPurchaseRecord   record )   =  { \n   if   (! record . Success )   { \n     Debug . Log ( Purchase was not validation. Reason: {0}. ,   record . Message ); \n   }   else   { \n     if   ( record . SeenBefore )   { \n       // This is useful for recovering previous purchases \n       Debug . Log ( This is a valid purchase but the purchase item was redeemed once before. ); \n     }   else   { \n       Debug . Log ( New purchase was validated ); \n     } \n   }  },   ( INError   e )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });      Param  Type  Description      receipt_data  string  Base-64 encoded receipt data returned by the purchase operation itself.    product_id  string  The product, item, or subscription package ID the purchase relates to.", 
            "title": "Validate Purchase"
        }, 
        {
            "location": "/in-app-purchase-validation/#google", 
            "text": "Nakama supports validating purchases made for products and subscription on Android.", 
            "title": "Google"
        }, 
        {
            "location": "/in-app-purchase-validation/#setup_1", 
            "text": "To validate receipts against the Play Store, Nakama requires your app's package name, as well as a service file. You can setup a service account and download the service file on  Google Play Developer Console .  Firstly, you'll need to setup a Service Account in the  Google API Console .   Once a service account is created, you'll need to create a key:   Download the key as a JSON file. You'll need to put this file somewhere that Nakama server can access.   Once the key is created, navigate back to  Google Play Developer Console  and navigate to  Settings     API Access .  The service account you created in the previous steps should be listed above. You'll need to grant access to the service account to access the API:   Make sure that you give the service account access to  Visibility ,  View Financial Data , and  Manage Orders . These permissions are required for Nakama to validate receipts against Google Play.   Navigate to  Users   Permissions  to check that the service account is setup correctly.   Lastly, you'll need to update Nakama's configuration with the following information:    purchase.google.package_name : Package name for your Android app, as you've listed in Google Play.    purchase.google.service_key_file : Path of the JSON file you download in previous steps. This file contains authentication information that allows Nakama to communicate with Google Play on your behalf. Make sure that the file is kept safe and is only accessible by Nakama and other authorized parties.", 
            "title": "Setup"
        }, 
        {
            "location": "/in-app-purchase-validation/#validate-purchase_1", 
            "text": "var   productId   =   com.yourcompany.product ;  var   purchaseType   =   product ;  var   purchaseToken   =   some-token-from-google ;  var   message   =   NPurchaseValidateMessage . Google ( productId ,   purchaseType ,   purchaseToken );  client . Send ( message ,   ( INPurchaseRecord   record )   =  { \n   if   (! record . Success )   { \n     Debug . Log ( Purchase was not validation. Reason: {0}. ,   record . Message ); \n   }   else   { \n     if   ( record . SeenBefore )   { \n       // This is useful for recovering previous purchases \n       Debug . Log ( This is a valid purchase but the purchase item was redeemed once before. ); \n     }   else   { \n       Debug . Log ( New purchase was validated ); \n     } \n   }  },   ( INError   e )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });      Param  Type  Description      product_type  string  Whether the purchase is for a  product  or a  subscription    purchase_token  string  The token returned in the purchase operation response, acts as a transaction identifier.    product_id  string  The identifier of the product or subscription being purchased.", 
            "title": "Validate Purchase"
        }, 
        {
            "location": "/in-app-purchase-validation/#interpreting-responses", 
            "text": "Responses contain the following information:   success  - Whether or not the transaction is valid and all the information matches.  seen_before  - If this is a new transaction or if Nakama has a log of it.  purchase_provider_reachable  - Indicates whether or not Nakama was able to reach the remote purchase service.  message  - A string indicating why the purchase verification failed, if appropriate.  data  - The complete response Nakama received from the remote service.    Note  If  purchase_provider_reachable  is  false  it indicates that Nakama was unable to query the remote purchase service. In this situation the client should use its discretion to decide if the purchase should be accepted, and must queue up the verification request for a later retry.   Each response contains all the information needed to take the appropriate action. Below is a quick reference for interpreting the key fields:      seen_before  =  true  seen_before  =  false       success  =  true  Valid, but Nakama has an existing record of it.  Valid and new.     success  =  false   Rejected, check  message  field for reason.  Rejected, check  message  field for reason.", 
            "title": "Interpreting Responses"
        }, 
        {
            "location": "/in-app-purchase-validation/#recovering-purchases", 
            "text": "When users change devices, it's common to offer an option (or fully automated process) to re-apply the benefits of any previous purchases to their new client installation.  Clients should always refer to the platform purchase provider for a list of purchases, then verify each one with Nakama. In this case clients should accommodate responses where the  seen_before  indicator is true and act accordingly.", 
            "title": "Recovering Purchases"
        }, 
        {
            "location": "/runtime-code-basics/", 
            "text": "Basics\n\n\nThe server integrates the \nLua programming language\n as a fast embedded code runtime.\n\n\nIt is useful to run custom logic which isn\u2019t running on the device or browser. The code you deploy with the server can be used immediately by clients so you can change behavior on the fly and add new features faster.\n\n\nYou should use server-side code when you want to set rules around various features like how many \nfriends\n a user may have or how many \ngroups\n can be joined. It can be used to run authoritative logic or perform validation checks as well as integrate with other services over HTTPS.\n\n\nLoad modules\n\n\nYou can create a Lua file wherever you like on the filesystem as long as the server knows where to scan for the folder which contains your code.\n\n\nBy default the server will scan all files within the \"data/modules\" folder relative to the server file or the folder specified in the YAML \nconfiguration\n at startup. You can also specify the modules folder via a command flag when you start the server.\n\n\nnakama --runtime.path \n$HOME\n/some/path/\n\n\n\n\n\n\nAll files with the \".lua\" extension will be loaded and evaluated as part of the boot up sequence. Each Lua file represents a module and all code in each module will be run and can be used to register functions which can operate on messages from clients as well as execute logic on demand.\n\n\nSimple example\n\n\nLets create a module called \"example.lua\". In it we'll register code to be run by a client as an \nRPC call\n.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \nsome_example\n(\ncontext\n,\n \npayload\n)\n\n  \n-- we\nll assume payload was sent as JSON and decode it.\n\n  \nlocal\n \njson\n \n=\n \nnk\n.\njson_decode\n(\npayload\n)\n\n\n  \n-- log data sent to RPC call.\n\n  \nnk\n.\nlogger_info\n((\nPayload: %q\n):\nformat\n(\njson\n))\n\n\n  \nlocal\n \nid\n \n=\n \nnk\n.\nuuid_v4\n()\n\n  \n-- create a leaderboard with the json as metadata.\n\n  \nnk\n.\ncreate_leaderboard\n(\nid\n,\n \ndesc\n,\n \n0 0 * * 1\n,\n \njson\n,\n \nfalse\n)\n\n\n  \nreturn\n \nnk\n.\njson_encode\n({[\nid\n]\n \n=\n \nid\n})\n\n  \n-- will return \n{\nid\n: \nsome UUID\n}\n (JSON) as bytes\n\n\nend\n\n\n\nnk\n.\nregister_rpc\n(\nsome_example\n,\n \nmy_unique_id\n)\n\n\n\n\n\n\nWe import the \n\"nakama\"\n module which is embedded within the server and contains lots of server-side functions which are helpful as you build your code. You can see all available functions in the \nmodule reference\n.\n\n\nRegister hooks\n\n\nThe code in a module will be evaluated immediately and can be used to register functions which can operate on messages from clients as well as execute logic on demand.\n\n\nAll registered functions receive a \"context\" table as the first argument and \"payload\" as the second. The \"context\" contains fields which depend on when the code is executed.\n\n\n\n\n\n\n\n\nField\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\ncontext.Env\n\n\nA table of key/value pairs which are defined in the YAML \nconfiguration\n of the server. This is useful to store API keys and other secrets which may be different between servers run in production and in development.\n\n\n\n\n\n\ncontext.ExecutionMode\n\n\nThe mode associated with the execution context. It's one of these values: \"after\", \"before\", \"http\", or \"rpc\".\n\n\n\n\n\n\ncontext.UserHandle\n\n\nThe user handle associated with the execution context. It will always be \nnil\n on \nregister_http\n.\n\n\n\n\n\n\ncontext.UserId\n\n\nThe user ID associated with the execution context. It will always be \nnil\n on \nregister_http\n.\n\n\n\n\n\n\ncontext.UserSessionExp\n\n\nThe user session expiry in milliseconds associated with the execution context. It will always be \nnil\n on \nregister_http\n.\n\n\n\n\n\n\n\n\nThere are four ways to register a function within the runtime each of which is used to handle specific behavior between client and server.\n\n\nregister_before\n\n\nAny function may be registered to intercept a message received from a client and operate on it (or reject it) based on custom logic. This is useful to enforce specific rules on top of the standard features in the server.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \nlimit_friends\n(\ncontext\n,\n \npayload\n)\n\n  \nlocal\n \nuser\n \n=\n \nnk\n.\nuser_fetch_id\n({\ncontext\n.\nUserId\n})[\n1\n]\n\n  \n-- lets assume we\nve stored a user\ns level in their metadata.\n\n  \nlocal\n \nmetadata\n \n=\n \nnk\n.\njson_decode\n(\nuser\n.\nMetadata\n)\n\n  \nif\n \nmetadata\n.\nlevel\n \n=\n \n10\n \nthen\n\n    \nerror\n(\nMust reach level 10 before you can add friends.\n)\n\n  \nend\n\n\n  \nreturn\n \npayload\n \n-- important!\n\n\nend\n\n\nnk\n.\nregister_before\n(\nlimit_friends\n,\n \nTFriendAdd\n)\n\n\n\n\n\n\nThe code above fetches the current user's profile and checks the metadata which is assumed to be JSON encoded with \n\"{level: 12}\"\n in it. If a user's level is too low an error is thrown to prevent the Friend Add message from being passed onwards in the server pipeline.\n\n\n\n\nNote\n\n\nYou must remember to return the payload at the end of your function in the same structure as you received it. See \n\"return payload\"\n highlighted in the code above.\n\n\n\n\nregister_after\n\n\nSimilar to \n\"register_before\"\n you can attach a function to operate on a message. The registered function will be called after the message has been processed in the pipeline. The custom code will be executed asynchronously after the response message has been sent to a client.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \nadd_reward\n(\ncontext\n,\n \npayload\n)\n\n  \nlocal\n \nvalue\n \n=\n \n{\n\n    \nuser_ids\n \n=\n \n{\npayload\n.\nUserId\n}\n\n  \n}\n\n  \nlocal\n \nrecord\n \n=\n \n{\n\n    \nBucket\n \n=\n \nmygame\n,\n\n    \nCollection\n \n=\n \nrewards\n,\n\n    \nRecord\n \n=\n \nreward\n,\n\n    \nUserId\n \n=\n \ncontext\n.\nUserId\n,\n\n    \nValue\n \n=\n \nvalue\n\n  \n}\n\n  \nnk\n.\nstorage_write\n({\n \nrecord\n \n})\n\n\nend\n\n\n\nnk\n.\nregister_after\n(\nadd_reward\n,\n \nTFriendAdd\n)\n\n\n\n\n\n\nThe simple code above writes a record to a user's storage when they add a friend. Any data returned by the function will be discarded.\n\n\nregister_http\n\n\nSometimes it's useful to create HTTP REST handlers which can be used by web services and ease integration into custom server environments. If you want to send a message from a client you should probably use \n\"register_rpc\"\n instead.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \nhttp_handler\n(\ncontext\n,\n \npayload\n)\n\n  \nlocal\n \nmessage\n \n=\n \nnk\n.\njson_encode\n(\npayload\n)\n\n  \nnk\n.\nlogger_info\n((\nMessage: %q\n):\nformat\n(\nmessage\n))\n\n  \nreturn\n \n{[\ncontext\n]\n \n=\n \ncontext\n}\n\n\nend\n\n\n\nnk\n.\nregister_http\n(\nhttp_handler\n,\n \nhttp_handler_path\n)\n\n\n\n\n\n\nThis function can be called with any HTTP client. For example with cURL you could execute the function with the server.\n\n\ncurl -X POST \nhttp://127.0.0.1:7350/runtime/http_handler_path?key=defaultkey\n \n\\\n\n     -d \n{\nsome\n: \ndata\n}\n \n\\\n\n     -H \nContent-Type: application/json\n \n\\\n\n     -H \nAccept: application/json\n\n\n\n\n\n\n\n\nHTTP key\n\n\nYou should change the default HTTP key before you deploy your code in production.\n\n\n\n\nregister_rpc\n\n\nSome logic between client and server is best handled as RPC functions which clients can execute.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \ncustom_rpc_func\n(\ncontext\n,\n \npayload\n)\n\n  \nnk\n.\nlogger_info\n((\nPayload: %q\n):\nformat\n(\npayload\n))\n\n\n  \n-- \npayload\n is bytes sent by the client we\nll JSON decode it.\n\n  \nlocal\n \njson\n \n=\n \nnk\n.\njson_decode\n(\npayload\n)\n\n\n  \nreturn\n \nnkx\n.\njson_encode\n(\njson\n)\n\n\nend\n\n\n\nnk\n.\nregister_rpc\n(\ncustom_rpc_func\n,\n \ncustom_rpc_func_id\n)\n\n\n\n\n\n\nThe code above registers a function with the identifier \"custom_rpc_func_id\". This ID can be used within client code to send an RPC message to execute the function and return the result. Results are always returned as a Lua string (or optionally \nnil\n).\n\n\nErrors and logs\n\n\nYou can handle errors like you would normally in Lua code. If you want to trap the error which occurs in the execution of a function you'll need to execute it via \npcall\n as a \"protected call\".\n\n\nlocal\n \nfunction\n \nwill_error\n()\n\n  \nerror\n(\nThis function will always throw an error!\n)\n\n\nend\n\n\n\nif\n \npcall\n(\nwill_error\n)\n \nthen\n\n  \n-- no errors with \nwill_error\n\n\nelse\n\n  \n-- handle errors\n\n\nend\n\n\n\n\n\n\nThe function \nwill_error\n uses the \nerror\n function in Lua to throw an error with a reason message. The \npcall\n will invoke the \nwill_error\n function and trap any errors. We can then handle the success or error cases as needed.\n\n\nWe recommend you use this pattern with your Lua code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nstatus\n,\n \nresult\n \n=\n \npcall\n(\nnk\n.\nusers_fetch_handle\n,\n \n{\n22e9ed62\n})\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nError occurred: %q\n):\nformat\n(\nresult\n))\n\n\nelse\n\n  \nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nresult\n)\n\n  \ndo\n\n    \nlocal\n \nmessage\n \n=\n \n(\nid: %q, fullname: %q\n):\nformat\n(\nu\n.\nId\n,\n \nu\n.\nFullname\n)\n\n    \nprint\n(\nmessage\n)\n \n-- will appear in console output.\n\n  \nend\n\n\nend\n\n\n\n\n\n\nRestrictions\n\n\nThe Lua virtual machine embedded in the server uses a restricted set of Lua standard library modules. This ensures the code sandbox cannot tamper with operating system input/output or the filesystem.\n\n\nThe list of available modules are: base module, \"math\", \"os\", \"string\", and \"table\".\n\n\nAn example module\n\n\nAs a fun example lets use the \nPok\u00e9api\n and build a helpful module named \"pokeapi.lua\".\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nM\n \n=\n \n{}\n\n\n\nlocal\n \nAPI_BASE_URL\n \n=\n \nhttp://pokeapi.co/api/v2/\n\n\n\nfunction\n \nM\n.\nlookup_pokemon\n(\nname\n)\n\n  \nlocal\n \nurl\n \n=\n \n(\n%s/pokemon/%s\n):\nformat\n(\nAPI_BASE_URL\n,\n \nname\n)\n\n  \nlocal\n \nmethod\n \n=\n \nGET\n\n  \nlocal\n \nheaders\n \n=\n \n{\n\n    \n[\nContent-Type\n]\n \n=\n \napplication/json\n,\n\n    \n[\nAccept\n]\n \n=\n \napplication/json\n\n  \n}\n\n  \nlocal\n \nsuccess\n,\n \ncode\n,\n \n_\n,\n \nbody\n \n=\n \npcall\n(\nnk\n.\nhttp_request\n,\n \nurl\n,\n \nmethod\n,\n \nheaders\n,\n \nnil\n)\n\n  \nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n    \nnk\n.\nlogger_error\n((\nFailed request %q\n):\nformat\n(\ncode\n))\n\n    \nerror\n(\ncode\n)\n\n  \nelseif\n \n(\ncode\n \n=\n \n400\n)\n \nthen\n\n    \nnk\n.\nlogger_error\n((\nFailed request %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n    \nerror\n(\nbody\n)\n\n  \nelse\n\n    \nreturn\n \nnk\n.\njson_decode\n(\nbody\n)\n\n  \nend\n\n\nend\n\n\n\nreturn\n \nM\n\n\n\n\n\n\nWe can import it into another module we'll call \"pokemon.lua\" which will register an RPC call.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\nlocal\n \npokeapi\n \n=\n \nrequire\n(\npokeapi\n)\n\n\n\nlocal\n \nfunction\n \nget_pokemon\n(\n_\n,\n \npayload\n)\n\n  \n-- we\nll assume payload was sent as JSON and decode it.\n\n  \nlocal\n \njson\n \n=\n \nnk\n.\njson_decode\n(\npayload\n)\n\n\n  \nlocal\n \nsuccess\n,\n \nresult\n \n=\n \npcall\n(\npokeapi\n.\nlookup_pokemon\n,\n \njson\n.\nPokemonName\n)\n\n  \nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n    \nerror\n(\nUnable to lookup pokemon.\n)\n\n  \nelse\n\n    \nlocal\n \npokemon\n \n=\n \n{\n\n      \nname\n \n=\n \nresult\n.\nname\n,\n\n      \nheight\n \n=\n \nresult\n.\nheight\n,\n\n      \nweight\n \n=\n \nresult\n.\nweight\n,\n\n      \nimage\n \n=\n \nresult\n.\nsprites\n.\nfront_default\n\n    \n}\n\n    \nreturn\n \npokemon\n\n  \nend\n\n\nend\n\n\n\nnk\n.\nregister_rpc\n(\nget_pokemon\n,\n \nget_pokemon\n)\n\n\n\n\n\n\nWe can make now make an RPC call for a pokemon from a client.\n\n\nbyte\n[]\n \npayload\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{\\\nPokemonName\\\n: \\\nDragonite\\\n}\n);\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNRuntimeRpcMessage\n\n    \n.\nBuilder\n(\nget_pokemon\n)\n\n    \n.\nPayload\n(\npayload\n)\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINRuntimeRpc\n \nrpc\n)\n \n=\n \n{\n\n  \nvar\n \nresult\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nrpc\n.\nPayload\n);\n\n  \nDebug\n.\nLogFormat\n(\nJSON response {0}\n,\n \nresult\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n=\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});", 
            "title": "Basics"
        }, 
        {
            "location": "/runtime-code-basics/#basics", 
            "text": "The server integrates the  Lua programming language  as a fast embedded code runtime.  It is useful to run custom logic which isn\u2019t running on the device or browser. The code you deploy with the server can be used immediately by clients so you can change behavior on the fly and add new features faster.  You should use server-side code when you want to set rules around various features like how many  friends  a user may have or how many  groups  can be joined. It can be used to run authoritative logic or perform validation checks as well as integrate with other services over HTTPS.", 
            "title": "Basics"
        }, 
        {
            "location": "/runtime-code-basics/#load-modules", 
            "text": "You can create a Lua file wherever you like on the filesystem as long as the server knows where to scan for the folder which contains your code.  By default the server will scan all files within the \"data/modules\" folder relative to the server file or the folder specified in the YAML  configuration  at startup. You can also specify the modules folder via a command flag when you start the server.  nakama --runtime.path  $HOME /some/path/   All files with the \".lua\" extension will be loaded and evaluated as part of the boot up sequence. Each Lua file represents a module and all code in each module will be run and can be used to register functions which can operate on messages from clients as well as execute logic on demand.", 
            "title": "Load modules"
        }, 
        {
            "location": "/runtime-code-basics/#simple-example", 
            "text": "Lets create a module called \"example.lua\". In it we'll register code to be run by a client as an  RPC call .  local   nk   =   require ( nakama )  local   function   some_example ( context ,   payload ) \n   -- we ll assume payload was sent as JSON and decode it. \n   local   json   =   nk . json_decode ( payload ) \n\n   -- log data sent to RPC call. \n   nk . logger_info (( Payload: %q ): format ( json )) \n\n   local   id   =   nk . uuid_v4 () \n   -- create a leaderboard with the json as metadata. \n   nk . create_leaderboard ( id ,   desc ,   0 0 * * 1 ,   json ,   false ) \n\n   return   nk . json_encode ({[ id ]   =   id }) \n   -- will return  { id :  some UUID }  (JSON) as bytes  end  nk . register_rpc ( some_example ,   my_unique_id )   We import the  \"nakama\"  module which is embedded within the server and contains lots of server-side functions which are helpful as you build your code. You can see all available functions in the  module reference .", 
            "title": "Simple example"
        }, 
        {
            "location": "/runtime-code-basics/#register-hooks", 
            "text": "The code in a module will be evaluated immediately and can be used to register functions which can operate on messages from clients as well as execute logic on demand.  All registered functions receive a \"context\" table as the first argument and \"payload\" as the second. The \"context\" contains fields which depend on when the code is executed.     Field  Purpose      context.Env  A table of key/value pairs which are defined in the YAML  configuration  of the server. This is useful to store API keys and other secrets which may be different between servers run in production and in development.    context.ExecutionMode  The mode associated with the execution context. It's one of these values: \"after\", \"before\", \"http\", or \"rpc\".    context.UserHandle  The user handle associated with the execution context. It will always be  nil  on  register_http .    context.UserId  The user ID associated with the execution context. It will always be  nil  on  register_http .    context.UserSessionExp  The user session expiry in milliseconds associated with the execution context. It will always be  nil  on  register_http .     There are four ways to register a function within the runtime each of which is used to handle specific behavior between client and server.", 
            "title": "Register hooks"
        }, 
        {
            "location": "/runtime-code-basics/#register_before", 
            "text": "Any function may be registered to intercept a message received from a client and operate on it (or reject it) based on custom logic. This is useful to enforce specific rules on top of the standard features in the server.  local   nk   =   require ( nakama )  local   function   limit_friends ( context ,   payload ) \n   local   user   =   nk . user_fetch_id ({ context . UserId })[ 1 ] \n   -- lets assume we ve stored a user s level in their metadata. \n   local   metadata   =   nk . json_decode ( user . Metadata ) \n   if   metadata . level   =   10   then \n     error ( Must reach level 10 before you can add friends. ) \n   end     return   payload   -- important!  end  nk . register_before ( limit_friends ,   TFriendAdd )   The code above fetches the current user's profile and checks the metadata which is assumed to be JSON encoded with  \"{level: 12}\"  in it. If a user's level is too low an error is thrown to prevent the Friend Add message from being passed onwards in the server pipeline.   Note  You must remember to return the payload at the end of your function in the same structure as you received it. See  \"return payload\"  highlighted in the code above.", 
            "title": "register_before"
        }, 
        {
            "location": "/runtime-code-basics/#register_after", 
            "text": "Similar to  \"register_before\"  you can attach a function to operate on a message. The registered function will be called after the message has been processed in the pipeline. The custom code will be executed asynchronously after the response message has been sent to a client.  local   nk   =   require ( nakama )  local   function   add_reward ( context ,   payload ) \n   local   value   =   { \n     user_ids   =   { payload . UserId } \n   } \n   local   record   =   { \n     Bucket   =   mygame , \n     Collection   =   rewards , \n     Record   =   reward , \n     UserId   =   context . UserId , \n     Value   =   value \n   } \n   nk . storage_write ({   record   })  end  nk . register_after ( add_reward ,   TFriendAdd )   The simple code above writes a record to a user's storage when they add a friend. Any data returned by the function will be discarded.", 
            "title": "register_after"
        }, 
        {
            "location": "/runtime-code-basics/#register_http", 
            "text": "Sometimes it's useful to create HTTP REST handlers which can be used by web services and ease integration into custom server environments. If you want to send a message from a client you should probably use  \"register_rpc\"  instead.  local   nk   =   require ( nakama )  local   function   http_handler ( context ,   payload ) \n   local   message   =   nk . json_encode ( payload ) \n   nk . logger_info (( Message: %q ): format ( message )) \n   return   {[ context ]   =   context }  end  nk . register_http ( http_handler ,   http_handler_path )   This function can be called with any HTTP client. For example with cURL you could execute the function with the server.  curl -X POST  http://127.0.0.1:7350/runtime/http_handler_path?key=defaultkey   \\ \n     -d  { some :  data }   \\ \n     -H  Content-Type: application/json   \\ \n     -H  Accept: application/json    HTTP key  You should change the default HTTP key before you deploy your code in production.", 
            "title": "register_http"
        }, 
        {
            "location": "/runtime-code-basics/#register_rpc", 
            "text": "Some logic between client and server is best handled as RPC functions which clients can execute.  local   nk   =   require ( nakama )  local   function   custom_rpc_func ( context ,   payload ) \n   nk . logger_info (( Payload: %q ): format ( payload )) \n\n   --  payload  is bytes sent by the client we ll JSON decode it. \n   local   json   =   nk . json_decode ( payload ) \n\n   return   nkx . json_encode ( json )  end  nk . register_rpc ( custom_rpc_func ,   custom_rpc_func_id )   The code above registers a function with the identifier \"custom_rpc_func_id\". This ID can be used within client code to send an RPC message to execute the function and return the result. Results are always returned as a Lua string (or optionally  nil ).", 
            "title": "register_rpc"
        }, 
        {
            "location": "/runtime-code-basics/#errors-and-logs", 
            "text": "You can handle errors like you would normally in Lua code. If you want to trap the error which occurs in the execution of a function you'll need to execute it via  pcall  as a \"protected call\".  local   function   will_error () \n   error ( This function will always throw an error! )  end  if   pcall ( will_error )   then \n   -- no errors with  will_error  else \n   -- handle errors  end   The function  will_error  uses the  error  function in Lua to throw an error with a reason message. The  pcall  will invoke the  will_error  function and trap any errors. We can then handle the success or error cases as needed.  We recommend you use this pattern with your Lua code.  local   nk   =   require ( nakama )  local   status ,   result   =   pcall ( nk . users_fetch_handle ,   { 22e9ed62 })  if   ( not   status )   then \n   nk . logger_error (( Error occurred: %q ): format ( result ))  else \n   for   _ ,   u   in   ipairs ( result ) \n   do \n     local   message   =   ( id: %q, fullname: %q ): format ( u . Id ,   u . Fullname ) \n     print ( message )   -- will appear in console output. \n   end  end", 
            "title": "Errors and logs"
        }, 
        {
            "location": "/runtime-code-basics/#restrictions", 
            "text": "The Lua virtual machine embedded in the server uses a restricted set of Lua standard library modules. This ensures the code sandbox cannot tamper with operating system input/output or the filesystem.  The list of available modules are: base module, \"math\", \"os\", \"string\", and \"table\".", 
            "title": "Restrictions"
        }, 
        {
            "location": "/runtime-code-basics/#an-example-module", 
            "text": "As a fun example lets use the  Pok\u00e9api  and build a helpful module named \"pokeapi.lua\".  local   nk   =   require ( nakama )  local   M   =   {}  local   API_BASE_URL   =   http://pokeapi.co/api/v2/  function   M . lookup_pokemon ( name ) \n   local   url   =   ( %s/pokemon/%s ): format ( API_BASE_URL ,   name ) \n   local   method   =   GET \n   local   headers   =   { \n     [ Content-Type ]   =   application/json , \n     [ Accept ]   =   application/json \n   } \n   local   success ,   code ,   _ ,   body   =   pcall ( nk . http_request ,   url ,   method ,   headers ,   nil ) \n   if   ( not   success )   then \n     nk . logger_error (( Failed request %q ): format ( code )) \n     error ( code ) \n   elseif   ( code   =   400 )   then \n     nk . logger_error (( Failed request %q %q ): format ( code ,   body )) \n     error ( body ) \n   else \n     return   nk . json_decode ( body ) \n   end  end  return   M   We can import it into another module we'll call \"pokemon.lua\" which will register an RPC call.  local   nk   =   require ( nakama )  local   pokeapi   =   require ( pokeapi )  local   function   get_pokemon ( _ ,   payload ) \n   -- we ll assume payload was sent as JSON and decode it. \n   local   json   =   nk . json_decode ( payload ) \n\n   local   success ,   result   =   pcall ( pokeapi . lookup_pokemon ,   json . PokemonName ) \n   if   ( not   success )   then \n     error ( Unable to lookup pokemon. ) \n   else \n     local   pokemon   =   { \n       name   =   result . name , \n       height   =   result . height , \n       weight   =   result . weight , \n       image   =   result . sprites . front_default \n     } \n     return   pokemon \n   end  end  nk . register_rpc ( get_pokemon ,   get_pokemon )   We can make now make an RPC call for a pokemon from a client.  byte []   payload   =   Encoding . UTF8 . GetBytes ( {\\ PokemonName\\ : \\ Dragonite\\ } );  var   message   =   new   NRuntimeRpcMessage \n     . Builder ( get_pokemon ) \n     . Payload ( payload ) \n     . Build ();  client . Send ( message ,   ( INRuntimeRpc   rpc )   =   { \n   var   result   =   Encoding . UTF8 . GetString ( rpc . Payload ); \n   Debug . LogFormat ( JSON response {0} ,   result );  },   ( INError   err )   =   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });", 
            "title": "An example module"
        }, 
        {
            "location": "/runtime-code-function-reference/", 
            "text": "Function Reference\n\n\nThe code runtime built into the server includes a module with functions to implement various logic and custom behavior. It is easy to define authoritative code and conditions on input received by clients.\n\n\nNakama module\n\n\nThis module contains all the core gameplay APIs, all registration functions used at server startup, utilities for various codecs, and cryptographic primitives.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n\n\n\n\n\nNote\n\n\nAll code examples assume the \"nakama\" module has been imported.\n\n\n\n\nbase16\n\n\nbase16_decode (input)\n\n\nBase 16 decode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base16 decoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 16 decoded input.\n\n\nExample\n\n\nlocal\n \ndecoded\n \n=\n \nnk\n.\nbase16_decode\n(\n48656C6C6F20776F726C64\n)\n\n\nprint\n(\ndecoded\n)\n \n-- outputs \nHello world\n\n\n\n\n\n\n\n\nbase16_encode (input)\n\n\nBase 16 encode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base16 encoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 16 encoded input.\n\n\nExample\n\n\nlocal\n \nencoded\n \n=\n \nnk\n.\nbase16_encode\n(\nHello world\n)\n\n\nprint\n(\nencoded\n)\n \n-- outputs \n48656C6C6F20776F726C64\n\n\n\n\n\n\nbase64\n\n\nbase64_decode (input)\n\n\nBase 64 decode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base64 decoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 64 decoded input.\n\n\nExample\n\n\nlocal\n \ndecoded\n \n=\n \nnk\n.\nbase64_decode\n(\nSGVsbG8gd29ybGQ=\n)\n\n\nprint\n(\ndecoded\n)\n \n-- outputs \nHello world\n\n\n\n\n\n\n\n\nbase64_encode (input)\n\n\nBase 64 encode the input.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe string which will be base64 encoded.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe base 64 encoded input.\n\n\nExample\n\n\nlocal\n \nencoded\n \n=\n \nnk\n.\nbase64_encode\n(\nHello world\n)\n\n\nprint\n(\nencoded\n)\n \n-- outputs \nSGVsbG8gd29ybGQ=\n\n\n\n\n\n\ngroups\n\n\ngroups_create (new_groups)\n\n\nSetup one or more groups with various configuration settings. The groups will be created if they don't exist or fail if the group names are taken.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_groups\n\n\ntable\n\n\nThe Lua table array of new groups to create.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nmetadata\n \n=\n \n{\n \n-- Add whatever custom fields you want.\n\n  \nmy_custom_field\n \n=\n \nsome value\n\n\n}\n\n\nlocal\n \ngroup\n \n=\n \n{\n\n  \nName\n \n=\n \nSome unique group name\n,\n\n  \nDescription\n \n=\n \nMy awesome group.\n,\n\n  \nLang\n \n=\n \nen\n,\n\n  \nPrivate\n \n=\n \ntrue\n,\n\n  \nCreatorId\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n,\n\n  \nAvatarUrl\n \n=\n \nurl://somelink\n,\n\n  \nMetadata\n \n=\n \nmetadata\n\n\n}\n\n\nlocal\n \nnew_groups\n \n=\n \n{\n \ngroup\n \n}\n\n\nnk\n.\ngroups_create\n(\nnew_groups\n)\n\n\n\n\n\n\ngroups_update (update_groups)\n\n\nUpdate one or more groups with various configuration settings. The groups which are updated can change some or all of their fields.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nupdate_groups\n\n\ntable\n\n\nA Lua table of groups to be updated.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nmetadata\n \n=\n \n{\n\n  \nsome_field\n \n=\n \nsome value\n\n\n}\n\n\nlocal\n \ngroup\n \n=\n \n{\n\n  \nGroupId\n \n=\n \nf00fa79a-750f-11e7-8626-0fb79f45ff97\n,\n\n  \nDescription\n \n=\n \nAn updated description.\n,\n\n  \nMetadata\n \n=\n \nmetadata\n\n\n}\n\n\nlocal\n \nupdate_groups\n \n=\n \n{\n \ngroup\n \n}\n\n\nnk\n.\ngroups_update\n(\nupdate_groups\n)\n\n\n\n\n\n\ngroups_user_list (user_id)\n\n\nList all groups which a user belongs to and whether they've been accepted into the group or if it's an invite.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_id\n\n\nstring\n\n\nThe Id of the user who's groups you want to list.\n\n\n\n\n\n\n\n\nReturns\n\n\nA list of groups for the user.\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n64ef6cb0-7512-11e7-9e52-d7789d80b70b\n\n\nlocal\n \ngroups\n \n=\n \nnk\n.\ngroups_user_list\n(\nuser_id\n)\n\n\nfor\n \n_\n,\n \ng\n \nin\n \nipairs\n(\ngroups\n)\n\n\ndo\n\n  \nlocal\n \nmsg\n \n=\n \n(\nGroup name %q with id %q\n):\nformat\n(\ng\n.\nName\n,\n \ng\n.\nId\n)\n\n  \nprint\n(\nmsg\n)\n\n\nend\n\n\n\n\n\n\ngroup_users_list (group_id)\n\n\nList all members and admins which belong to a group.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngroup_id\n\n\nstring\n\n\nThe Id of the group who's members and admins you want to list.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe members and admins for the group.\n\n\nExample\n\n\nlocal\n \ngroup_id\n \n=\n \na1aafe16-7540-11e7-9738-13777fcc7cd8\n\n\nlocal\n \nmembers\n \n=\n \nnk\n.\ngroup_users_list\n(\ngroup_id\n)\n\n\nfor\n \n_\n,\n \nm\n \nin\n \nipairs\n(\nmembers\n)\n\n\ndo\n\n  \nlocal\n \nmsg\n \n=\n \n(\nMember handle %q has status %q\n):\nformat\n(\nm\n.\nHandle\n,\n \nm\n.\nType\n)\n\n  \nprint\n(\nmsg\n)\n\n\nend\n\n\n\n\n\n\nhttp\n\n\nhttp_request (url, method, headers, content)\n\n\nSend a HTTP request and receive the result as a Lua table.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nstring\n\n\nThe URL of the web resource to request.\n\n\n\n\n\n\nmethod\n\n\nstring\n\n\nThe HTTP method verb used with the request.\n\n\n\n\n\n\nheaders\n\n\ntable\n\n\nA table of headers used with the request.\n\n\n\n\n\n\ncontent\n\n\nstring\n\n\nThe bytes to send with the request.\n\n\n\n\n\n\n\n\nReturns\n\n\ncode, headers, body\n - Multiple return values for the HTTP response.\n\n\nExample\n\n\nlocal\n \nurl\n \n=\n \nhttps://google.com/\n\n\nlocal\n \nmethod\n \n=\n \nHEAD\n\n\nlocal\n \nheaders\n \n=\n \n{\n\n  \n[\nContent-Type\n]\n \n=\n \napplication/json\n,\n\n  \n[\nAccept\n]\n \n=\n \napplication/json\n\n\n}\n\n\nlocal\n \ncontent\n \n=\n \nnk\n.\njson_encode\n({})\n \n-- encode table as JSON string\n\n\nlocal\n \nsuccess\n,\n \ncode\n,\n \nheaders\n,\n \nbody\n \n=\n \npcall\n(\nnk\n.\nhttp_request\n,\n \nurl\n,\n \nmethod\n,\n \nheaders\n,\n \ncontent\n)\n\n\nif\n \n(\nnot\n \nsuccess\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nFailed %q\n):\nformat\n(\ncode\n))\n\n\nelseif\n \n(\ncode\n \n=\n \n400\n)\n \nthen\n\n  \nnk\n.\nlogger_error\n((\nFailed %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n\nelse\n\n  \nnk\n.\nlogger_info\n((\nSuccess %q %q\n):\nformat\n(\ncode\n,\n \nbody\n))\n\n\nend\n\n\n\n\n\n\njson\n\n\njson_decode (input)\n\n\nDecode the JSON input as a Lua table.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe JSON encoded input.\n\n\n\n\n\n\n\n\nReturns\n\n\nA Lua table with the decoded JSON.\n\n\nExample\n\n\nlocal\n \njson\n \n=\n \nnk\n.\njson_decode\n(\n{\nhello\n: \nworld\n}\n)\n\n\nprint\n(\njson\n.\nhello\n)\n\n\n\n\n\n\n\n\njson_encode (input)\n\n\nEncode the input as JSON.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nstring\n\n\nThe input to encode as JSON.\n\n\n\n\n\n\n\n\nReturns\n\n\nThe encoded JSON string.\n\n\nExample\n\n\nlocal\n \ninput\n \n=\n \n{[\nsome\n]\n \n=\n \njson\n}\n\n\nlocal\n \njson\n \n=\n \nnk\n.\njson_encode\n(\ninput\n)\n\n\nprint\n(\njson\n)\n \n-- outputs \n{\nsome\n: \njson\n}\n\n\n\n\n\n\nleaderboard\n\n\nleaderboard_create (id, sort, reset, metadata, authoritative)\n\n\nSetup a new dynamic leaderboard with the specified ID and various configuration settings. The leaderboard will be created if it doesn't already exist.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe unique identifier for the new leaderboard. This is used by clients to submit scores.\n\n\n\n\n\n\nsort\n\n\nstring\n\n\nThe sort order for records in the leaderboard; possible values are \"asc\" or \"desc\".\n\n\n\n\n\n\nreset\n\n\nstring\n\n\nThe cron format used to define the reset schedule for the leaderboard. This controls when a leaderboard is reset and can be used to power daily/weekly/monthly leaderboards.\n\n\n\n\n\n\nmetadata\n\n\ntable\n\n\nThe metadata you want associated to the leaderboard. Some good examples are weather conditions for a racing game.\n\n\n\n\n\n\nauthoritative\n\n\nbool\n\n\nMark the leaderboard as authoritative which ensures updates can only be made via the Lua runtime. No client can submit a score directly.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nmetadata\n \n=\n \n{\n\n  \nweather_conditions\n \n=\n \nrain\n\n\n}\n\n\nlocal\n \nid\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n\n\nnk\n.\nleaderboard_create\n(\nid\n,\n \ndesc\n,\n \n0 0 * * 1\n,\n \nmetadata\n,\n \nfalse\n)\n\n\n\n\n\n\nlogger\n\n\nlogger_error (message)\n\n\nWrite an ERROR level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with ERROR level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_error\n(\nmessage\n)\n\n\n\n\n\n\n\n\nlogger_info (message)\n\n\nWrite an INFO level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with INFO level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_info\n(\nmessage\n)\n\n\n\n\n\n\n\n\nlogger_warn (message)\n\n\nWrite an WARN level message to the server logs.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe message to write to server logs with WARN level severity.\n\n\n\n\n\n\n\n\nReturns\n\n\n(string) - The message which was written to the logs.\n\n\nExample\n\n\nlocal\n \nmessage\n \n=\n \n(\n%q - %q\n):\nformat\n(\nhello\n,\n \nworld\n)\n\n\nnk\n.\nlogger_warn\n(\nmessage\n)\n\n\n\n\n\n\nnotifications\n\n\nnotifications_send_id (new_notifications)\n\n\nSend one or more in-app notifications to a user. Have a look at the section on \nin-app notifications\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_notifications\n\n\ntable\n\n\nThe Lua table array of notifications to send.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nsubject\n \n=\n \nYou\nve unlocked level 100!\n\n\nlocal\n \ncontent\n \n=\n \nnk\n.\njson_encode\n({\n\n  \nreward_coins\n \n=\n \n1000\n\n\n})\n\n\nlocal\n \nuser_id\n \n=\n \n4c2ae592-b2a7-445e-98ec-697694478b1c\n \n-- who to send\n\n\nlocal\n \ncode\n \n=\n \n101\n\n\n\nlocal\n \nnew_notifications\n \n=\n \n{\n\n  \n{\n \nSubject\n \n=\n \nsubject\n,\n \nContent\n \n=\n \ncontent\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nCode\n \n=\n \ncode\n,\n \nPersistent\n \n=\n \ntrue\n}\n\n\n}\n\n\nnk\n.\nnotifications_send_id\n(\nnew_notifications\n)\n\n\n\n\n\n\nregister hooks\n\n\nregister_after (func, msgname)\n\n\nRegister a function with the server which will be executed after every message with the specified message name.\n\n\nThis can be used to apply custom logic to standard features in the server. Similar to the \nregister_before\n function but it will not block the execution pipeline. The logic will be executed in parallel to any response message sent back to a client. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each \nmsgname\n message.\n\n\n\n\n\n\nmsgname\n\n\nstring\n\n\nThe specific message name to execute the \nfunc\n function after.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n\nend\n\n\nnk\n.\nregister_after\n(\nmy_func\n,\n \nTFriendsAdd\n)\n\n\n\n\n\n\n\n\nregister_before (func, msgname)\n\n\nRegister a function with the server which will be executed before every message with the specified message name.\n\n\nFor example \nregister_before(somefunc, \"TFriendAdd\")\n will execute the function before the Friend Add message is executed by the server's message pipeline. This can be used to apply custom conditions to standard features in the server. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each \nmsgname\n message.\n\n\n\n\n\n\nmsgname\n\n\nstring\n\n\nThe specific message name to execute the \nfunc\n function before.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n should pass the \npayload\n back as a return argument so the pipeline can continue to execute the standard logic.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n  \nreturn\n \npayload\n \n-- important!\n\n\nend\n\n\nnk\n.\nregister_before\n(\nmy_func\n,\n \nTFriendsAdd\n)\n\n\n\n\n\n\n\n\nregister_http (func, path)\n\n\nRegisters a HTTP endpoint within the server.\n\n\n\n\nWarning\n\n\nThis should not be used to implement custom client functions instead have a look at \nregister_rpc\n.\n\n\n\n\nThis can be useful to define web callbacks to handle various Ad networks. It can also be used to enable server to server communication to ease the integration of Nakama server into various server stacks. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each HTTP call.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nThe path that should be registered as a HTTP endpoint.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n can pass \nnil\n or \ntable\n back as a return argument which will determine the HTTP response code returned.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- let\ns return the \ncontext\n as JSON back in the HTTP response body\n\n  \nreturn\n \ncontext\n\n\nend\n\n\nnk\n.\nregister_http\n(\nmy_func\n,\n \n/my_endpoint\n)\n\n\n-- \nmy_func\n will be registered at \nPOST /runtime/my_endpoint\n\n\n\n\n\n\nYou can send a request to the HTTP endpoint with JSON and responses will be returned in JSON.\n\n\ncurl -X POST http://127.0.0.1:7350/runtime/my_endpoint?key\n=\ndefaultkey \n\\\n\n     -d \n{\nsome\n: \ndata\n}\n \n\\\n\n     -H \nContent-Type: application/json\n \n\\\n\n     -H \nAccept: application/json\n\n\n\n\n\n\n\n\nregister_rpc (func, id)\n\n\nRegisters a function for use with client RPC to the server.\n\n\nThe ID can be any string identifier and is sent by the client. The ID is used to map the client RPC message to the specific function to execute. Have a look at the section on \nruntime code basics\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nfunction\n\n\nA function reference which will be executed on each RPC message.\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe unique identifier used to register the \nfunc\n function for RPC.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nfunc\n can pass \nnil\n or \nstring\n back as a return argument which will returned as bytes in the RPC response.\n\n\n\n\nExample\n\n\nlocal\n \nfunction\n \nmy_func\n(\ncontext\n,\n \npayload\n)\n\n  \n-- run some code\n\n\nend\n\n\nnk\n.\nregister_rpc\n(\nmy_func\n,\n \nmy_func_id\n)\n\n\n\n\n\n\nstorage\n\n\nstorage_fetch (record_keys)\n\n\nFetch one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of record identifiers to be fetched.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the records result set.\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n}\n\n\n}\n\n\nlocal\n \nrecords\n \n=\n \nnk\n.\nstorage_fetch\n(\nrecord_keys\n)\n\n\nfor\n \n_\n,\n \nr\n \nin\n \nipairs\n(\nrecords\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nread: %q, write: %q, value: %q\n):\nformat\n(\nr\n.\nPermissionRead\n,\n \nr\n.\nPermissionWrite\n,\n \nr\n.\nValue\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nstorage_remove (record_keys)\n\n\nRemove one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of record identifiers to be removed.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n}\n\n\n}\n\n\nnk\n.\nstorage_remove\n(\nrecord_keys\n)\n\n\n\n\n\n\n\n\nstorage_update (record_keys)\n\n\nUpdate one or more records by their bucket/collection/keyname and optional user. Have a look at the section on \nstorage collections\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrecord_keys\n\n\ntable\n\n\nA table array of records to update.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nnow\n \n=\n \nos.time\n()\n \n*\n \n1000\n \n-- current time converted for msec\n\n\nlocal\n \nupdate_ops\n \n=\n \n{\n\n  \n{\nOp\n \n=\n \ninit\n,\n \nPath\n \n=\n \n/\n,\n \nValue\n \n=\n \n{\n \nprogress\n \n=\n \n1\n \n}},\n\n  \n{\nOp\n \n=\n \nincr\n,\n \nPath\n \n=\n \n/progress\n,\n \nValue\n \n=\n \n1\n},\n\n  \n{\nOp\n \n=\n \nreplace\n,\n \nPath\n \n=\n \n/updated_at\n,\n \nValue\n \n=\n \nnow\n}\n\n\n}\n\n\nlocal\n \nrecord_keys\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nb\n,\n \nCollection\n \n=\n \nc\n,\n \nRecord\n \n=\n \nr\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nUpdateOps\n \n=\n \nupdate_ops\n}\n\n\n}\n\n\nnk\n.\nstorage_update\n(\nrecord_keys\n)\n\n\n\n\n\n\n\n\nstorage_write (new_records)\n\n\nWrite one or more records by their bucket/collection/keyname and optional user.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_records\n\n\ntable\n\n\nA table array of new records to write.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nnew_records\n \n=\n \n{\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave1\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave2\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}},\n\n  \n{\nBucket\n \n=\n \nmygame\n,\n \nCollection\n \n=\n \nsave\n,\n \nRecord\n \n=\n \nsave3\n,\n \nUserId\n \n=\n \nuser_id\n,\n \nValue\n \n=\n \n{}}\n\n\n}\n\n\nnk\n.\nstorage_write\n(\nnew_records\n)\n\n\n\n\n\n\nusers\n\n\nusers_ban (user_ids)\n\n\nBan one or more users from the server.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_ids\n\n\ntable\n\n\nA table array of user IDs to be banned.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n4c2ae592-b2a7-445e-98ec-697694478b1c\n}\n\n\nlocal\n \nstatus\n,\n \nresult\n \n=\n \npcall\n(\nnk\n.\nusers_ban\n,\n \nuser_ids\n)\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nprint\n(\nresult\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_fetch_handle (user_handles)\n\n\nFetch a set of users by handle.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_handles\n\n\ntable\n\n\nA table array of user handles to fetch.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the user result set.\n\n\nExample\n\n\nlocal\n \nuser_handles\n \n=\n \n{\nb7865e7e\n,\n \nc048ba7a\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nusers_fetch_handle\n(\nuser_handles\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nid: %q, fullname: %q\n):\nformat\n(\nu\n.\nId\n,\n \nu\n.\nFullname\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_fetch_id (user_ids)\n\n\nFetch one or more users by ID.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_ids\n\n\ntable\n\n\nA table array of user IDs to fetch.\n\n\n\n\n\n\n\n\nReturns\n\n\nA table array of the user result set.\n\n\nExample\n\n\nlocal\n \nuser_ids\n \n=\n \n{\n\n  \n3ea5608a-43c3-11e7-90f9-7b9397165f34\n,\n\n  \n447524be-43c3-11e7-af09-3f7172f05936\n\n\n}\n\n\nlocal\n \nusers\n \n=\n \nnk\n.\nuser_fetch_id\n(\nuser_ids\n)\n\n\nfor\n \n_\n,\n \nu\n \nin\n \nipairs\n(\nusers\n)\n\n\ndo\n\n  \nlocal\n \nmessage\n \n=\n \n(\nhandle: %q, fullname: %q\n):\nformat\n(\nu\n.\nHandle\n,\n \nu\n.\nFullname\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n\n\n\n\n\n\n\n\nusers_update (user_updates)\n\n\nUpdate one or more users.\n\n\nParameters\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuser_updates\n\n\ntable\n\n\nThe table array of users to update.\n\n\n\n\n\n\n\n\nExample\n\n\nlocal\n \nuser_id\n \n=\n \n4ec4f126-3f9d-11e7-84ef-b7c182b36521\n \n-- some user ID.\n\n\nlocal\n \nuser_updates\n \n=\n \n{\n\n  \n{\n \nUserId\n \n=\n \nuser_id\n,\n \nMetadata\n \n=\n \n{}\n \n}\n\n\n}\n\n\nlocal\n \nstatus\n,\n \nerr\n \n=\n \npcall\n(\nnk\n.\nusers_update\n,\n \nuser_updates\n)\n\n\nif\n \n(\nnot\n \nstatus\n)\n \nthen\n\n  \nprint\n((\nUser update error: %q\n):\nformat\n(\nerr\n))\n\n\nend\n\n\n\n\n\n\nuuid\n\n\nuuid_v4 ()\n\n\nGenerate a version 4 UUID.\n\n\nReturns\n\n\nThe generated version 4 UUID identifier.\n\n\nExample\n\n\nlocal\n \nuuid\n \n=\n \nnk\n.\nuuid_v4\n()\n\n\nprint\n(\nuuid\n)", 
            "title": "Function Reference"
        }, 
        {
            "location": "/runtime-code-function-reference/#function-reference", 
            "text": "The code runtime built into the server includes a module with functions to implement various logic and custom behavior. It is easy to define authoritative code and conditions on input received by clients.", 
            "title": "Function Reference"
        }, 
        {
            "location": "/runtime-code-function-reference/#nakama-module", 
            "text": "This module contains all the core gameplay APIs, all registration functions used at server startup, utilities for various codecs, and cryptographic primitives.  local   nk   =   require ( nakama )    Note  All code examples assume the \"nakama\" module has been imported.", 
            "title": "Nakama module"
        }, 
        {
            "location": "/runtime-code-function-reference/#base16", 
            "text": "base16_decode (input)  Base 16 decode the input.  Parameters     Param  Type  Description      input  string  The string which will be base16 decoded.     Returns  The base 16 decoded input.  Example  local   decoded   =   nk . base16_decode ( 48656C6C6F20776F726C64 )  print ( decoded )   -- outputs  Hello world    base16_encode (input)  Base 16 encode the input.  Parameters     Param  Type  Description      input  string  The string which will be base16 encoded.     Returns  The base 16 encoded input.  Example  local   encoded   =   nk . base16_encode ( Hello world )  print ( encoded )   -- outputs  48656C6C6F20776F726C64", 
            "title": "base16"
        }, 
        {
            "location": "/runtime-code-function-reference/#base64", 
            "text": "base64_decode (input)  Base 64 decode the input.  Parameters     Param  Type  Description      input  string  The string which will be base64 decoded.     Returns  The base 64 decoded input.  Example  local   decoded   =   nk . base64_decode ( SGVsbG8gd29ybGQ= )  print ( decoded )   -- outputs  Hello world    base64_encode (input)  Base 64 encode the input.  Parameters     Param  Type  Description      input  string  The string which will be base64 encoded.     Returns  The base 64 encoded input.  Example  local   encoded   =   nk . base64_encode ( Hello world )  print ( encoded )   -- outputs  SGVsbG8gd29ybGQ=", 
            "title": "base64"
        }, 
        {
            "location": "/runtime-code-function-reference/#groups", 
            "text": "groups_create (new_groups)  Setup one or more groups with various configuration settings. The groups will be created if they don't exist or fail if the group names are taken.  Parameters     Param  Type  Description      new_groups  table  The Lua table array of new groups to create.     Example  local   metadata   =   {   -- Add whatever custom fields you want. \n   my_custom_field   =   some value  }  local   group   =   { \n   Name   =   Some unique group name , \n   Description   =   My awesome group. , \n   Lang   =   en , \n   Private   =   true , \n   CreatorId   =   4c2ae592-b2a7-445e-98ec-697694478b1c , \n   AvatarUrl   =   url://somelink , \n   Metadata   =   metadata  }  local   new_groups   =   {   group   }  nk . groups_create ( new_groups )   groups_update (update_groups)  Update one or more groups with various configuration settings. The groups which are updated can change some or all of their fields.  Parameters     Param  Type  Description      update_groups  table  A Lua table of groups to be updated.     Example  local   metadata   =   { \n   some_field   =   some value  }  local   group   =   { \n   GroupId   =   f00fa79a-750f-11e7-8626-0fb79f45ff97 , \n   Description   =   An updated description. , \n   Metadata   =   metadata  }  local   update_groups   =   {   group   }  nk . groups_update ( update_groups )   groups_user_list (user_id)  List all groups which a user belongs to and whether they've been accepted into the group or if it's an invite.  Parameters     Param  Type  Description      user_id  string  The Id of the user who's groups you want to list.     Returns  A list of groups for the user.  Example  local   user_id   =   64ef6cb0-7512-11e7-9e52-d7789d80b70b  local   groups   =   nk . groups_user_list ( user_id )  for   _ ,   g   in   ipairs ( groups )  do \n   local   msg   =   ( Group name %q with id %q ): format ( g . Name ,   g . Id ) \n   print ( msg )  end   group_users_list (group_id)  List all members and admins which belong to a group.  Parameters     Param  Type  Description      group_id  string  The Id of the group who's members and admins you want to list.     Returns  The members and admins for the group.  Example  local   group_id   =   a1aafe16-7540-11e7-9738-13777fcc7cd8  local   members   =   nk . group_users_list ( group_id )  for   _ ,   m   in   ipairs ( members )  do \n   local   msg   =   ( Member handle %q has status %q ): format ( m . Handle ,   m . Type ) \n   print ( msg )  end", 
            "title": "groups"
        }, 
        {
            "location": "/runtime-code-function-reference/#http", 
            "text": "http_request (url, method, headers, content)  Send a HTTP request and receive the result as a Lua table.  Parameters     Param  Type  Description      url  string  The URL of the web resource to request.    method  string  The HTTP method verb used with the request.    headers  table  A table of headers used with the request.    content  string  The bytes to send with the request.     Returns  code, headers, body  - Multiple return values for the HTTP response.  Example  local   url   =   https://google.com/  local   method   =   HEAD  local   headers   =   { \n   [ Content-Type ]   =   application/json , \n   [ Accept ]   =   application/json  }  local   content   =   nk . json_encode ({})   -- encode table as JSON string  local   success ,   code ,   headers ,   body   =   pcall ( nk . http_request ,   url ,   method ,   headers ,   content )  if   ( not   success )   then \n   nk . logger_error (( Failed %q ): format ( code ))  elseif   ( code   =   400 )   then \n   nk . logger_error (( Failed %q %q ): format ( code ,   body ))  else \n   nk . logger_info (( Success %q %q ): format ( code ,   body ))  end", 
            "title": "http"
        }, 
        {
            "location": "/runtime-code-function-reference/#json", 
            "text": "json_decode (input)  Decode the JSON input as a Lua table.  Parameters     Param  Type  Description      input  string  The JSON encoded input.     Returns  A Lua table with the decoded JSON.  Example  local   json   =   nk . json_decode ( { hello :  world } )  print ( json . hello )    json_encode (input)  Encode the input as JSON.  Parameters     Param  Type  Description      input  string  The input to encode as JSON.     Returns  The encoded JSON string.  Example  local   input   =   {[ some ]   =   json }  local   json   =   nk . json_encode ( input )  print ( json )   -- outputs  { some :  json }", 
            "title": "json"
        }, 
        {
            "location": "/runtime-code-function-reference/#leaderboard", 
            "text": "leaderboard_create (id, sort, reset, metadata, authoritative)  Setup a new dynamic leaderboard with the specified ID and various configuration settings. The leaderboard will be created if it doesn't already exist.  Parameters     Param  Type  Description      id  string  The unique identifier for the new leaderboard. This is used by clients to submit scores.    sort  string  The sort order for records in the leaderboard; possible values are \"asc\" or \"desc\".    reset  string  The cron format used to define the reset schedule for the leaderboard. This controls when a leaderboard is reset and can be used to power daily/weekly/monthly leaderboards.    metadata  table  The metadata you want associated to the leaderboard. Some good examples are weather conditions for a racing game.    authoritative  bool  Mark the leaderboard as authoritative which ensures updates can only be made via the Lua runtime. No client can submit a score directly.     Example  local   metadata   =   { \n   weather_conditions   =   rain  }  local   id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521  nk . leaderboard_create ( id ,   desc ,   0 0 * * 1 ,   metadata ,   false )", 
            "title": "leaderboard"
        }, 
        {
            "location": "/runtime-code-function-reference/#logger", 
            "text": "logger_error (message)  Write an ERROR level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with ERROR level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_error ( message )    logger_info (message)  Write an INFO level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with INFO level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_info ( message )    logger_warn (message)  Write an WARN level message to the server logs.  Parameters     Param  Type  Description      message  string  The message to write to server logs with WARN level severity.     Returns  (string) - The message which was written to the logs.  Example  local   message   =   ( %q - %q ): format ( hello ,   world )  nk . logger_warn ( message )", 
            "title": "logger"
        }, 
        {
            "location": "/runtime-code-function-reference/#notifications", 
            "text": "notifications_send_id (new_notifications)  Send one or more in-app notifications to a user. Have a look at the section on  in-app notifications .  Parameters     Param  Type  Description      new_notifications  table  The Lua table array of notifications to send.     Example  local   subject   =   You ve unlocked level 100!  local   content   =   nk . json_encode ({ \n   reward_coins   =   1000  })  local   user_id   =   4c2ae592-b2a7-445e-98ec-697694478b1c   -- who to send  local   code   =   101  local   new_notifications   =   { \n   {   Subject   =   subject ,   Content   =   content ,   UserId   =   user_id ,   Code   =   code ,   Persistent   =   true }  }  nk . notifications_send_id ( new_notifications )", 
            "title": "notifications"
        }, 
        {
            "location": "/runtime-code-function-reference/#register-hooks", 
            "text": "register_after (func, msgname)  Register a function with the server which will be executed after every message with the specified message name.  This can be used to apply custom logic to standard features in the server. Similar to the  register_before  function but it will not block the execution pipeline. The logic will be executed in parallel to any response message sent back to a client. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each  msgname  message.    msgname  string  The specific message name to execute the  func  function after.     Example  local   function   my_func ( context ,   payload ) \n   -- run some code  end  nk . register_after ( my_func ,   TFriendsAdd )    register_before (func, msgname)  Register a function with the server which will be executed before every message with the specified message name.  For example  register_before(somefunc, \"TFriendAdd\")  will execute the function before the Friend Add message is executed by the server's message pipeline. This can be used to apply custom conditions to standard features in the server. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each  msgname  message.    msgname  string  The specific message name to execute the  func  function before.      Note  The  func  should pass the  payload  back as a return argument so the pipeline can continue to execute the standard logic.   Example  local   function   my_func ( context ,   payload ) \n   -- run some code \n   return   payload   -- important!  end  nk . register_before ( my_func ,   TFriendsAdd )    register_http (func, path)  Registers a HTTP endpoint within the server.   Warning  This should not be used to implement custom client functions instead have a look at  register_rpc .   This can be useful to define web callbacks to handle various Ad networks. It can also be used to enable server to server communication to ease the integration of Nakama server into various server stacks. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each HTTP call.    path  string  The path that should be registered as a HTTP endpoint.      Note  The  func  can pass  nil  or  table  back as a return argument which will determine the HTTP response code returned.   Example  local   function   my_func ( context ,   payload ) \n   -- let s return the  context  as JSON back in the HTTP response body \n   return   context  end  nk . register_http ( my_func ,   /my_endpoint )  --  my_func  will be registered at  POST /runtime/my_endpoint   You can send a request to the HTTP endpoint with JSON and responses will be returned in JSON.  curl -X POST http://127.0.0.1:7350/runtime/my_endpoint?key = defaultkey  \\ \n     -d  { some :  data }   \\ \n     -H  Content-Type: application/json   \\ \n     -H  Accept: application/json    register_rpc (func, id)  Registers a function for use with client RPC to the server.  The ID can be any string identifier and is sent by the client. The ID is used to map the client RPC message to the specific function to execute. Have a look at the section on  runtime code basics .  Parameters     Param  Type  Description      func  function  A function reference which will be executed on each RPC message.    id  string  The unique identifier used to register the  func  function for RPC.      Note  The  func  can pass  nil  or  string  back as a return argument which will returned as bytes in the RPC response.   Example  local   function   my_func ( context ,   payload ) \n   -- run some code  end  nk . register_rpc ( my_func ,   my_func_id )", 
            "title": "register hooks"
        }, 
        {
            "location": "/runtime-code-function-reference/#storage", 
            "text": "storage_fetch (record_keys)  Fetch one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      record_keys  table  A table array of record identifiers to be fetched.     Returns  A table array of the records result set.  Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   record_keys   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id }  }  local   records   =   nk . storage_fetch ( record_keys )  for   _ ,   r   in   ipairs ( records )  do \n   local   message   =   ( read: %q, write: %q, value: %q ): format ( r . PermissionRead ,   r . PermissionWrite ,   r . Value ) \n   print ( message )  end    storage_remove (record_keys)  Remove one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      record_keys  table  A table array of record identifiers to be removed.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   record_keys   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id }, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id }  }  nk . storage_remove ( record_keys )    storage_update (record_keys)  Update one or more records by their bucket/collection/keyname and optional user. Have a look at the section on  storage collections .  Parameters     Param  Type  Description      record_keys  table  A table array of records to update.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   now   =   os.time ()   *   1000   -- current time converted for msec  local   update_ops   =   { \n   { Op   =   init ,   Path   =   / ,   Value   =   {   progress   =   1   }}, \n   { Op   =   incr ,   Path   =   /progress ,   Value   =   1 }, \n   { Op   =   replace ,   Path   =   /updated_at ,   Value   =   now }  }  local   record_keys   =   { \n   { Bucket   =   b ,   Collection   =   c ,   Record   =   r ,   UserId   =   user_id ,   UpdateOps   =   update_ops }  }  nk . storage_update ( record_keys )    storage_write (new_records)  Write one or more records by their bucket/collection/keyname and optional user.  Parameters     Param  Type  Description      new_records  table  A table array of new records to write.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   new_records   =   { \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save1 ,   UserId   =   user_id ,   Value   =   {}}, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save2 ,   UserId   =   user_id ,   Value   =   {}}, \n   { Bucket   =   mygame ,   Collection   =   save ,   Record   =   save3 ,   UserId   =   user_id ,   Value   =   {}}  }  nk . storage_write ( new_records )", 
            "title": "storage"
        }, 
        {
            "location": "/runtime-code-function-reference/#users", 
            "text": "users_ban (user_ids)  Ban one or more users from the server.  Parameters     Param  Type  Description      user_ids  table  A table array of user IDs to be banned.     Example  local   user_ids   =   { 4c2ae592-b2a7-445e-98ec-697694478b1c }  local   status ,   result   =   pcall ( nk . users_ban ,   user_ids )  if   ( not   status )   then \n   print ( result )  end    users_fetch_handle (user_handles)  Fetch a set of users by handle.  Parameters     Param  Type  Description      user_handles  table  A table array of user handles to fetch.     Returns  A table array of the user result set.  Example  local   user_handles   =   { b7865e7e ,   c048ba7a }  local   users   =   nk . users_fetch_handle ( user_handles )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( id: %q, fullname: %q ): format ( u . Id ,   u . Fullname ) \n   print ( message )  end    users_fetch_id (user_ids)  Fetch one or more users by ID.  Parameters     Param  Type  Description      user_ids  table  A table array of user IDs to fetch.     Returns  A table array of the user result set.  Example  local   user_ids   =   { \n   3ea5608a-43c3-11e7-90f9-7b9397165f34 , \n   447524be-43c3-11e7-af09-3f7172f05936  }  local   users   =   nk . user_fetch_id ( user_ids )  for   _ ,   u   in   ipairs ( users )  do \n   local   message   =   ( handle: %q, fullname: %q ): format ( u . Handle ,   u . Fullname ) \n   print ( message )  end    users_update (user_updates)  Update one or more users.  Parameters     Param  Type  Description      user_updates  table  The table array of users to update.     Example  local   user_id   =   4ec4f126-3f9d-11e7-84ef-b7c182b36521   -- some user ID.  local   user_updates   =   { \n   {   UserId   =   user_id ,   Metadata   =   {}   }  }  local   status ,   err   =   pcall ( nk . users_update ,   user_updates )  if   ( not   status )   then \n   print (( User update error: %q ): format ( err ))  end", 
            "title": "users"
        }, 
        {
            "location": "/runtime-code-function-reference/#uuid", 
            "text": "uuid_v4 ()  Generate a version 4 UUID.  Returns  The generated version 4 UUID identifier.  Example  local   uuid   =   nk . uuid_v4 ()  print ( uuid )", 
            "title": "uuid"
        }, 
        {
            "location": "/deployment-digital-ocean/", 
            "text": "Deploy on Digital Ocean\n\n\nRunning Nakama in a Digital Ocean droplet is a great way to develop using Nakama without needing to install it locally.\n\n\nYou can install Nakama on your Digital Ocean droplet using the \nDocker installation guide\n but first there are some things that need to be configured on the droplet.\n\n\nDroplet configuration\n\n\nYour droplet should have the following configuration:\n\n\n\n\nLinux distribution: \nUbuntu 16.04 x64\n\n\nRAM: \n4GB RAM\n / 60GB SSD Disk\n\n\nStorage: Optionally add block storage (you\nll need this to keep your data intact between restarts)\n\n\nRegion: To minimise latency, choose a region close to you.\n\n\nAdd a new SSH Key: \nThis is important\n. Follow \nDigital Ocean\ns guide\n if you need help setting up a public key.\n\n\n\n\n\n\nSSH Key\n\n\nYou must create a new SSH key and store the key safely. This is the way you'll login to your server.\n\n\n\n\nAccessing the droplet\n\n\nOnce the droplet is running, make a note of its IP address from within your Digital Ocean console.\n\n\n\n\nFor the next steps, you need to SSH into the droplet. There isn\nt a need for username/password as you\nve pre-authorized yourself using a public key in the previous step.\n\n\nssh root@\nIP ADDRESS\n\n\n# you are now connected to the droplet through an SSH session.\n\n\n# you can type `exit` to close the session.\n\n\n\n\n\n\nCreating a user to run Nakama\n\n\nYou should create a separate user, with sudo privileges, to run Nakama. You\nll see how in this guide.\n\n\nInstalling Docker Compose\n\n\nTo prepare for installing Nakama, you\nll need to install both Docker and Docker Compose on your droplet.\n\n\nThe most straightforward way to do that is to follow Digital Ocean\ns own guides:\n\n\n\n\nInstall Docker on your droplet\n\n\nInstall Docker Compose on your droplet\n\n\n\n\nRunning Nakama\n\n\nNow that you\nve installed Docker and Docker Compose you can follow our guide to \ninstalling Nakama using Docker\n.", 
            "title": "Digital Ocean"
        }, 
        {
            "location": "/deployment-digital-ocean/#deploy-on-digital-ocean", 
            "text": "Running Nakama in a Digital Ocean droplet is a great way to develop using Nakama without needing to install it locally.  You can install Nakama on your Digital Ocean droplet using the  Docker installation guide  but first there are some things that need to be configured on the droplet.", 
            "title": "Deploy on Digital Ocean"
        }, 
        {
            "location": "/deployment-digital-ocean/#droplet-configuration", 
            "text": "Your droplet should have the following configuration:   Linux distribution:  Ubuntu 16.04 x64  RAM:  4GB RAM  / 60GB SSD Disk  Storage: Optionally add block storage (you ll need this to keep your data intact between restarts)  Region: To minimise latency, choose a region close to you.  Add a new SSH Key:  This is important . Follow  Digital Ocean s guide  if you need help setting up a public key.    SSH Key  You must create a new SSH key and store the key safely. This is the way you'll login to your server.", 
            "title": "Droplet configuration"
        }, 
        {
            "location": "/deployment-digital-ocean/#accessing-the-droplet", 
            "text": "Once the droplet is running, make a note of its IP address from within your Digital Ocean console.   For the next steps, you need to SSH into the droplet. There isn t a need for username/password as you ve pre-authorized yourself using a public key in the previous step.  ssh root@ IP ADDRESS  # you are now connected to the droplet through an SSH session.  # you can type `exit` to close the session.", 
            "title": "Accessing the droplet"
        }, 
        {
            "location": "/deployment-digital-ocean/#creating-a-user-to-run-nakama", 
            "text": "You should create a separate user, with sudo privileges, to run Nakama. You ll see how in this guide.", 
            "title": "Creating a user to run Nakama"
        }, 
        {
            "location": "/deployment-digital-ocean/#installing-docker-compose", 
            "text": "To prepare for installing Nakama, you ll need to install both Docker and Docker Compose on your droplet.  The most straightforward way to do that is to follow Digital Ocean s own guides:   Install Docker on your droplet  Install Docker Compose on your droplet", 
            "title": "Installing Docker Compose"
        }, 
        {
            "location": "/deployment-digital-ocean/#running-nakama", 
            "text": "Now that you ve installed Docker and Docker Compose you can follow our guide to  installing Nakama using Docker .", 
            "title": "Running Nakama"
        }, 
        {
            "location": "/tutorial-initialize-new-user/", 
            "text": "Initialize a new user\n\n\nIt's often useful when a new user registers to have a bunch of records setup for them. In games this could be needed for a user's virtual wallet, initial inventory items, etc. In this tutorial we'll cover a few different ways to handle this use case.\n\n\n\n\nSummary\n\n\nWhile there are various ways to solve this use case we highly recommend you \ninitialize the records on usage\n.\n\n\n\n\nAfter register callback\n\n\nThe simplest approach is to write records in the success callback for the register function in a client.\n\n\nThis code demonstrates how to do it with a condensed example. In real application code you'll break up the \nauthentication\n and connect logic from the storage writes based on how you manage connect and reconnect.\n\n\nvar\n \nerrorHandler\n \n=\n \ndelegate\n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n};\n\n\n\nvar\n \nid\n \n=\n \nSystemInfo\n.\ndeviceUniqueIdentifier\n;\n\n\n// Use one of the user register messages.\n\n\nvar\n \nauthMessage\n \n=\n \nNAuthenticateMessage\n.\nDevice\n(\nid\n);\n\n\nclient\n.\nRegister\n(\nauthMessage\n,\n \n(\nINSession\n \nsession\n)\n \n=\n \n{\n\n  \nclient\n.\nConnect\n(\nsession\n,\n \n(\nbool\n \ndone\n)\n \n=\n \n{\n\n    \nvar\n \njsonString\n \n=\n \n{\\\ncoins\\\n: 100, \\\ngems\\\n: 10, \\\nartifacts\\\n: 0}\n;\n\n    \nbyte\n[]\n \njson\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njsonString\n);\n\n\n    \nvar\n \nmessage\n \n=\n \nnew\n \nNStorageWriteMessage\n.\nBuilder\n()\n\n        \n.\nWrite\n(\nmygame\n,\n \nwallets\n,\n \nmywallet\n,\n \njson\n)\n\n        \n.\nBuild\n();\n\n    \nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINStorageKey\n \nlist\n)\n \n=\n \n{\n\n      \nDebug\n.\nLog\n(\nSuccessfully setup new user\ns records.\n);\n\n    \n},\n \nerrorHandler\n);\n\n  \n});\n\n\n},\n \nerrorHandler\n);\n\n\n\n\n\n\nThis code has tradeoffs which should be noted. A disconnect can happen before the records are written to storage. This may leave the setup of the user incomplete and the application in a bad state.\n\n\nThis option is only worth choosing when you want to avoid writing server-side code or have built retry logic on top of a client.\n\n\nServer-side hook\n\n\nAnother way to write records for the new user is to run server-side code after registration has completed. This can be done with a \nregister hook\n.\n\n\nThe \n\"register_after\"\n hook can be used with one of the \n\"authenticaterequest_*\"\n message types to tell the server to run a function after that message has been processed. It's important to note that the server does not distinguish between register and login messages so we use a \nconditional write\n to store the records.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nfunction\n \ninitialize_user\n(\ncontext\n,\n \n_payload\n)\n\n  \nlocal\n \nvalue\n \n=\n \n{\n\n    \ncoins\n \n=\n \n100\n,\n\n    \ngems\n \n=\n \n10\n,\n\n    \nartifacts\n \n=\n \n0\n\n  \n}\n\n  \nlocal\n \nrecord\n \n=\n \n{\n\n    \nBucket\n \n=\n \nmygame\n,\n\n    \nCollection\n \n=\n \nwallets\n,\n\n    \nRecord\n \n=\n \nmywallet\n,\n\n    \nUserId\n \n=\n \ncontext\n.\nUserId\n,\n\n    \nValue\n \n=\n \nvalue\n,\n\n    \nVersion\n \n=\n \n*\n   \n-- only write record if one doesn\nt already exist.\n\n  \n}\n\n  \npcall\n(\nnk\n.\nstorage_write\n,\n \n{\n \nrecord\n \n})\n \n-- write record, ignore errors.\n\n\nend\n\n\n\n-- change to whatever message name matches your authentication type.\n\n\nnk\n.\nregister_after\n(\ninitialize_user\n,\n \nauthenticaterequest_device\n)\n\n\n\n\n\n\nThis approach avoids the tradeoff with client disconnects but requires a database write to happen after every login or register message. This could be acceptable depending on how frequently you write data to the storage engine and can be minimized if you \ncache a user's session\n for quick reconnects.\n\n\nInitialize record when used\n\n\nThe last way to write initial records for the user is to \n\"init\"\n the record with a storage update wherever it's written to in application code. With this approach you never use storage writes and always perform all write operations as updates.\n\n\nIn our example it means wherever you will update the \"mywallet\" record you ensure it's been initialized first.\n\n\nvar\n \njsonString\n \n=\n \n{\\\ncoins\\\n: 100, \\\ngems\\\n: 10, \\\nartifacts\\\n: 0}\n;\n\n\nbyte\n[]\n \njson\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\njsonString\n);\n\n\n\nvar\n \nmessage\n \n=\n \nnew\n \nNStorageUpdateMessage\n.\nBuilder\n()\n\n    \n.\nUpdate\n(\nmygame\n,\n \nwallets\n,\n \nmywallet\n,\n \nnew\n \nStorageUpdateBuilder\n()\n\n        \n.\nInit\n(\n/\n,\n \njson\n)\n     \n// make sure record is setup.\n\n        \n.\nIncr\n(\n/coins\n,\n \n-\n10\n)\n \n// perform other updates to the record.\n\n        \n.\nBuild\n())\n\n    \n.\nBuild\n();\n\n\nclient\n.\nSend\n(\nmessage\n,\n \n(\nINResultSet\nINStorageKey\n \nlist\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n(\nUpdated user\ns storage records.\n);\n\n\n},\n \n(\nINError\n \nerr\n)\n \n{\n\n  \nDebug\n.\nLogErrorFormat\n(\nError: code \n{0}\n with \n{1}\n.\n,\n \nerr\n.\nCode\n,\n \nerr\n.\nMessage\n);\n\n\n});\n\n\n\n\n\n\nYou can also perform the \"initialize before update\" with server-side code.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nvalue\n \n=\n \n{\n\n  \ncoins\n \n=\n \n100\n,\n\n  \ngems\n \n=\n \n10\n,\n\n  \nartifacts\n \n=\n \n0\n\n\n}\n\n\nlocal\n \nupdate_ops\n \n=\n \n{\n\n  \n{\n \nOp\n \n=\n \ninit\n,\n \nPath\n \n=\n \n/\n,\n \nValue\n \n=\n \nvalue\n \n},\n \n-- make sure record is setup.\n\n\n  \n-- perform other updates to the record.\n\n  \n{\n \nOp\n \n=\n \nincr\n,\n \nPath\n \n=\n \n/coins\n,\n \nValue\n \n=\n \n-\n10\n \n}\n\n\n}\n\n\nlocal\n \nrecord\n \n=\n \n{\n\n  \nBucket\n \n=\n \nmygame\n,\n\n  \nCollection\n \n=\n \nwallets\n,\n\n  \nRecord\n \n=\n \nmywallet\n,\n\n  \nUserId\n \n=\n \ncontext\n.\nUserId\n,\n\n  \nUpdate\n \n=\n \nupdate_ops\n\n\n}\n\n\nnk\n.\nstorage_update\n({\n \nrecord\n \n})\n\n\n\n\n\n\nThis is our recommended approach. It has no tradeoffs compared with the other approaches except that you must remember to add \n\"init\"\n logic wherever the record would be updated.", 
            "title": "Initialize a new user"
        }, 
        {
            "location": "/tutorial-initialize-new-user/#initialize-a-new-user", 
            "text": "It's often useful when a new user registers to have a bunch of records setup for them. In games this could be needed for a user's virtual wallet, initial inventory items, etc. In this tutorial we'll cover a few different ways to handle this use case.   Summary  While there are various ways to solve this use case we highly recommend you  initialize the records on usage .", 
            "title": "Initialize a new user"
        }, 
        {
            "location": "/tutorial-initialize-new-user/#after-register-callback", 
            "text": "The simplest approach is to write records in the success callback for the register function in a client.  This code demonstrates how to do it with a condensed example. In real application code you'll break up the  authentication  and connect logic from the storage writes based on how you manage connect and reconnect.  var   errorHandler   =   delegate ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  };  var   id   =   SystemInfo . deviceUniqueIdentifier ;  // Use one of the user register messages.  var   authMessage   =   NAuthenticateMessage . Device ( id );  client . Register ( authMessage ,   ( INSession   session )   =   { \n   client . Connect ( session ,   ( bool   done )   =   { \n     var   jsonString   =   {\\ coins\\ : 100, \\ gems\\ : 10, \\ artifacts\\ : 0} ; \n     byte []   json   =   Encoding . UTF8 . GetBytes ( jsonString ); \n\n     var   message   =   new   NStorageWriteMessage . Builder () \n         . Write ( mygame ,   wallets ,   mywallet ,   json ) \n         . Build (); \n     client . Send ( message ,   ( INResultSet INStorageKey   list )   =   { \n       Debug . Log ( Successfully setup new user s records. ); \n     },   errorHandler ); \n   });  },   errorHandler );   This code has tradeoffs which should be noted. A disconnect can happen before the records are written to storage. This may leave the setup of the user incomplete and the application in a bad state.  This option is only worth choosing when you want to avoid writing server-side code or have built retry logic on top of a client.", 
            "title": "After register callback"
        }, 
        {
            "location": "/tutorial-initialize-new-user/#server-side-hook", 
            "text": "Another way to write records for the new user is to run server-side code after registration has completed. This can be done with a  register hook .  The  \"register_after\"  hook can be used with one of the  \"authenticaterequest_*\"  message types to tell the server to run a function after that message has been processed. It's important to note that the server does not distinguish between register and login messages so we use a  conditional write  to store the records.  local   nk   =   require ( nakama )  local   function   initialize_user ( context ,   _payload ) \n   local   value   =   { \n     coins   =   100 , \n     gems   =   10 , \n     artifacts   =   0 \n   } \n   local   record   =   { \n     Bucket   =   mygame , \n     Collection   =   wallets , \n     Record   =   mywallet , \n     UserId   =   context . UserId , \n     Value   =   value , \n     Version   =   *     -- only write record if one doesn t already exist. \n   } \n   pcall ( nk . storage_write ,   {   record   })   -- write record, ignore errors.  end  -- change to whatever message name matches your authentication type.  nk . register_after ( initialize_user ,   authenticaterequest_device )   This approach avoids the tradeoff with client disconnects but requires a database write to happen after every login or register message. This could be acceptable depending on how frequently you write data to the storage engine and can be minimized if you  cache a user's session  for quick reconnects.", 
            "title": "Server-side hook"
        }, 
        {
            "location": "/tutorial-initialize-new-user/#initialize-record-when-used", 
            "text": "The last way to write initial records for the user is to  \"init\"  the record with a storage update wherever it's written to in application code. With this approach you never use storage writes and always perform all write operations as updates.  In our example it means wherever you will update the \"mywallet\" record you ensure it's been initialized first.  var   jsonString   =   {\\ coins\\ : 100, \\ gems\\ : 10, \\ artifacts\\ : 0} ;  byte []   json   =   Encoding . UTF8 . GetBytes ( jsonString );  var   message   =   new   NStorageUpdateMessage . Builder () \n     . Update ( mygame ,   wallets ,   mywallet ,   new   StorageUpdateBuilder () \n         . Init ( / ,   json )       // make sure record is setup. \n         . Incr ( /coins ,   - 10 )   // perform other updates to the record. \n         . Build ()) \n     . Build ();  client . Send ( message ,   ( INResultSet INStorageKey   list )   =   { \n   Debug . Log ( Updated user s storage records. );  },   ( INError   err )   { \n   Debug . LogErrorFormat ( Error: code  {0}  with  {1} . ,   err . Code ,   err . Message );  });   You can also perform the \"initialize before update\" with server-side code.  local   nk   =   require ( nakama )  local   value   =   { \n   coins   =   100 , \n   gems   =   10 , \n   artifacts   =   0  }  local   update_ops   =   { \n   {   Op   =   init ,   Path   =   / ,   Value   =   value   },   -- make sure record is setup. \n\n   -- perform other updates to the record. \n   {   Op   =   incr ,   Path   =   /coins ,   Value   =   - 10   }  }  local   record   =   { \n   Bucket   =   mygame , \n   Collection   =   wallets , \n   Record   =   mywallet , \n   UserId   =   context . UserId , \n   Update   =   update_ops  }  nk . storage_update ({   record   })   This is our recommended approach. It has no tradeoffs compared with the other approaches except that you must remember to add  \"init\"  logic wherever the record would be updated.", 
            "title": "Initialize record when used"
        }, 
        {
            "location": "/tutorial-remote-configuration/", 
            "text": "Remote configuration\n\n\nRemote configuration is a way to customize the behavior of an app or game via in-app parameters stored on a remote server. This can be used to implement \nfeature flags\n or adjust settings which change the appearance or behavior of the app or game.\n\n\nDevelopers can use remote configuration to remove the hassle of a lengthy review process or modifying the game or app and then waiting for users to update. This makes it especially useful with mobile projects.\n\n\nManage In-app parameters\n\n\nThe configuration settings sent to the app or game need to be stored on the server. The best way to store the information depends on how often the data will be changed.\n\n\nFor mostly static data it's most efficient to embed it as data structures in server-side code and for more dynamic data it's better to use a read-only \nstorage record\n.\n\n\nWith both of these approaches you can access remote configuration before you've done \nregister/login\n or connected with a \nuser session\n. The in-app parameters you configure can be initialized at the earliest point of application startup.\n\n\nStatic parameters\n\n\nThe simplest approach uses server-side code to represent the in-app parameters as a static variable. A change to the parameters after the server has started would require an update to the Lua code and a server restart.\n\n\nThe code could be stored in a module named \n\"rc.lua\"\n and placed in the runtime path for the server.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\n-- In-app parameters stored in a static variable.\n\n\nlocal\n \nparameters\n \n=\n \n{\n\n  \nreachable_levels\n \n=\n \n10\n,\n\n  \nmax_player_level\n \n=\n \n90\n,\n\n  \nmin_version\n \n=\n \n12\n\n\n}\n\n\n\nlocal\n \nfunction\n \nremote_configuration\n(\n_context\n,\n \n_payload\n)\n\n  \nreturn\n \n{\n \nrc\n \n=\n \nparameters\n \n}\n\n\nend\n\n\n\nnk\n.\nregister_http\n(\nremote_configuration\n,\n \nrc\n)\n\n\n\n\n\n\nDynamic parameters\n\n\nFor in-app parameters which may be changed via Analytics or with a Liveops dashboard it's more flexible to store the configuration settings in the \nstorage engine\n as a read-only record.\n\n\nSame as above we'll use server-side code with a module named \n\"rc.lua\"\n and placed in the runtime path for the server.\n\n\nlocal\n \nnk\n \n=\n \nrequire\n(\nnakama\n)\n\n\n\nlocal\n \nparameters\n \n=\n \n{\n\n  \nreachable_levels\n \n=\n \n10\n,\n\n  \nmax_player_level\n \n=\n \n90\n,\n\n  \nmin_version\n \n=\n \n12\n\n\n}\n\n\n\nlocal\n \nrecord\n \n=\n \n{\n\n  \nBucket\n \n=\n \napp\n,\n\n  \nCollection\n \n=\n \nconfiguration\n,\n\n  \nRecord\n \n=\n \nrc\n,\n\n  \nUserId\n \n=\n \nnil\n,\n\n  \nValue\n \n=\n \nparameters\n,\n\n  \nPermissionRead\n \n=\n \n1\n,\n\n  \nPermissionWrite\n \n=\n \n0\n,\n\n  \nVersion\n \n=\n \n*\n       \n-- only write record if it does not already exist.\n\n\n}\n\n\npcall\n(\nnk\n.\nstorage_write\n,\n \n{\n \nrecord\n \n})\n \n-- write record, ignore errors.\n\n\n\nlocal\n \nfunction\n \nremote_configuration\n(\n_context\n,\n \n_payload\n)\n\n  \nlocal\n \nrc\n \n=\n \n{\n\n    \nBucket\n \n=\n \nrecord\n.\nBucket\n,\n\n    \nCollection\n \n=\n \nrecord\n.\nCollection\n,\n\n    \nRecord\n \n=\n \nrecord\n.\nRecord\n,\n\n    \nUserId\n \n=\n \nnil\n\n  \n}\n\n  \nlocal\n \nrecords\n \n=\n \nnk\n.\nstorage_fetch\n({\n \nrc\n \n})\n\n  \nreturn\n \nrecords\n[\n1\n].\nValue\n\n\nend\n\n\n\nnk\n.\nregister_http\n(\nremote_configuration\n,\n \nrc\n)\n\n\n\n\n\n\nFetch In-app parameters\n\n\nWith either approach used to store in-app parameters you can fetch the configuration with a HTTP request.\n\n\n\n\nTip\n\n\nRemember to change the host, port, and auth values for how you've setup your server.\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nUnity\n\n        \n\n    \n        \n\n            \ncURL\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nvar\n \nhost\n \n=\n \n127.0.0.1\n;\n\n\nvar\n \nport\n \n=\n \n7350\n;\n\n\nvar\n \npath\n \n=\n \nrc\n;\n\n\nvar\n \nauth\n \n=\n \ndefaultkey\n;\n\n\n\nvar\n \nformat\n \n=\n \nhttp://{0}:{1}/runtime/{2}?key={3}\n;\n\n\nvar\n \nurl\n \n=\n \nstring\n.\nFormat\n(\nformat\n,\n \nHost\n,\n \nPort\n,\n \nPath\n,\n \nAuth\n);\n\n\nvar\n \nheaders\n \n=\n \nnew\n \nDictionary\nstring\n,\n \nstring\n();\n\n\nheaders\n.\nAdd\n(\nContent-Type\n,\n \napplication/json\n);\n\n\nheaders\n.\nAdd\n(\nAccept\n,\n \napplication/json\n);\n\n\nvar\n \ncontent\n \n=\n \nEncoding\n.\nUTF8\n.\nGetBytes\n(\n{}\n);\n\n\n\nWWW\n \nwww\n \n=\n \nnew\n \nWWW\n(\nurl\n,\n \ncontent\n,\n \nheaders\n);\n\n\nyield\n \nreturn\n \nwww\n;\n\n\nif\n \n(!\nstring\n.\nIsNullOrEmpty\n(\nwww\n.\nerror\n))\n \n{\n\n    \nDebug\n.\nLogErrorFormat\n(\nError occurred: {0}\n,\n \nwww\n.\nerror\n);\n\n\n}\n \nelse\n \n{\n\n    \nvar\n \nresponse\n \n=\n \nEncoding\n.\nUTF8\n.\nGetString\n(\nwww\n.\nbytes\n);\n\n    \nDebug\n.\nLog\n(\nresponse\n);\n\n    \n// output\n\n    \n// {\nrc\n:{\nmax_player_level\n:90,\nmin_version\n:12,\nreachable_levels\n:10}}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \ncurl -X POST http://127.0.0.1:7350/runtime/rc?key\n=\ndefaultkey \n\\\n\n     -d \n{}\n \n\\\n\n     -H \nContent-Type: application/json\n \n\\\n\n     -H \nAccept: application/json\n\n\n# output\n\n\n# {\nrc\n:{\nmax_player_level\n:90,\nmin_version\n:12,\nreachable_levels\n:10}}", 
            "title": "Remote configuration"
        }, 
        {
            "location": "/tutorial-remote-configuration/#remote-configuration", 
            "text": "Remote configuration is a way to customize the behavior of an app or game via in-app parameters stored on a remote server. This can be used to implement  feature flags  or adjust settings which change the appearance or behavior of the app or game.  Developers can use remote configuration to remove the hassle of a lengthy review process or modifying the game or app and then waiting for users to update. This makes it especially useful with mobile projects.", 
            "title": "Remote configuration"
        }, 
        {
            "location": "/tutorial-remote-configuration/#manage-in-app-parameters", 
            "text": "The configuration settings sent to the app or game need to be stored on the server. The best way to store the information depends on how often the data will be changed.  For mostly static data it's most efficient to embed it as data structures in server-side code and for more dynamic data it's better to use a read-only  storage record .  With both of these approaches you can access remote configuration before you've done  register/login  or connected with a  user session . The in-app parameters you configure can be initialized at the earliest point of application startup.", 
            "title": "Manage In-app parameters"
        }, 
        {
            "location": "/tutorial-remote-configuration/#static-parameters", 
            "text": "The simplest approach uses server-side code to represent the in-app parameters as a static variable. A change to the parameters after the server has started would require an update to the Lua code and a server restart.  The code could be stored in a module named  \"rc.lua\"  and placed in the runtime path for the server.  local   nk   =   require ( nakama )  -- In-app parameters stored in a static variable.  local   parameters   =   { \n   reachable_levels   =   10 , \n   max_player_level   =   90 , \n   min_version   =   12  }  local   function   remote_configuration ( _context ,   _payload ) \n   return   {   rc   =   parameters   }  end  nk . register_http ( remote_configuration ,   rc )", 
            "title": "Static parameters"
        }, 
        {
            "location": "/tutorial-remote-configuration/#dynamic-parameters", 
            "text": "For in-app parameters which may be changed via Analytics or with a Liveops dashboard it's more flexible to store the configuration settings in the  storage engine  as a read-only record.  Same as above we'll use server-side code with a module named  \"rc.lua\"  and placed in the runtime path for the server.  local   nk   =   require ( nakama )  local   parameters   =   { \n   reachable_levels   =   10 , \n   max_player_level   =   90 , \n   min_version   =   12  }  local   record   =   { \n   Bucket   =   app , \n   Collection   =   configuration , \n   Record   =   rc , \n   UserId   =   nil , \n   Value   =   parameters , \n   PermissionRead   =   1 , \n   PermissionWrite   =   0 , \n   Version   =   *         -- only write record if it does not already exist.  }  pcall ( nk . storage_write ,   {   record   })   -- write record, ignore errors.  local   function   remote_configuration ( _context ,   _payload ) \n   local   rc   =   { \n     Bucket   =   record . Bucket , \n     Collection   =   record . Collection , \n     Record   =   record . Record , \n     UserId   =   nil \n   } \n   local   records   =   nk . storage_fetch ({   rc   }) \n   return   records [ 1 ]. Value  end  nk . register_http ( remote_configuration ,   rc )", 
            "title": "Dynamic parameters"
        }, 
        {
            "location": "/tutorial-remote-configuration/#fetch-in-app-parameters", 
            "text": "With either approach used to store in-app parameters you can fetch the configuration with a HTTP request.   Tip  Remember to change the host, port, and auth values for how you've setup your server.   \n                 \n                    \n         \n            \n         \n             Unity \n         \n    \n         \n             cURL \n         \n    \n         \n    \n         \n            \n         \n             var   host   =   127.0.0.1 ;  var   port   =   7350 ;  var   path   =   rc ;  var   auth   =   defaultkey ;  var   format   =   http://{0}:{1}/runtime/{2}?key={3} ;  var   url   =   string . Format ( format ,   Host ,   Port ,   Path ,   Auth );  var   headers   =   new   Dictionary string ,   string ();  headers . Add ( Content-Type ,   application/json );  headers . Add ( Accept ,   application/json );  var   content   =   Encoding . UTF8 . GetBytes ( {} );  WWW   www   =   new   WWW ( url ,   content ,   headers );  yield   return   www ;  if   (! string . IsNullOrEmpty ( www . error ))   { \n     Debug . LogErrorFormat ( Error occurred: {0} ,   www . error );  }   else   { \n     var   response   =   Encoding . UTF8 . GetString ( www . bytes ); \n     Debug . Log ( response ); \n     // output \n     // { rc :{ max_player_level :90, min_version :12, reachable_levels :10}}  }  \n\n         \n    \n         \n             curl -X POST http://127.0.0.1:7350/runtime/rc?key = defaultkey  \\ \n     -d  {}   \\ \n     -H  Content-Type: application/json   \\ \n     -H  Accept: application/json  # output  # { rc :{ max_player_level :90, min_version :12, reachable_levels :10}}", 
            "title": "Fetch In-app parameters"
        }
    ]
}